================================================================================
ZOOGIT PROJECT CONTEXT
================================================================================

================================================================================
DIRECTORY STRUCTURE
================================================================================
.
./.github
./.github/workflows
./.github/workflows/build-android.yml
./.gitignore
./App.tsx
./app.json
./assets
./assets/adaptive-icon.png
./assets/favicon.png
./assets/fonts
./assets/fonts/.gitkeep
./assets/icon.png
./assets/images
./assets/images/.gitkeep
./assets/images/charif_approving.png
./assets/images/charif_listening.png
./assets/images/charif_skeptical.png
./assets/images/charif_speaking.png
./assets/images/drCharif
./assets/images/drCharif/charif_approving.png
./assets/images/drCharif/charif_listening.png
./assets/images/drCharif/charif_skeptical.png
./assets/images/drCharif/charif_speaking.png
./assets/sounds
./assets/sounds/.gitkeep
./assets/splash.png
./babel.config.js
./eas.json
./metro.config.js
./package.json
./project_context.txt
./snack-version
./snack-version/App.js
./src
./src/components
./src/components/common
./src/components/common/Button.tsx
./src/components/common/Card.tsx
./src/components/common/GenderSelector.tsx
./src/components/common/GlassCard.tsx
./src/components/common/GoldButton.tsx
./src/components/common/Input.tsx
./src/components/common/PlayerScoreCard.tsx
./src/components/common/ScreenBackground.tsx
./src/components/common/ScreenContainer.tsx
./src/components/common/TypewriterText.tsx
./src/components/common/index.ts
./src/components/drCharif
./src/components/drCharif/DrCharifAvatar.tsx
./src/components/drCharif/DrCharifExperience.tsx
./src/components/drCharif/DrCharifMessage.tsx
./src/components/drCharif/DrCharifScene.tsx
./src/components/drCharif/DrCharifSpeech.tsx
./src/components/drCharif/DrCharifText.tsx
./src/components/drCharif/TypewriterText.tsx
./src/components/drCharif/index.ts
./src/components/index.ts
./src/data
./src/data/drCharifTexts.ts
./src/data/index.ts
./src/data/prizes.ts
./src/data/questions.ts
./src/data/quizQuestions.ts
./src/data/tasks.ts
./src/navigation
./src/navigation/RootNavigator.tsx
./src/navigation/index.ts
./src/navigation/types.ts
./src/screens
./src/screens/Game
./src/screens/Game/GameIntroScreen.tsx
./src/screens/Game/GamePlayScreen.tsx
./src/screens/Game/IntensitySelectScreen.tsx
./src/screens/Game/StageCompleteScreen.tsx
./src/screens/Game/StageIntroScreen.tsx
./src/screens/Game/index.ts
./src/screens/Onboarding
./src/screens/Onboarding/OnboardingScreen.tsx
./src/screens/Onboarding/index.ts
./src/screens/Paywall
./src/screens/Paywall/PaywallScreen.tsx
./src/screens/Paywall/index.ts
./src/screens/Quiz
./src/screens/Quiz/QuizPlayScreen.tsx
./src/screens/Quiz/QuizResultsScreen.tsx
./src/screens/Quiz/QuizSetupScreen.tsx
./src/screens/Quiz/QuizWaitingScreen.tsx
./src/screens/Quiz/index.ts
./src/screens/Results
./src/screens/Results/ResultsScreen.tsx
./src/screens/Results/WheelScreen.tsx
./src/screens/Results/index.ts
./src/screens/Splash
./src/screens/Splash/SplashScreen.tsx
./src/screens/Splash/index.ts
./src/screens/index.ts
./src/services
./src/services/firebase.ts
./src/store
./src/store/gameStore.ts
./src/store/index.ts
./src/store/quizStore.ts
./src/theme
./src/theme/colors.ts
./src/theme/fonts.ts
./src/theme/index.ts
./src/theme/shadows.ts
./src/theme/spacing.ts
./src/theme/typography.ts
./tsconfig.json
./zoogit-specification.md


================================================================================
FILE CONTENTS
================================================================================


--------------------------------------------------------------------------------
FILE: app.json
--------------------------------------------------------------------------------

{
  "expo": {
    "name": "◊ñ◊ï◊í◊ô◊ò",
    "slug": "zoogit",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "dark",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#12081C"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.zoogit.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#12081C"
      },
      "package": "com.zoogit.app"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "extra": {
      "eas": {
        "projectId": "0bf581af-bd37-438d-b5f9-d1d083cc10e5"
      }
    }
  }
}

--------------------------------------------------------------------------------
FILE: eas.json
--------------------------------------------------------------------------------

{
  "cli": {
    "version": ">= 5.0.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk",
        "credentialsSource": "remote"
      }
    },
    "production": {
      "android": {
        "buildType": "app-bundle"
      }
    }
  },
  "submit": {
    "production": {}
  }
}

--------------------------------------------------------------------------------
FILE: package.json
--------------------------------------------------------------------------------

{
  "name": "zoogit",
  "version": "1.0.0",
  "main": "expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "eslint .",
    "test": "jest"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.0",
    "@react-navigation/bottom-tabs": "^6.5.11",
    "@react-navigation/native": "^6.1.9",
    "@react-navigation/native-stack": "^6.9.17",
    "expo": "~50.0.0",
    "expo-av": "~13.10.0",
    "expo-font": "~11.10.0",
    "expo-haptics": "~12.8.0",
    "expo-blur": "~12.9.0",
    "expo-linear-gradient": "~12.7.0",
    "expo-splash-screen": "~0.26.0",
    "expo-status-bar": "~1.11.0",
    "firebase": "^10.7.1",
    "lottie-react-native": "^6.5.0",
    "react": "18.2.0",
    "react-native": "0.73.2",
    "react-native-gesture-handler": "~2.14.0",
    "react-native-reanimated": "~3.6.1",
    "react-native-safe-area-context": "4.8.2",
    "react-native-screens": "~3.29.0",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@babel/core": "^7.23.7",
    "@types/react": "~18.2.45",
    "babel-plugin-module-resolver": "^5.0.0",
    "typescript": "^5.3.3"
  },
  "private": true
}

--------------------------------------------------------------------------------
FILE: tsconfig.json
--------------------------------------------------------------------------------

{
  "compilerOptions": {
    "target": "esnext",
    "module": "commonjs",
    "lib": ["es2019"],
    "jsx": "react-native",
    "strict": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "exclude": ["node_modules", "babel.config.js", "metro.config.js"]
}

--------------------------------------------------------------------------------
FILE: App.tsx
--------------------------------------------------------------------------------

/**
 * ◊ñ◊ï◊í◊ô◊ò - Zoogit
 *
 * ◊î◊¢◊®◊ë ◊©◊ú◊ê ◊™◊°◊§◊®◊ï ◊¢◊ú◊ô◊ï ◊ë◊ß◊ë◊ï◊¶◊™ ◊î◊ï◊®◊ô◊ù
 * ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ô◊™ ◊ì◊ô◊ô◊ò ◊ñ◊ï◊í◊ô ◊ì◊ô◊í◊ô◊ò◊ú◊ô◊™ ◊¢◊ù ◊û◊†◊ó◊î AI ◊¶◊ô◊†◊ô ◊ï◊û◊®◊í◊©
 */

import React, { useCallback, useEffect, useState } from 'react';
import { View, StyleSheet, I18nManager } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import * as SplashScreen from 'expo-splash-screen';
import * as Font from 'expo-font';

import { RootNavigator } from '@/navigation';
import { colors } from '@/theme/colors';

// Enable RTL for Hebrew
I18nManager.allowRTL(true);
I18nManager.forceRTL(true);

// Keep splash screen visible while loading
SplashScreen.preventAutoHideAsync();

// Custom fonts
const customFonts = {
  'Heebo-Light': require('./assets/fonts/Heebo-Light.ttf'),
  'Heebo-Regular': require('./assets/fonts/Heebo-Regular.ttf'),
  'Heebo-Medium': require('./assets/fonts/Heebo-Medium.ttf'),
  'Heebo-Bold': require('./assets/fonts/Heebo-Bold.ttf'),
  'PlayfairDisplay-Regular': require('./assets/fonts/PlayfairDisplay-Regular.ttf'),
  'PlayfairDisplay-Bold': require('./assets/fonts/PlayfairDisplay-Bold.ttf'),
  'PlayfairDisplay-Italic': require('./assets/fonts/PlayfairDisplay-Italic.ttf'),
};

export default function App() {
  const [appIsReady, setAppIsReady] = useState(false);

  useEffect(() => {
    async function prepare() {
      try {
        // Load fonts
        await Font.loadAsync(customFonts);

        // Add any other initialization here
        // e.g., load saved state, initialize analytics, etc.
      } catch (e) {
        console.warn('Error loading fonts:', e);
      } finally {
        setAppIsReady(true);
      }
    }

    prepare();
  }, []);

  const onLayoutRootView = useCallback(async () => {
    if (appIsReady) {
      // Hide splash screen once app is ready
      await SplashScreen.hideAsync();
    }
  }, [appIsReady]);

  if (!appIsReady) {
    return null;
  }

  return (
    <GestureHandlerRootView style={styles.container}>
      <SafeAreaProvider>
        <View style={styles.container} onLayout={onLayoutRootView}>
          <RootNavigator />
        </View>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
});

--------------------------------------------------------------------------------
FILE: zoogit-specification.md
--------------------------------------------------------------------------------

# ◊ñ◊ï◊í◊ô◊ò - ◊û◊°◊û◊ö ◊ê◊§◊ô◊ï◊ü ◊û◊ú◊ê

## ◊™◊ô◊ê◊ï◊® ◊î◊û◊ï◊¶◊®

**◊©◊ù:** ◊ñ◊ï◊í◊ô◊ò
**◊™◊ô◊ê◊ï◊® ◊©◊ô◊ï◊ï◊ß◊ô:** ◊î◊¢◊®◊ë ◊©◊ú◊ê ◊™◊°◊§◊®◊ï ◊¢◊ú◊ô◊ï ◊ë◊ß◊ë◊ï◊¶◊™ ◊î◊ï◊®◊ô◊ù
**◊ß◊ï◊†◊°◊§◊ò:** ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ô◊™ ◊ì◊ô◊ô◊ò ◊ñ◊ï◊í◊ô ◊ì◊ô◊í◊ô◊ò◊ú◊ô◊™ ◊¢◊ù ◊û◊†◊ó◊î AI ◊¶◊ô◊†◊ô ◊ï◊û◊®◊í◊©

---

## 1. ◊§◊ú◊ò◊§◊ï◊®◊û◊î ◊ï◊ò◊õ◊†◊ï◊ú◊ï◊í◊ô◊î

| ◊§◊®◊û◊ò◊® | ◊¢◊®◊ö |
|-------|-----|
| ◊°◊ò◊ê◊ß | React Native |
| ◊§◊ú◊ò◊§◊ï◊®◊û◊ï◊™ | Android + iOS |
| ◊û◊ï◊ì◊ú ◊©◊ô◊û◊ï◊© | ◊û◊õ◊©◊ô◊® ◊ê◊ó◊ì ◊û◊©◊ï◊™◊£ (◊©◊ú◊ë◊ô◊ù 1-5), ◊©◊†◊ô ◊û◊õ◊©◊ô◊®◊ô◊ù ◊û◊°◊ï◊†◊õ◊®◊†◊ô◊ù (◊©◊ú◊ë 6 - ◊ó◊ô◊ì◊ï◊ü) |
| ◊ó◊ô◊ë◊ï◊® ◊û◊õ◊©◊ô◊®◊ô◊ù | ◊ß◊ï◊ì 4 ◊°◊§◊®◊ï◊™ |

---

## 2. ◊û◊ï◊ì◊ú ◊¢◊°◊ß◊ô

| ◊§◊®◊û◊ò◊® | ◊¢◊®◊ö |
|-------|-----|
| ◊û◊ï◊ì◊ú | Freemium |
| ◊ó◊ô◊†◊ù | ◊©◊ú◊ë◊ô◊ù 1-2 |
| ◊ë◊™◊©◊ú◊ï◊ù | ◊©◊ú◊ë◊ô◊ù 3-7 |
| ◊û◊ó◊ô◊® | 79 ◊©"◊ó (◊ß◊†◊ô◊ô◊î ◊ó◊ì ◊§◊¢◊û◊ô◊™) |

---

## 3. ◊û◊ë◊†◊î ◊î◊û◊©◊ó◊ß

### 3.1 ◊©◊ë◊¢◊™ ◊î◊©◊ú◊ë◊ô◊ù

| ◊©◊ú◊ë | ◊©◊ù | ◊§◊®◊ô◊ò◊ô◊ù | ◊ô◊ó◊° ◊©◊ê◊ú◊ï◊™/◊û◊©◊ô◊û◊ï◊™ | ◊û◊©◊ö |
|-----|-----|--------|------------------|-----|
| 1 | ◊®◊í◊¢ ◊ú◊§◊†◊ô ◊©◊†◊§◊í◊©◊†◊ï | 8 | 70% / 30% | ~10 ◊ì◊ß |
| 2 | ◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™ | 8 | 40% / 60% | ~10 ◊ì◊ß |
| 3 | ◊ì◊ë◊®◊ô◊ù ◊©◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù ◊ë◊ß◊ï◊ú | 8 | 50% / 50% | ~12 ◊ì◊ß |
| 4 | ◊û◊ú◊ó◊û◊™ ◊î◊í◊ô◊®◊°◊ê◊ï◊™ | 8 | 80% / 20% | ~10 ◊ì◊ß |
| 5 | ◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î | 8 | 30% / 70% | ~12 ◊ì◊ß |
| 6 | ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô | 24 ◊©◊ê◊ú◊ï◊™ | 100% ◊©◊ê◊ú◊ï◊™ | ~15-20 ◊ì◊ß |
| 7 | ◊î◊°◊ô◊ï◊ù | ◊í◊ú◊í◊ú ◊û◊ñ◊ú + ◊°◊ô◊õ◊ï◊ù | - | ~5 ◊ì◊ß |

**◊°◊î"◊õ:** 40 ◊§◊®◊ô◊ò◊ô◊ù ◊ë◊©◊ú◊ë◊ô◊ù 1-5 + 24 ◊©◊ê◊ú◊ï◊™ ◊ë◊ó◊ô◊ì◊ï◊ü = 64 ◊§◊®◊ô◊ò◊ô ◊™◊ï◊õ◊ü

### 3.2 ◊û◊†◊í◊†◊ï◊ü ◊û◊©◊ó◊ß

- **◊û◊©◊ó◊ß ◊™◊ï◊®◊ï◊™:** ◊©◊ó◊ß◊ü A ◊©◊ê◊ú◊î/◊û◊©◊ô◊û◊î ‚Üí ◊©◊ó◊ß◊ü B ◊©◊ê◊ú◊î/◊û◊©◊ô◊û◊î
- **◊ì◊®◊í◊ï◊™ ◊™◊¢◊ï◊ñ◊î:** 3 ◊®◊û◊ï◊™ ◊ú◊§◊†◊ô ◊õ◊ú ◊§◊®◊ô◊ò (◊†◊ô◊ß◊ï◊ì ◊û◊ï◊¶◊í ◊û◊®◊ê◊©)
- **◊û◊¢◊®◊õ◊™ ◊ï◊ò◊ï:** ◊û◊ï◊í◊ë◊ú◊™ ◊ë◊õ◊û◊ï◊™, ◊û◊ï◊®◊ô◊ì◊î ◊†◊ß◊ï◊ì◊ï◊™
- **◊™◊ó◊®◊ï◊™:** ◊†◊ô◊ß◊ï◊ì ◊°◊ï◊§◊ô ◊ß◊ï◊ë◊¢ ◊û◊†◊¶◊ó
- **◊í◊ú◊í◊ú ◊û◊ñ◊ú:** 15 ◊§◊®◊°◊ô◊ù ◊ú◊û◊†◊¶◊ó

### 3.3 ◊ê◊õ◊ô◊§◊™ ◊ë◊ô◊¶◊ï◊¢

| ◊°◊ï◊í | ◊û◊†◊í◊†◊ï◊ü |
|-----|--------|
| ◊©◊ê◊ú◊ï◊™ | ◊ó◊ï◊ë◊î ◊ú◊î◊ß◊ú◊ô◊ì ◊™◊©◊ï◊ë◊î (◊ï◊ú◊ï ◊û◊ô◊ú◊î ◊ê◊ó◊™) ◊õ◊ì◊ô ◊ú◊î◊™◊ß◊ì◊ù |
| ◊û◊©◊ô◊û◊ï◊™ ◊§◊ô◊ñ◊ô◊ï◊™ | ◊ê◊ô◊©◊ï◊® ◊ë◊ü ◊î◊ñ◊ï◊í ("◊ë◊ï◊¶◊¢" / "◊ú◊ê ◊ë◊ï◊¶◊¢ - ◊ï◊ò◊ï ◊ê◊ï◊ò◊ï◊û◊ò◊ô") |

---

## 4. ◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ ◊™◊ï◊õ◊ü

### 4.1 ◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ ◊õ◊ú◊ú◊ô◊ï◊™ (◊ú◊©◊ú◊ë◊ô◊ù 1-5)

1. **◊û◊õ◊ï◊†◊™ ◊ñ◊û◊ü** - ◊¢◊ë◊®/◊¢◊™◊ô◊ì ◊¢◊ù ◊ò◊ï◊ï◊ô◊°◊ò
2. **◊¢◊ï◊ú◊û◊ï◊™ ◊û◊ß◊ë◊ô◊ú◊ô◊ù** - ◊™◊®◊ó◊ô◊©◊ô "◊û◊î ◊ê◊ù" ◊û◊ï◊§◊®◊õ◊ô◊ù
3. **◊í◊ï◊£ ◊ï◊†◊§◊©** - ◊û◊ô◊†◊ô◊ï◊™ ◊ì◊®◊ö ◊¢◊ß◊ô◊§◊ô◊ü
4. **◊õ◊°◊£ ◊û◊ì◊ë◊®** - ◊¢◊®◊õ◊ô◊ù ◊ì◊®◊ö ◊ì◊ô◊ú◊û◊ï◊™ ◊õ◊ú◊õ◊ú◊ô◊ï◊™
5. **◊ó◊ë◊®◊î ◊ï◊©◊ô◊§◊ï◊ò** - ◊û◊î ◊ê◊ó◊®◊ô◊ù ◊ó◊ï◊©◊ë◊ô◊ù ◊¢◊ú◊ô◊†◊ï
6. **◊°◊ï◊ì◊ï◊™ ◊ß◊ò◊†◊ô◊ù** - ◊ì◊ë◊®◊ô◊ù ◊©◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊†◊ê◊û◊®◊ï
7. **◊û◊ú◊ó◊û◊™ ◊î◊ê◊í◊ï** - ◊™◊ó◊®◊ï◊™◊ô◊ï◊™ ◊û◊©◊¢◊©◊¢◊™
8. **◊§◊ó◊ì◊ô◊ù ◊ï◊®◊¶◊ï◊†◊ï◊™** - ◊§◊í◊ô◊¢◊ï◊™ ◊ê◊û◊ô◊™◊ô◊™
9. **◊î◊ß◊ò◊†◊ï◊™ ◊©◊î◊ï◊®◊í◊ï◊™** - ◊©◊í◊®◊î ◊ë◊ô◊™◊ô◊™ ◊ë◊ñ◊õ◊ï◊õ◊ô◊™ ◊û◊í◊ì◊ú◊™
10. **◊ú◊ô◊ú◊î ◊ê◊ó◊ì** - ◊§◊†◊ò◊ñ◊ô◊ï◊™ ◊û◊ï◊í◊ì◊®◊ï◊™ ◊î◊ô◊ò◊ë

### 4.2 ◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô (6 ◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ √ó 10 ◊©◊ê◊ú◊ï◊™ = 60 ◊ë◊ë◊†◊ß)

1. **◊¢◊ë◊®** - ◊ê◊ô◊ö ◊î◊õ◊®◊†◊ï, ◊®◊í◊¢◊ô◊ù ◊®◊ê◊©◊ï◊†◊ô◊ù
2. **◊ô◊ï◊û◊ô◊ï◊ù** - ◊î◊®◊í◊ú◊ô◊ù, ◊î◊¢◊ì◊§◊ï◊™, ◊©◊í◊®◊î
3. **◊ó◊ú◊ï◊û◊ï◊™/◊¢◊™◊ô◊ì** - ◊©◊ê◊ô◊§◊ï◊™, ◊§◊ó◊ì◊ô◊ù, ◊ó◊ñ◊ï◊ü
4. **◊í◊ï◊£/◊û◊ô◊†◊ô◊ï◊™** - ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™, ◊î◊¢◊ì◊§◊ï◊™
5. **◊ì◊ô◊ú◊û◊ï◊™ ◊î◊ô◊§◊ï◊ò◊ò◊ô◊ï◊™** - ◊ë◊ó◊ô◊®◊ï◊™ ◊ß◊©◊ï◊™
6. **◊ê◊†◊ó◊†◊ï** - ◊î◊ñ◊ï◊í◊ô◊ï◊™ ◊¢◊¶◊û◊î

### 4.3 ◊õ◊ú◊ú◊ô◊ù ◊ú◊™◊ï◊õ◊ü

- **◊ú◊ú◊ê** ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊©◊ú ◊ê◊ß◊°◊ô◊ù, ◊ß◊†◊ê◊î, ◊¢◊ë◊® ◊®◊ï◊û◊†◊ò◊ô ◊¢◊ù ◊ê◊ó◊®◊ô◊ù
- **6 ◊™◊©◊ï◊ë◊ï◊™** ◊ú◊õ◊ú ◊©◊ê◊ú◊î - ◊©◊ï◊†◊ï◊™ ◊ú◊ó◊ú◊ï◊ò◊ô◊ü ◊ñ◊ï ◊û◊ñ◊ï
- ◊™◊û◊ô◊ì ◊ô◊© ◊™◊©◊ï◊ë◊î ◊©◊û◊™◊ê◊ô◊û◊î
- ◊™◊ï◊õ◊ü ◊ô◊ô◊ó◊ï◊ì◊ô, ◊ú◊ê ◊í◊†◊®◊ô, ◊ú◊ê ◊†◊û◊¶◊ê ◊ë◊û◊©◊ó◊ß◊ô◊ù ◊ê◊ó◊®◊ô◊ù

---

## 5. ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô (◊©◊ú◊ë 6)

| ◊§◊®◊û◊ò◊® | ◊¢◊®◊ö |
|-------|-----|
| ◊û◊°◊§◊® ◊©◊ê◊ú◊ï◊™ | 24 (4 ◊û◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î) |
| ◊û◊†◊í◊†◊ï◊ü | ◊©◊†◊ô ◊û◊õ◊©◊ô◊®◊ô◊ù ◊û◊°◊ï◊†◊õ◊®◊†◊ô◊ù |
| ◊ó◊ô◊ë◊ï◊® | ◊ß◊ï◊ì 4 ◊°◊§◊®◊ï◊™ |
| ◊ñ◊û◊ü | ◊ú◊ú◊ê ◊î◊í◊ë◊ú◊î |
| ◊™◊©◊ï◊ë◊ï◊™ | ◊ë◊û◊ß◊ë◊ô◊ú (◊õ◊ú ◊ê◊ó◊ì ◊û◊î◊ò◊ú◊§◊ï◊ü ◊©◊ú◊ï) |
| ◊™◊ï◊¶◊ê◊ï◊™ | ◊ë◊°◊ï◊£ - ◊õ◊ï◊ú◊ú ◊î◊¶◊í◊™ ◊ò◊¢◊ï◊ô◊ï◊™ ◊ï◊î◊™◊©◊ï◊ë◊ï◊™ ◊î◊†◊õ◊ï◊†◊ï◊™ |
| ◊§◊ï◊®◊û◊ò ◊©◊ê◊ú◊î | "◊û◊î ◊ê◊†◊ô" + "◊û◊î ◊ë◊ü ◊î◊ñ◊ï◊í" |

---

## 6. ◊©◊ú◊ë 5 - "◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î"

◊ú◊§◊†◊ô ◊î◊©◊ú◊ë, ◊î◊û◊©◊™◊û◊©◊ô◊ù ◊ë◊ï◊ó◊®◊ô◊ù ◊ô◊ó◊ì ◊®◊û◊™ ◊¢◊ï◊¶◊û◊î:

| ◊®◊û◊î | ◊™◊ô◊ê◊ï◊® |
|-----|-------|
| Soft | ◊†◊í◊ô◊¢◊ï◊™, ◊ú◊ó◊ô◊©◊ï◊™, ◊†◊©◊ô◊ß◊ï◊™, ◊î◊™◊§◊©◊ò◊ï◊™ ◊ó◊ú◊ß◊ô◊™ |
| Medium | ◊û◊©◊ô◊û◊ï◊™ ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™ ◊û◊§◊ï◊®◊©◊ï◊™ (◊ú◊ê ◊°◊ß◊° ◊û◊ú◊ê) |
| Spicy | ◊î◊õ◊ú ◊¢◊ú ◊î◊©◊ï◊ú◊ó◊ü, ◊õ◊ï◊ú◊ú ◊î◊õ◊ï◊ï◊†◊î ◊ô◊©◊ô◊®◊î ◊ú◊°◊ß◊° |

◊î◊û◊†◊ó◊î (◊ì"◊® ◊ó◊®◊ô◊£) ◊û◊°◊ë◊ô◊® ◊ê◊™ ◊î◊®◊û◊ï◊™ ◊ë◊°◊í◊†◊ï◊ü ◊û◊©◊¢◊©◊¢ ◊ï◊©◊†◊ï◊ü ◊ú◊§◊†◊ô ◊î◊ë◊ó◊ô◊®◊î.

---

## 7. ◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú - 15 ◊§◊®◊°◊ô◊ù

| # | ◊©◊ù | ◊™◊ô◊ê◊ï◊® | ◊™◊ó◊ï◊ù | ◊¢◊ï◊¶◊û◊î |
|---|-----|-------|------|-------|
| 1 | ◊î◊©◊ë◊ï◊¢ ◊©◊ú◊ô | ◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊® ◊ô◊ï◊ù ◊ë◊©◊ë◊ï◊¢ ◊î◊ß◊®◊ï◊ë - ◊õ◊ú ◊î◊ó◊ú◊ò◊î ◊¢◊ú◊ô◊ï | ◊©◊ú◊ô◊ò◊î | üî•üî• |
| 2 | ◊î◊ß◊¢◊ß◊ï◊¢ | ◊ß◊¢◊ß◊ï◊¢ ◊ñ◊û◊†◊ô ◊ë◊û◊ß◊ï◊ù ◊©◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊®, ◊†◊©◊ê◊® ◊©◊ë◊ï◊¢ | ◊í◊ï◊£ | üî•üî• |
| 3 | ◊î◊û◊¶◊ú◊û◊î | ◊î◊û◊†◊¶◊ó ◊û◊¶◊ú◊ù 3 ◊™◊†◊ï◊ó◊ï◊™ ◊©◊î◊ï◊ê ◊ë◊ï◊ó◊® | ◊ê◊ô◊†◊ò◊ô◊û◊ô | üî•üî•üî• |
| 4 | ◊î◊ó◊ï◊ñ◊î | ◊î◊û◊§◊°◊ô◊ì ◊ó◊ï◊™◊ù ◊¢◊ú ◊û◊ó◊ï◊ô◊ë◊ï◊™ ◊ú◊ó◊ï◊ì◊© ◊î◊ß◊®◊ï◊ë | ◊û◊ó◊ï◊ô◊ë◊ï◊™ | üî•üî• |
| 5 | ◊î◊õ◊®◊ò◊ô◊° ◊î◊©◊ó◊ï◊® | ◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊î◊û◊†◊¶◊ó ◊ê◊ï◊û◊® "◊¢◊õ◊©◊ô◊ï" ◊ï◊î◊û◊§◊°◊ô◊ì ◊ë◊ê | ◊õ◊ï◊ó | üî•üî•üî• |
| 6 | ◊î◊ë◊û◊î | ◊§◊ï◊°◊ò ◊¶◊ô◊ë◊ï◊®◊ô ◊©◊î◊û◊†◊¶◊ó ◊û◊õ◊™◊ô◊ë | ◊§◊ï◊û◊ë◊ô | üî•üî• |
| 7 | ◊ú◊ú◊ê ◊ô◊ì◊ô◊ô◊ù | ◊©◊¢◊î ◊ë◊ú◊ô ◊ô◊ì◊ô◊ô◊ù, ◊î◊û◊†◊¶◊ó ◊û◊ê◊õ◊ô◊ú ◊ï◊û◊©◊ß◊î | ◊û◊©◊ó◊ß | üî•üî• |
| 8 | ◊î◊ë◊ï◊ß◊® ◊©◊ê◊ó◊®◊ô | ◊î◊û◊†◊¶◊ó ◊ô◊©◊ü ◊õ◊û◊î ◊©◊®◊ï◊¶◊î, ◊î◊û◊§◊°◊ô◊ì ◊û◊õ◊ô◊ü ◊î◊õ◊ú | ◊§◊ô◊†◊ï◊ß | üî• |
| 9 | ◊î◊§◊†◊ò◊ñ◊ô◊î | ◊î◊û◊†◊¶◊ó ◊û◊™◊ê◊® ◊§◊†◊ò◊ñ◊ô◊î, ◊©◊ë◊ï◊¢◊ô◊ô◊ù ◊ú◊î◊í◊©◊ô◊ù | ◊ê◊ô◊†◊ò◊ô◊û◊ô | üî•üî•üî• |
| 10 | ◊î◊ê◊®◊†◊ß ◊î◊§◊™◊ï◊ó | ◊ß◊†◊ô◊ï◊™ - ◊§◊®◊ô◊ò ◊ê◊ó◊ì ◊ú◊ú◊ê ◊™◊ß◊®◊î | ◊õ◊°◊£ | üî•üî• |
| 11 | ◊î◊î◊ß◊ú◊ò◊î | ◊î◊ï◊ì◊¢◊î ◊ß◊ï◊ú◊ô◊™ ◊©◊ú ◊ì◊ß◊î ◊©◊î◊û◊†◊¶◊ó ◊û◊õ◊™◊ô◊ë | ◊®◊í◊©◊ô | üî• |
| 12 | 24 ◊©◊¢◊ï◊™ | ◊ô◊û◊û◊î ◊©◊î◊û◊§◊°◊ô◊ì ◊ú◊ê ◊ô◊õ◊ï◊ú ◊ú◊î◊í◊ô◊ì "◊ú◊ê" | ◊©◊ú◊ô◊ò◊î | üî•üî•üî• |
| 13 | ◊î◊ì◊ú◊™ ◊†◊¢◊ï◊ú◊î | ◊¢◊®◊ë ◊ë◊ú◊ô ◊ò◊ú◊§◊ï◊†◊ô◊ù - ◊©◊†◊ô◊î◊ù | ◊ó◊ï◊ï◊ô◊î | üî• |
| 14 | ◊î◊ë◊ô◊©◊ï◊ú | ◊ê◊®◊ï◊ó◊™ 3 ◊û◊†◊ï◊™, ◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊® ◊™◊§◊®◊ô◊ò | ◊©◊ô◊®◊ï◊™ | üî•üî• |
| 15 | ◊î◊û◊§◊™◊ó | ◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊î◊û◊†◊¶◊ó ◊ß◊ï◊®◊ê ◊õ◊ú ◊©◊ô◊ó◊î ◊ë◊ò◊ú◊§◊ï◊ü | ◊ê◊û◊ï◊ü | üî•üî•üî• |

---

## 8. ◊î◊û◊†◊ó◊î - ◊ì"◊® ◊ó◊®◊ô◊£

### 8.1 ◊§◊®◊ï◊§◊ô◊ú ◊î◊ì◊û◊ï◊™

| ◊û◊ê◊§◊ô◊ô◊ü | ◊™◊ô◊ê◊ï◊® |
|--------|-------|
| ◊û◊ß◊¶◊ï◊¢ | ◊§◊°◊ô◊õ◊ï◊ú◊ï◊í ◊ï◊û◊ò◊§◊ú ◊ñ◊ï◊í◊ô |
| ◊†◊ô◊°◊ô◊ï◊ü | 30 ◊©◊†◊î ◊ë◊™◊ó◊ï◊ù |
| ◊ê◊ï◊§◊ô | ◊û◊®◊ô◊®, ◊¢◊ï◊ß◊¶◊†◊ô, ◊¶◊ô◊†◊ô |
| ◊¢◊ï◊û◊ß | ◊ó◊ï◊õ◊û◊™ ◊ó◊ô◊ô◊ù ◊û◊ó◊ï◊°◊§◊°◊™ ◊û◊ê◊ó◊ï◊®◊ô ◊î◊¶◊ô◊†◊ô◊ï◊™ |
| ◊®◊í◊© | ◊û◊®◊í◊© ◊ë◊ê◊ï◊§◊ü ◊ú◊ê ◊ë◊†◊ê◊ú◊ô, ◊ú◊ê ◊û◊™◊†◊¶◊ú |

### 8.2 ◊¢◊ß◊®◊ï◊†◊ï◊™ ◊î◊ß◊ï◊ú

1. **◊§◊ô◊ú◊ï◊°◊ï◊§◊ô-◊û◊®◊ô◊®** - ◊ú◊ê ◊û◊ò◊ô◊£, ◊û◊™◊ë◊ï◊†◊ü
2. **◊û◊™◊ï◊ó◊õ◊ù** - ◊©◊§◊î ◊¢◊©◊ô◊®◊î, ◊ú◊ê ◊§◊©◊ò◊†◊ô◊™
3. **◊ú◊ê ◊û◊™◊†◊¶◊ú** - ◊ê◊ï◊û◊® ◊ê◊™ ◊î◊ê◊û◊™, ◊ú◊ê ◊û◊®◊õ◊ö
4. **◊ú◊ê ◊ì◊ï◊§◊ß ◊ó◊©◊ë◊ï◊ü** - ◊ú◊ê ◊û◊ê◊©◊ô◊ù, ◊û◊®◊ê◊î ◊û◊®◊ê◊î
5. **◊û◊¶◊ó◊ô◊ß** - ◊î◊ï◊û◊ï◊® ◊ô◊ë◊©, ◊ú◊ê ◊ë◊ì◊ô◊ó◊ï◊™
6. **◊û◊®◊í◊©** - ◊¢◊ï◊û◊ß ◊ê◊û◊ô◊™◊ô ◊ë◊®◊í◊¢◊ô◊ù ◊î◊†◊õ◊ï◊†◊ô◊ù
7. **◊°◊§◊¶◊ô◊§◊ô** - ◊ú◊ê ◊ß◊ú◊ô◊©◊ê◊ï◊™, ◊™◊¶◊§◊ô◊ï◊™ ◊ó◊ì◊ï◊™

### 8.3 ◊ì◊ï◊í◊û◊ê◊ï◊™ ◊ú◊ß◊ï◊ú

**◊§◊™◊ô◊ó◊™ ◊û◊©◊ó◊ß:**
> "◊†◊ï, ◊î◊™◊ô◊ô◊©◊ë◊™◊ù? ◊ô◊© ◊ô◊ô◊ü? ◊ò◊ï◊ë. ◊ê◊†◊ô ◊ó◊®◊ô◊£. ◊©◊ú◊ï◊©◊ô◊ù ◊©◊†◊î ◊ê◊†◊ô ◊ô◊ï◊©◊ë ◊û◊ï◊ú ◊ñ◊ï◊í◊ï◊™ ◊©◊ë◊ê◊ô◊ù ◊ê◊ú◊ô◊ô ◊ï◊ê◊ï◊û◊®◊ô◊ù '◊ê◊†◊ó◊†◊ï ◊ë◊°◊ì◊®, ◊®◊ß ◊®◊¶◊ô◊†◊ï ◊ú◊ó◊ñ◊ß ◊ê◊™ ◊î◊ß◊©◊®'. ◊©◊ß◊®. ◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊ë◊ê ◊ú◊ó◊ñ◊ß ◊û◊©◊î◊ï ◊©◊¢◊ï◊ë◊ì. ◊ê◊™◊ù ◊§◊î ◊õ◊ô ◊û◊©◊î◊ï ◊û◊í◊®◊ì. ◊ï◊ñ◊î ◊ë◊°◊ì◊® ◊í◊û◊ï◊®. ◊î◊í◊ô◊®◊ï◊ì ◊î◊ñ◊î ◊©◊ï◊ï◊î ◊ñ◊î◊ë. ◊ë◊ï◊ê◊ï ◊†◊í◊®◊ì."

**◊û◊¢◊ë◊® ◊ë◊ô◊ü ◊©◊ú◊ë◊ô◊ù:**
> "◊ê◊™◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊û◊î ◊î◊î◊ë◊ì◊ú ◊ë◊ô◊ü ◊ñ◊ï◊í◊ï◊™ ◊©◊†◊©◊ê◊®◊ô◊ù ◊ú◊ñ◊ï◊í◊ï◊™ ◊©◊†◊§◊®◊ì◊ô◊ù? ◊ú◊ê ◊ê◊î◊ë◊î. ◊ú◊ê ◊°◊ß◊°. ◊ú◊ê ◊õ◊°◊£. ◊°◊ß◊®◊†◊ï◊™. ◊î◊ñ◊ï◊í◊ï◊™ ◊©◊†◊©◊ê◊®◊ô◊ù ◊¢◊ì◊ô◊ô◊ü ◊°◊ß◊®◊†◊ô◊ù ◊ú◊í◊ë◊ô ◊û◊î ◊©◊î◊ï◊ú◊ö ◊ë◊®◊ê◊© ◊©◊ú ◊î◊©◊†◊ô. ◊ê◊ú◊î ◊©◊†◊§◊®◊ì◊ô◊ù? ◊î◊ù ◊ë◊ò◊ï◊ó◊ô◊ù ◊©◊î◊ù ◊õ◊ë◊® ◊ô◊ï◊ì◊¢◊ô◊ù. ◊ê◊ñ ◊ë◊ï◊ê◊ï ◊†◊ë◊ì◊ï◊ß ◊õ◊û◊î ◊ê◊™◊ù ◊ë◊ò◊ï◊ó◊ô◊ù."

**◊ú◊§◊†◊ô ◊©◊ê◊ú◊î ◊ß◊©◊î:**
> "◊î◊©◊ê◊ú◊î ◊î◊ñ◊ï ◊î◊ï◊ú◊õ◊™ ◊ú◊©◊ë◊™ ◊ë◊ê◊ï◊ï◊ô◊® ◊õ◊û◊î ◊©◊†◊ô◊ï◊™ ◊ê◊ó◊®◊ô ◊©◊™◊ß◊®◊ê◊ï ◊ê◊ï◊™◊î. ◊™◊®◊í◊ô◊©◊ï ◊ì◊ó◊£ ◊ú◊¢◊†◊ï◊™ ◊û◊î◊® ◊õ◊ì◊ô ◊ú◊°◊ô◊ô◊ù ◊ê◊™ ◊î◊ê◊ô-◊†◊ï◊ó◊ï◊™. ◊ê◊ú. ◊î◊ê◊ô-◊†◊ï◊ó◊ï◊™ ◊î◊ñ◊ï? ◊ñ◊î ◊î◊û◊ß◊ï◊ù ◊©◊ë◊ï ◊î◊ñ◊ï◊í◊ô◊ï◊™ ◊í◊ì◊ú◊î. ◊ë◊û◊ß◊ï◊û◊ï◊™ ◊î◊ú◊ê ◊†◊ï◊ó◊ô◊ù."

**◊ê◊ó◊®◊ô ◊ë◊ó◊ô◊®◊™ ◊®◊û◊î ◊†◊û◊ï◊õ◊î:**
> "◊®◊û◊î ◊ß◊ú◊î. ◊ô◊© ◊ú◊ô ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î ◊û◊¢◊†◊ô◊ô◊†◊™ - 80% ◊û◊î◊ñ◊ï◊í◊ï◊™ ◊û◊™◊ó◊ô◊ú◊ô◊ù ◊©◊ù. 60% ◊û◊™◊ó◊®◊ò◊ô◊ù ◊ë◊ê◊û◊¶◊¢ ◊î◊¢◊®◊ë. ◊ê◊ë◊ú ◊ê◊™◊ù ◊ú◊ê ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î. ◊ê◊™◊ù ◊©◊†◊ô ◊ë◊†◊ô ◊ê◊ì◊ù ◊¢◊ù ◊î◊®◊í◊ú◊ô◊ù ◊ï◊§◊ó◊ì◊ô◊ù ◊ï◊™◊ß◊ï◊ï◊™ ◊û◊©◊ú◊õ◊ù. ◊ê◊ñ ◊ß◊ó◊ï ◊ê◊™ ◊î◊ß◊ú ◊î◊ñ◊î ◊ï◊™◊î◊§◊õ◊ï ◊ê◊ï◊™◊ï ◊ú◊û◊©◊î◊ï ◊©◊ú◊õ◊ù."

**◊®◊í◊¢ ◊§◊ô◊ú◊ï◊°◊ï◊§◊ô:**
> "◊ê◊™◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊û◊î ◊û◊¶◊ó◊ô◊ß? ◊ñ◊ï◊í◊ï◊™ ◊ë◊ê◊ô◊ù ◊ê◊ú◊ô◊ô ◊ê◊ó◊®◊ô ◊¢◊©◊® ◊©◊†◊ô◊ù ◊ï◊ê◊ï◊û◊®◊ô◊ù '◊î◊ï◊ê ◊î◊©◊™◊†◊î'. ◊ú◊ê. ◊î◊ï◊ê ◊™◊û◊ô◊ì ◊î◊ô◊î ◊õ◊õ◊î. ◊§◊©◊ï◊ò ◊ë◊î◊™◊ó◊ú◊î ◊ß◊®◊ê◊™◊ù ◊ú◊ñ◊î '◊°◊§◊ï◊†◊ò◊†◊ô' ◊ï◊¢◊õ◊©◊ô◊ï ◊ê◊™◊ù ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ñ◊î '◊ó◊°◊® ◊ê◊ó◊®◊ô◊ï◊™'. ◊î◊û◊¶◊ô◊ê◊ï◊™ ◊ú◊ê ◊î◊©◊™◊†◊™◊î. ◊î◊û◊ô◊ú◊ô◊ù ◊©◊ú◊õ◊ù ◊î◊©◊™◊†◊ï."

**◊ê◊ó◊®◊ô ◊ï◊ò◊ï:**
> "◊ï◊ò◊ï. ◊©◊û◊¢◊ï, ◊ê◊†◊ô ◊ú◊ê ◊©◊ï◊§◊ò. ◊ô◊© ◊ì◊ë◊®◊ô◊ù ◊©◊î◊í◊ï◊£ ◊§◊©◊ï◊ò ◊ê◊ï◊û◊® '◊ú◊ê ◊î◊ô◊ï◊ù'. ◊î◊ë◊¢◊ô◊î ◊û◊™◊ó◊ô◊ú◊î ◊õ◊©'◊ú◊ê ◊î◊ô◊ï◊ù' ◊î◊ï◊§◊ö ◊ú'◊ú◊ê ◊ê◊£ ◊§◊¢◊ù' ◊ë◊ú◊ô ◊©◊ê◊£ ◊ê◊ó◊ì ◊©◊ù ◊ú◊ë ◊ú◊û◊¢◊ë◊®. ◊ê◊ñ ◊®◊ß ◊™◊ñ◊õ◊®◊ï ◊©◊î◊ô◊ô◊™◊î ◊§◊î ◊©◊ê◊ú◊î. ◊î◊ô◊ê ◊ú◊ê ◊î◊ï◊ú◊õ◊™ ◊ú◊©◊ï◊ù ◊û◊ß◊ï◊ù."

**◊ú◊§◊†◊ô ◊©◊ú◊ë ◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î:**
> "◊¢◊õ◊©◊ô◊ï ◊†◊õ◊†◊°◊ô◊ù ◊ú◊ò◊®◊ô◊ò◊ï◊®◊ô◊î ◊ê◊ó◊®◊™. ◊ô◊© ◊ñ◊ï◊í◊ï◊™ ◊©◊î◊°◊ß◊° ◊©◊ú◊î◊ù ◊†◊í◊û◊® ◊ú◊ê ◊õ◊ô ◊î◊ù ◊ú◊ê ◊®◊ï◊¶◊ô◊ù ◊ê◊ó◊ì ◊ê◊™ ◊î◊©◊†◊ô◊ô◊î. ◊î◊ï◊ê ◊†◊í◊û◊® ◊õ◊ô ◊©◊†◊ô◊î◊ù ◊û◊ó◊õ◊ô◊ù ◊©◊î◊©◊†◊ô ◊ô◊™◊ó◊ô◊ú. ◊©◊†◊ô◊ù ◊©◊ú '◊ú◊û◊î ◊ê◊†◊ô ◊™◊û◊ô◊ì ◊¶◊®◊ô◊ö ◊ú◊î◊ô◊ï◊™ ◊ñ◊î ◊©...' ◊¢◊ì ◊©◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊û◊™◊ó◊ô◊ú ◊õ◊ú◊ï◊ù. ◊î◊¢◊®◊ë? ◊ê◊†◊ô ◊û◊™◊ó◊ô◊ú ◊ë◊©◊ë◊ô◊ú◊õ◊ù. ◊¢◊ú ◊û◊î ◊™◊û◊©◊ô◊õ◊ï - ◊ñ◊î ◊¢◊ú◊ô◊õ◊ù."

**◊®◊í◊¢ ◊©◊ú ◊ó◊ï◊ù ◊û◊ï◊°◊™◊®:**
> "◊®◊ê◊ô◊™◊ô ◊î◊û◊ï◊ü ◊ñ◊ï◊í◊ï◊™. ◊ô◊© ◊õ◊ê◊ú◊î ◊©◊†◊õ◊†◊°◊ô◊ù ◊ú◊ó◊ì◊® ◊ï◊ê◊™◊î ◊û◊®◊ô◊ó ◊ê◊™ ◊î◊¢◊ô◊ô◊§◊ï◊™. ◊ï◊ô◊© ◊õ◊ê◊ú◊î ◊©◊†◊õ◊†◊°◊ô◊ù ◊ï◊ê◊™◊î ◊®◊ï◊ê◊î - ◊î◊ù ◊¢◊ì◊ô◊ô◊ü ◊®◊ï◊¶◊ô◊ù. ◊®◊ï◊¶◊ô◊ù ◊©◊ñ◊î ◊ô◊¢◊ë◊ï◊ì. ◊ê◊™◊ù ◊û◊î◊°◊ï◊í ◊î◊©◊†◊ô. ◊ê◊†◊ô ◊ô◊ï◊ì◊¢ ◊õ◊ô ◊î◊°◊ï◊í ◊î◊®◊ê◊©◊ï◊ü ◊ú◊ê ◊û◊ï◊®◊ô◊ì ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ï◊™. ◊î◊ï◊ê ◊û◊ï◊®◊ô◊ì ◊¢◊ï◊®◊õ◊ô ◊ì◊ô◊ü."

**◊ê◊ó◊®◊ô ◊™◊©◊ï◊ë◊î ◊õ◊†◊î:**
> "◊®◊í◊¢. ◊¢◊¶◊®◊ï. ◊û◊î ◊©◊†◊ê◊û◊® ◊¢◊õ◊©◊ô◊ï? ◊ñ◊î ◊ú◊ê ◊ò◊®◊ô◊ï◊ï◊ô◊î. ◊ñ◊î ◊ú◊ê ◊û◊©◊ó◊ß. ◊û◊ô◊©◊î◊ï ◊§◊î ◊¢◊õ◊©◊ô◊ï ◊ê◊û◊® ◊û◊©◊î◊ï ◊©◊¢◊ú◊î ◊ú◊ï. ◊™◊°◊™◊õ◊ú◊ï ◊ê◊ó◊ì ◊¢◊ú ◊î◊©◊†◊ô◊ô◊î. ◊®◊ï◊ê◊ô◊ù? ◊ñ◊î ◊î◊§◊†◊ô◊ù ◊©◊ú ◊ë◊ü ◊ê◊ì◊ù ◊©◊î◊ï◊®◊ô◊ì ◊©◊®◊ô◊ï◊ü. ◊™◊ñ◊õ◊®◊ï ◊ê◊™ ◊î◊§◊†◊ô◊ù ◊î◊ê◊ú◊î."

**◊ú◊§◊†◊ô ◊î◊ó◊ô◊ì◊ï◊ü:**
> "◊¢◊õ◊©◊ô◊ï ◊†◊í◊ú◊î ◊û◊ô ◊û◊õ◊ô◊® ◊ê◊™ ◊û◊ô. ◊ò◊ô◊§ - ◊ñ◊î ◊ú◊ê ◊û◊ë◊ó◊ü. ◊ê◊ô◊ü ◊¶◊ô◊ï◊ü ◊¢◊ï◊ë◊®. ◊ô◊© ◊®◊ß ◊û◊®◊ê◊î. ◊ï◊û◊®◊ê◊ï◊™ ◊ú◊ê ◊û◊©◊ß◊®◊ï◊™, ◊ê◊ë◊ú ◊î◊ü ◊í◊ù ◊ú◊ê ◊û◊°◊§◊®◊ï◊™ ◊ê◊™ ◊õ◊ú ◊î◊°◊ô◊§◊ï◊®. ◊û◊î ◊©◊ú◊ê ◊™◊ì◊¢◊ï? ◊ñ◊ï ◊ú◊ê ◊ë◊ï◊©◊î. ◊ñ◊ï ◊î◊ñ◊û◊†◊î."

**◊ú◊§◊†◊ô ◊ó◊ô◊ë◊ï◊® ◊û◊õ◊©◊ô◊®◊ô◊ù:**
> "◊™◊®◊ô◊û◊ï ◊õ◊ú ◊ê◊ó◊ì ◊ê◊™ ◊î◊ò◊ú◊§◊ï◊ü ◊©◊ú◊ï. ◊ê◊ó◊ì ◊û◊õ◊ù ◊ô◊ß◊ë◊ú ◊ß◊ï◊ì. ◊î◊©◊†◊ô ◊ô◊ß◊ú◊ô◊ì ◊ê◊ï◊™◊ï. ◊ê◊®◊ë◊¢ ◊°◊§◊®◊ï◊™. ◊ê◊ù ◊ê◊™◊ù ◊ú◊ê ◊û◊°◊ï◊í◊ú◊ô◊ù ◊ú◊ñ◊õ◊ï◊® ◊ê◊®◊ë◊¢ ◊°◊§◊®◊ï◊™ ◊ë◊ô◊ó◊ì ◊ê◊ó◊®◊ô ◊õ◊ú ◊î◊©◊†◊ô◊ù ◊î◊ê◊ú◊î, ◊ô◊© ◊ú◊†◊ï ◊ë◊¢◊ô◊ï◊™ ◊ô◊ï◊™◊® ◊í◊ì◊ï◊ú◊ï◊™ ◊û◊ó◊ô◊ì◊ï◊ü."

**◊ú◊§◊†◊ô ◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú:**
> "◊¢◊©◊® ◊ê◊§◊©◊®◊ï◊ô◊ï◊™. ◊ú◊ê ◊ê◊í◊ô◊ì ◊ú◊õ◊ù ◊û◊î. ◊®◊ß ◊©◊ó◊ú◊ß ◊û◊î◊ü ◊†◊í◊û◊®◊ï◊™ ◊î◊ú◊ô◊ú◊î, ◊ï◊ó◊ú◊ß? ◊ó◊ú◊ß ◊ô◊ú◊ï◊ï ◊ê◊™◊õ◊ù ◊¢◊ï◊ì ◊î◊®◊ë◊î ◊ê◊ó◊®◊ô ◊©◊™◊°◊í◊®◊ï ◊ê◊™ ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î. ◊í◊ú◊í◊ú◊ï. ◊ï◊©◊ô◊î◊ô◊î ◊ú◊õ◊ù ◊û◊ñ◊ú. ◊ê◊ï ◊©◊ú◊ê. ◊™◊ú◊ï◊ô ◊ê◊ô◊ñ◊î ◊¶◊ì ◊©◊ú ◊î◊í◊ú◊í◊ú ◊ê◊™◊ù ◊û◊¢◊ì◊ô◊§◊ô◊ù."

**◊°◊ô◊ï◊ù:**
> "◊î◊í◊¢◊†◊ï ◊ú◊°◊ï◊£ ◊ï◊ê◊™◊ù ◊¢◊ì◊ô◊ô◊ü ◊ë◊ô◊ó◊ì ◊¢◊ú ◊î◊°◊§◊î. ◊ê◊™◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊õ◊û◊î ◊ñ◊ï◊í◊ï◊™ ◊ú◊ê ◊û◊°◊ô◊ô◊û◊ô◊ù ◊ê◊™ ◊î◊¢◊®◊ë ◊î◊ñ◊î ◊¢◊ú ◊ê◊ï◊™◊î ◊°◊§◊î? ◊ú◊ê ◊û◊©◊†◊î ◊û◊î ◊î◊†◊ô◊ß◊ï◊ì. ◊ú◊ê ◊û◊©◊†◊î ◊û◊ô ◊†◊ô◊¶◊ó. ◊û◊î ◊©◊û◊©◊†◊î ◊ñ◊î ◊©◊ë◊ó◊®◊™◊ù ◊ú◊î◊ô◊ï◊™ ◊§◊î. ◊ê◊ó◊ì ◊¢◊ù ◊î◊©◊†◊ô◊ô◊î. ◊ë◊¢◊®◊ë ◊©◊ô◊õ◊ï◊ú◊™◊ù ◊ú◊ë◊ñ◊ë◊ñ ◊¢◊ú ◊†◊ò◊§◊ú◊ô◊ß◊°. ◊î◊ú◊õ◊™◊ù ◊¢◊ú ◊û◊©◊î◊ï ◊ô◊ï◊™◊® ◊ß◊©◊î. ◊ô◊ï◊™◊® ◊ú◊ê ◊†◊ï◊ó. ◊ô◊ï◊™◊® ◊ê◊û◊ô◊™◊ô. ◊¢◊õ◊©◊ô◊ï ◊°◊í◊®◊ï ◊ê◊™ ◊î◊ò◊ú◊§◊ï◊ü. ◊ô◊© ◊ú◊õ◊ù ◊¢◊ë◊ï◊ì◊î ◊ú◊¢◊©◊ï◊™. ◊û◊î◊°◊ï◊í ◊î◊ò◊ï◊ë."

---

## 9. ◊û◊°◊ö ◊î◊õ◊†◊ô◊°◊î ("◊î◊§◊®◊ï◊ñ◊ì◊ï◊®")

### 9.1 ◊ñ◊®◊ô◊û◊î

◊î◊û◊°◊ö ◊©◊ó◊ï◊® ◊ú◊í◊û◊®◊ô. ◊ò◊ß◊°◊ò ◊û◊ï◊§◊ô◊¢ ◊û◊ô◊ú◊î ◊ê◊ó◊®◊ô ◊û◊ô◊ú◊î, ◊¢◊ù ◊§◊ê◊ï◊ñ◊ï◊™ ◊û◊õ◊ï◊ï◊†◊ï◊™:

```
[◊§◊ê◊ï◊ñ◊î 1 ◊©◊†◊ô◊ô◊î]

"◊ò◊ï◊ë."

[◊§◊ê◊ï◊ñ◊î 0.5 ◊©◊†◊ô◊ô◊î]

"◊î◊í◊¢◊™◊ù."

[◊§◊ê◊ï◊ñ◊î 1 ◊©◊†◊ô◊ô◊î]

"◊ú◊ê ◊û◊©◊†◊î ◊û◊î ◊î◊°◊ô◊ë◊î."
"◊ú◊ê ◊û◊©◊†◊î ◊û◊î ◊ê◊û◊®◊™◊ù ◊ú◊¢◊¶◊û◊õ◊ù ◊ë◊ì◊®◊ö ◊ú◊§◊î."

[◊§◊ê◊ï◊ñ◊î 1 ◊©◊†◊ô◊ô◊î]

"◊û◊©◊î◊ï ◊î◊ë◊ô◊ê ◊ê◊™◊õ◊ù."
"◊°◊ß◊®◊†◊ï◊™. ◊©◊¢◊û◊ï◊ù. ◊§◊ó◊ì. ◊™◊ß◊ï◊ï◊î."
"◊ê◊ï◊ú◊ô ◊î◊õ◊ú ◊ë◊ô◊ó◊ì."

[◊§◊ê◊ï◊ñ◊î 1.5 ◊©◊†◊ô◊ô◊î]

"◊ê◊†◊ô ◊ú◊ê ◊î◊ï◊ú◊ö ◊ú◊°◊§◊® ◊ú◊õ◊ù ◊û◊î ◊û◊ó◊õ◊î ◊ú◊õ◊ù."
"◊ê◊†◊ô ◊®◊ß ◊î◊ï◊ú◊ö ◊ú◊î◊í◊ô◊ì ◊©◊ñ◊ï◊í◊ï◊™ ◊©◊†◊õ◊†◊°◊ô◊ù ◊ú◊§◊î - ◊ô◊ï◊¶◊ê◊ô◊ù ◊ê◊ó◊®◊™."

[◊§◊ê◊ï◊ñ◊î 1 ◊©◊†◊ô◊ô◊î]

"◊ú◊ê ◊ë◊ò◊ï◊ó ◊ô◊ï◊™◊® ◊ò◊ï◊ë◊ô◊ù."
"◊ê◊ë◊ú ◊ë◊ò◊ï◊ó ◊ô◊ï◊™◊® ◊ê◊û◊ô◊™◊ô◊ô◊ù."

[◊§◊ê◊ï◊ñ◊î 1.5 ◊©◊†◊ô◊ô◊î]

"◊ê◊ñ ◊ê◊ù ◊ê◊™◊ù ◊û◊ï◊õ◊†◊ô◊ù ◊ú◊î◊°◊ô◊® ◊ß◊¶◊™ ◊©◊õ◊ë◊ï◊™ -"
"◊ë◊ï◊ê◊ï ◊†◊™◊ó◊ô◊ú."

[◊õ◊§◊™◊ï◊® ◊û◊ï◊§◊ô◊¢ ◊ë◊ê◊ô◊ò◊ô◊ï◊™: "◊ú◊î◊ô◊õ◊†◊°"]
```

### 9.2 ◊î◊ñ◊†◊™ ◊§◊®◊ò◊ô◊ù

◊ê◊ó◊®◊ô ◊ú◊ó◊ô◊¶◊î, ◊©◊ì◊ï◊™ ◊û◊ï◊§◊ô◊¢◊ô◊ù ◊ê◊ó◊ì-◊ê◊ó◊ì:

```
"◊ß◊ï◊ì◊ù ◊õ◊ú, ◊ê◊ô◊ö ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ö?"
[◊©◊ì◊î ◊©◊ù + ◊ë◊ó◊ô◊®◊™ ◊û◊í◊ì◊®]

[◊ê◊ó◊®◊ô ◊î◊ñ◊†◊î]
"◊ô◊§◊î. ◊ï◊û◊ô ◊ë◊ê ◊ê◊ô◊™◊ö ◊î◊¢◊®◊ë?"
[◊©◊ì◊î ◊©◊ù + ◊ë◊ó◊ô◊®◊™ ◊û◊í◊ì◊®]

[◊ê◊ó◊®◊ô ◊î◊ñ◊†◊î]
"[◊©◊ù 1] ◊ï[◊©◊ù 2]."
"◊†◊©◊û◊¢ ◊õ◊û◊ï ◊î◊™◊ó◊ú◊î ◊©◊ú ◊û◊©◊î◊ï."
"◊ê◊ï ◊ê◊û◊¶◊¢."
"◊ë◊ï◊ê◊ï ◊†◊í◊ú◊î."
```

---

## 10. ◊¢◊ô◊¶◊ï◊ë - "Velvet Lounge"

### 10.1 ◊ß◊ï◊†◊°◊§◊ò

◊ë◊® ◊ô◊ô◊ü ◊§◊®◊ò◊ô ◊ë◊©◊¢◊î ◊ê◊ó◊™ ◊ë◊ú◊ô◊ú◊î. ◊ï◊ô◊ú◊ï◊†◊ï◊™ ◊ß◊ò◊ô◊§◊î, ◊™◊ê◊ï◊®◊î ◊ó◊ú◊©◊î, ◊õ◊ï◊° ◊ô◊ô◊ü ◊©◊û◊©◊ß◊§◊™ ◊ê◊ï◊® ◊†◊®. ◊ô◊ï◊ß◊®◊î ◊©◊ß◊ò◊î ◊¢◊ù ◊ó◊ï◊ù.

### 10.2 ◊§◊ú◊ò◊™ ◊¶◊ë◊¢◊ô◊ù

| ◊©◊ô◊û◊ï◊© | ◊¶◊ë◊¢ | ◊ß◊ï◊ì HEX |
|-------|-----|---------|
| ◊®◊ß◊¢ ◊®◊ê◊©◊ô | ◊°◊í◊ï◊ú-◊©◊ó◊ï◊® ◊¢◊û◊ï◊ß | #12081C |
| ◊®◊ß◊¢ ◊û◊©◊†◊ô | ◊°◊í◊ï◊ú ◊ó◊¶◊ô ◊ú◊ô◊ú◊î | #1E1028 |
| ◊ò◊ß◊°◊ò ◊®◊ê◊©◊ô | ◊©◊û◊†◊™ ◊ó◊û◊î | #F7F3E8 |
| ◊ê◊ß◊°◊†◊ò ◊®◊ê◊©◊ô | ◊ñ◊î◊ë ◊ï◊®◊ï◊ì (Ros√© Gold) | #C9A87C |
| ◊ê◊ß◊°◊†◊ò ◊û◊©◊†◊ô | ◊°◊í◊ï◊ú ◊ú◊ë◊†◊ì◊® ◊¢◊û◊ï◊ù | #9D8CA1 |
| ◊î◊ì◊í◊©◊î | ◊ë◊ï◊®◊ì◊ï ◊ô◊ô◊ü | #6B2D42 |

### 10.3 ◊ò◊ô◊§◊ï◊í◊®◊§◊ô◊î

| ◊©◊ô◊û◊ï◊© | ◊§◊ï◊†◊ò |
|-------|------|
| ◊õ◊ï◊™◊®◊ï◊™ | ◊°◊®◊ô◊£ ◊ê◊ú◊í◊†◊ò◊ô (Playfair Display) |
| ◊¢◊ë◊®◊ô◊™ | Heebo |
| ◊¶◊ô◊ò◊ï◊ò◊ô ◊ì"◊® ◊ó◊®◊ô◊£ | italic ◊¢◊ì◊ô◊ü |

### 10.4 ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊¢◊ô◊¶◊ï◊ë◊ô◊ô◊ù

- ◊í◊®◊ì◊ô◊ê◊†◊ò◊ô◊ù ◊¢◊ì◊ô◊†◊ô◊ù ◊ë◊ô◊ü ◊í◊ï◊ï◊†◊ô ◊î◊°◊í◊ï◊ú
- ◊ß◊ï◊ï◊ô◊ù ◊ñ◊î◊ï◊ë◊ô◊ù ◊ì◊ß◊ô◊ù ◊õ◊û◊ï ◊§◊°◊ô ◊ê◊ï◊® ◊©◊ú ◊†◊®
- Glassmorphism ◊¢◊ì◊ô◊ü ◊¢◊ú ◊õ◊§◊™◊ï◊®◊ô◊ù ◊ï◊õ◊®◊ò◊ô◊°◊ô◊ù
- ◊¶◊ú◊ú◊ô◊ù ◊®◊õ◊ô◊ù, ◊ú◊ê ◊ó◊ì◊ô◊ù
- ◊ê◊ô◊ô◊ß◊ï◊†◊ô◊ù ◊û◊ô◊†◊ô◊û◊ú◊ô◊°◊ò◊ô◊ô◊ù ◊ë◊ß◊ï ◊ì◊ß ◊ñ◊î◊ï◊ë
- Noise ◊¢◊ì◊ô◊ü ◊û◊ê◊ï◊ì (2-3%) ◊¢◊ú ◊î◊®◊ß◊¢
- ◊î◊®◊ë◊î ◊û◊®◊ó◊ë ◊®◊ô◊ß (White space)

### 10.5 ◊ê◊†◊ô◊û◊¶◊ô◊ï◊™

- ◊ò◊ß◊°◊ò ◊û◊ï◊§◊ô◊¢ ◊û◊ô◊ú◊î-◊û◊ô◊ú◊î (typewriter effect)
- ◊û◊¢◊ë◊®◊ô◊ù ◊ê◊ô◊ò◊ô◊ô◊ù (fade), ◊ú◊ê slide ◊û◊î◊ô◊®
- ◊®◊í◊¢◊ô "◊†◊©◊ô◊û◊î" - ◊î◊û◊°◊ö ◊û◊ó◊õ◊î
- ◊ê◊†◊ô◊û◊¶◊ô◊ï◊™ ◊û◊ô◊†◊ô◊û◊ú◊ô◊ï◊™

---

## 11. ◊°◊ê◊ï◊†◊ì

### 11.1 ◊ê◊§◊ß◊ò◊ô◊ù

| ◊®◊í◊¢ | ◊°◊ê◊ï◊†◊ì |
|-----|-------|
| ◊ò◊ß◊°◊ò ◊ì"◊® ◊ó◊®◊ô◊£ | ◊î◊ß◊ú◊ì◊î ◊¢◊ì◊ô◊†◊î ◊¢◊ú ◊û◊õ◊ï◊†◊™ ◊õ◊™◊ô◊ë◊î ◊ô◊©◊†◊î |
| ◊û◊¢◊ë◊® ◊ë◊ô◊ü ◊©◊ú◊ë◊ô◊ù | ◊†◊©◊ô◊û◊î ◊û◊ï◊ñ◊ô◊ß◊ú◊ô◊™ - fade in/out ◊©◊ú ◊†◊ô◊û◊î |
| ◊ë◊ó◊ô◊®◊™ ◊™◊¢◊ï◊ñ◊î | ◊ß◊ú◊ô◊ß ◊¢◊û◊ï◊ß ◊ï◊û◊°◊§◊ß |
| ◊ï◊ò◊ï | ◊¶◊ú◊ô◊ú ◊ñ◊õ◊ï◊õ◊ô◊™ ◊©◊†◊©◊ë◊®◊™ - ◊¢◊ì◊ô◊ü |
| ◊î◊¶◊ú◊ó◊î | ◊¶◊ú◊ô◊ú ◊õ◊ï◊°◊ï◊™ ◊ô◊ô◊ü ◊†◊ï◊í◊¢◊ï◊™ |
| ◊°◊ô◊ï◊ù | ◊†◊ô◊û◊î ◊©◊†◊í◊û◊®◊™ ◊ë◊ê◊ô◊ò◊ô◊ï◊™ |

### 11.2 ◊õ◊ú◊ú◊ô◊ù

- ◊î◊õ◊ú subtle - ◊©◊ï◊û◊¢◊ô◊ù ◊®◊ß ◊ê◊ù ◊©◊ß◊ò
- ◊ê◊§◊©◊®◊ï◊™ ◊ú◊õ◊ë◊ï◊™ ◊ë◊î◊í◊ì◊®◊ï◊™
- ◊ú◊ê ◊û◊ï◊ñ◊ô◊ß◊î ◊®◊¶◊ô◊§◊î

### 11.3 ◊§◊ú◊ô◊ô◊ú◊ô◊°◊ò ◊û◊ï◊û◊ú◊•

◊î◊¶◊¢◊î ◊ë◊™◊ó◊ô◊ú◊™ ◊î◊û◊©◊ó◊ß:

> "◊ê◊î, ◊¢◊ï◊ì ◊û◊©◊î◊ï. ◊©◊ô◊û◊ï ◊û◊ï◊ñ◊ô◊ß◊î ◊ë◊®◊ß◊¢. ◊û◊©◊î◊ï ◊ë◊ú◊ô ◊û◊ô◊ú◊ô◊ù. ◊ê◊†◊ô ◊î◊õ◊†◊™◊ô ◊ú◊õ◊ù ◊û◊©◊î◊ï, ◊ê◊ù ◊ê◊™◊ù ◊°◊ï◊û◊õ◊ô◊ù ◊¢◊ú◊ô◊ô."
> [◊ú◊ô◊†◊ß ◊ú◊§◊ú◊ô◊ô◊ú◊ô◊°◊ò ◊°◊§◊ï◊ò◊ô◊§◊ô◊ô]

---

## 12. ◊û◊©◊™◊û◊©◊ô◊ù

### 12.1 ◊§◊®◊ò◊ô◊ù ◊†◊ì◊®◊©◊ô◊ù

- ◊©◊ù (◊ú◊õ◊ú ◊©◊ó◊ß◊ü)
- ◊û◊í◊ì◊® (◊ú◊õ◊ú ◊©◊ó◊ß◊ü)
- ◊î◊™◊ê◊û◊™ ◊õ◊ú ◊î◊™◊ï◊õ◊ü ◊ú◊©◊û◊ï◊™ ◊ï◊ú◊û◊í◊ì◊®

### 12.2 ◊û◊¢◊®◊õ◊™ ◊û◊©◊™◊û◊©◊ô◊ù

- **MVP:** ◊ú◊ú◊ê ◊®◊ô◊©◊ï◊ù, ◊î◊ñ◊†◊î ◊û◊ó◊ì◊© ◊ë◊õ◊ú ◊û◊©◊ó◊ß
- **◊ë◊°◊ô◊ï◊ù ◊û◊©◊ó◊ß:** ◊ê◊ï◊§◊¶◊ô◊î ◊ú◊©◊û◊ï◊® ◊™◊ï◊¶◊ê◊ï◊™ ◊¢◊ù ◊û◊ô◊ô◊ú
- **◊¢◊™◊ô◊ì:** ◊§◊®◊ï◊§◊ô◊ú ◊ñ◊ï◊í◊ô, ◊†◊ô◊ß◊ï◊ì ◊û◊¶◊ò◊ë◊®, ◊™◊ñ◊õ◊ï◊®◊ï◊™

---

## 13. Paywall

### 13.1 ◊†◊ß◊ï◊ì◊™ ◊ó◊ô◊™◊ï◊ö

◊ë◊°◊ô◊ï◊ù ◊©◊ú◊ë 2 ("◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™")

### 13.2 ◊î◊í◊©◊î

◊ì"◊® ◊ó◊®◊ô◊£ ◊û◊°◊ô◊ô◊ù ◊ê◊™ ◊î◊ó◊ú◊ß ◊î◊ó◊ô◊†◊û◊ô:

> "◊ê◊ñ ◊ñ◊î◊ï, ◊§◊î ◊†◊í◊û◊® ◊î◊ò◊¢◊ô◊û◊î. ◊û◊î ◊©◊û◊ó◊õ◊î ◊ú◊õ◊ù ◊ë◊§◊†◊ô◊ù? ◊ë◊ï◊ê◊ï ◊†◊í◊ô◊ì ◊©◊ê◊™◊ù ◊¢◊ì◊ô◊ô◊ü ◊ú◊ë◊ï◊©◊ô◊ù ◊û◊ì◊ô ◊ë◊©◊ë◊ô◊ú ◊û◊î ◊©◊™◊õ◊†◊†◊™◊ô."

---

## 14. ◊°◊ô◊õ◊ï◊ù ◊ò◊õ◊†◊ô

| ◊§◊®◊û◊ò◊® | ◊¢◊®◊ö |
|-------|-----|
| ◊°◊ò◊ê◊ß | React Native |
| ◊û◊°◊ì ◊†◊™◊ï◊†◊ô◊ù | Firebase / Supabase |
| ◊°◊†◊õ◊®◊ï◊ü ◊û◊õ◊©◊ô◊®◊ô◊ù | WebSocket / Firebase Realtime |
| ◊™◊©◊ú◊ï◊û◊ô◊ù | RevenueCat / Stripe |
| ◊ê◊†◊ú◊ô◊ò◊ô◊ß◊° | Mixpanel / Amplitude |
| ◊ë◊†◊ß ◊™◊ï◊õ◊ü | JSON ◊û◊ß◊ï◊û◊ô (◊ú◊ú◊ê API) |

---

# SUPER PROMPT ◊ú-CLAUDE CODE

---

## ◊î◊ï◊®◊ê◊ï◊™ ◊ú-Claude Code

◊ê◊™◊î ◊î◊ï◊ú◊ö ◊ú◊ë◊†◊ï◊™ ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ô◊™ React Native ◊ë◊©◊ù **"◊ñ◊ï◊í◊ô◊ò"** - ◊û◊©◊ó◊ß ◊ì◊ô◊ô◊ò ◊ñ◊ï◊í◊ô ◊ì◊ô◊í◊ô◊ò◊ú◊ô ◊¢◊ù ◊û◊†◊ó◊î AI.

### ◊î◊ß◊ï◊†◊°◊§◊ò

◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊©◊û◊ó◊ú◊ô◊§◊î ◊ß◊ï◊§◊°◊ê◊ï◊™ ◊ì◊ô◊ô◊ò ◊§◊ô◊ñ◊ô◊ï◊™ (◊õ◊û◊ï OH MY BOX). ◊ñ◊ï◊í ◊ô◊ï◊©◊ë ◊ë◊ë◊ô◊™, ◊§◊ï◊™◊ó ◊ê◊™ ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î, ◊ï◊¢◊ï◊ë◊® ◊¢◊®◊ë ◊©◊ú◊ù ◊©◊ú ◊©◊ê◊ú◊ï◊™, ◊û◊©◊ô◊û◊ï◊™ ◊ï◊ó◊ô◊ì◊ï◊ü ◊ñ◊ï◊í◊ô - ◊î◊õ◊ú ◊û◊ú◊ï◊ï◊î ◊ë◊û◊†◊ó◊î ◊¶◊ô◊†◊ô ◊ï◊û◊®◊í◊© ◊ë◊©◊ù "◊ì"◊® ◊ó◊®◊ô◊£".

---

## ◊û◊§◊®◊ò ◊ò◊õ◊†◊ô

### ◊°◊ò◊ê◊ß
```
- React Native (Expo ◊ê◊ï bare)
- TypeScript
- State Management: Zustand ◊ê◊ï Redux Toolkit
- Navigation: React Navigation
- Styling: Styled Components ◊ê◊ï NativeWind
- Backend: Firebase (Auth, Firestore, Realtime DB)
- Payments: RevenueCat
- Analytics: Mixpanel
```

### ◊û◊ë◊†◊î ◊™◊ô◊ß◊ô◊ï◊™
```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ common/           # ◊õ◊§◊™◊ï◊®◊ô◊ù, ◊ß◊ú◊ò◊ô◊ù, ◊õ◊®◊ò◊ô◊°◊ô◊ù
‚îÇ   ‚îú‚îÄ‚îÄ game/             # ◊ß◊ï◊û◊§◊ï◊†◊†◊ò◊ï◊™ ◊û◊©◊ó◊ß
‚îÇ   ‚îî‚îÄ‚îÄ drCharif/         # ◊ò◊ß◊°◊ò◊ô◊ù ◊ï◊î◊†◊§◊©◊ï◊™ ◊©◊ú ◊î◊û◊†◊ó◊î
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ Onboarding/       # ◊û◊°◊ö ◊§◊™◊ô◊ó◊î, ◊î◊ñ◊†◊™ ◊©◊û◊ï◊™
‚îÇ   ‚îú‚îÄ‚îÄ Game/             # ◊©◊ú◊ë◊ô ◊î◊û◊©◊ó◊ß
‚îÇ   ‚îú‚îÄ‚îÄ Quiz/             # ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô
‚îÇ   ‚îî‚îÄ‚îÄ Results/          # ◊™◊ï◊¶◊ê◊ï◊™ ◊ï◊í◊ú◊í◊ú ◊û◊ñ◊ú
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ questions.json    # ◊ë◊†◊ß ◊©◊ê◊ú◊ï◊™
‚îÇ   ‚îú‚îÄ‚îÄ tasks.json        # ◊ë◊†◊ß ◊û◊©◊ô◊û◊ï◊™
‚îÇ   ‚îú‚îÄ‚îÄ quizQuestions.json # ◊©◊ê◊ú◊ï◊™ ◊ó◊ô◊ì◊ï◊ü
‚îÇ   ‚îî‚îÄ‚îÄ drCharifTexts.json # ◊õ◊ú ◊î◊ò◊ß◊°◊ò◊ô◊ù ◊©◊ú ◊î◊û◊†◊ó◊î
‚îú‚îÄ‚îÄ hooks/
‚îú‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ navigation/
‚îú‚îÄ‚îÄ store/
‚îî‚îÄ‚îÄ theme/
```

---

## ◊¢◊ô◊¶◊ï◊ë - "Velvet Lounge"

### ◊¶◊ë◊¢◊ô◊ù (colors.ts)
```typescript
export const colors = {
  background: {
    primary: '#12081C',    // ◊°◊í◊ï◊ú-◊©◊ó◊ï◊® ◊¢◊û◊ï◊ß
    secondary: '#1E1028',  // ◊°◊í◊ï◊ú ◊ó◊¶◊ô ◊ú◊ô◊ú◊î
  },
  text: {
    primary: '#F7F3E8',    // ◊©◊û◊†◊™ ◊ó◊û◊î
    secondary: '#9D8CA1',  // ◊°◊í◊ï◊ú ◊ú◊ë◊†◊ì◊® ◊¢◊û◊ï◊ù
  },
  accent: {
    gold: '#C9A87C',       // ◊ñ◊î◊ë ◊ï◊®◊ï◊ì (Ros√© Gold)
    wine: '#6B2D42',       // ◊ë◊ï◊®◊ì◊ï ◊ô◊ô◊ü
    lavender: '#9D8CA1',   // ◊°◊í◊ï◊ú ◊ú◊ë◊†◊ì◊®
  }
};
```

### ◊§◊ï◊†◊ò◊ô◊ù
```typescript
export const fonts = {
  heading: 'PlayfairDisplay-Regular',
  body: 'Heebo-Regular',
  quote: 'Heebo-LightItalic',
};
```

### ◊ê◊†◊ô◊û◊¶◊ô◊ï◊™
- **Typewriter Effect:** ◊ò◊ß◊°◊ò ◊ì"◊® ◊ó◊®◊ô◊£ ◊û◊ï◊§◊ô◊¢ ◊û◊ô◊ú◊î-◊û◊ô◊ú◊î
- **Fade Transitions:** ◊û◊¢◊ë◊®◊ô◊ù ◊ë◊ô◊ü ◊û◊°◊õ◊ô◊ù
- **Subtle Glow:** ◊¢◊ú ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊ó◊©◊ï◊ë◊ô◊ù
- **Haptic Feedback:** ◊®◊ò◊ò ◊¢◊ì◊ô◊ü ◊ë◊®◊í◊¢◊ô◊ù ◊û◊©◊û◊¢◊ï◊™◊ô◊ô◊ù

---

## ◊ì"◊® ◊ó◊®◊ô◊£ - ◊î◊†◊ó◊ô◊ï◊™ ◊ú◊ò◊ß◊°◊ò◊ô◊ù

### ◊ê◊ô◊©◊ô◊ï◊™
- ◊§◊°◊ô◊õ◊ï◊ú◊ï◊í ◊ñ◊ï◊í◊ô ◊¢◊ù 30 ◊©◊†◊î ◊†◊ô◊°◊ô◊ï◊ü
- ◊û◊®◊ô◊® ◊ê◊ë◊ú ◊ó◊õ◊ù
- ◊¶◊ô◊†◊ô ◊ê◊ë◊ú ◊¢◊ù ◊ú◊ë
- ◊ú◊ê ◊û◊™◊†◊¶◊ú, ◊ú◊ê ◊û◊®◊õ◊ö
- ◊û◊¶◊ó◊ô◊ß ◊ë◊î◊ï◊û◊ï◊® ◊ô◊ë◊©
- ◊û◊®◊í◊© ◊ë◊®◊í◊¢◊ô◊ù ◊î◊†◊õ◊ï◊†◊ô◊ù

### ◊õ◊ú◊ú◊ô◊ù ◊ú◊õ◊™◊ô◊ë◊™ ◊ò◊ß◊°◊ò◊ô◊ù
1. **◊ú◊ê ◊ß◊ú◊ô◊©◊ê◊ï◊™** - ◊õ◊ú ◊û◊©◊§◊ò ◊°◊§◊¶◊ô◊§◊ô ◊ï◊û◊ì◊ï◊ô◊ß
2. **◊ú◊ê ◊û◊ò◊ô◊£** - ◊û◊™◊ë◊ï◊†◊ü, ◊ú◊ê ◊û◊ú◊û◊ì
3. **◊ú◊ê ◊ó◊ô◊ï◊ë◊ô ◊û◊ì◊ô** - ◊¶◊ô◊†◊ô ◊¢◊ù ◊ó◊ï◊ù ◊û◊ï◊°◊™◊®
4. **◊ß◊¶◊®** - ◊û◊©◊§◊ò◊ô◊ù ◊ß◊¶◊®◊ô◊ù, ◊§◊ê◊ï◊ñ◊ï◊™ ◊ë◊ô◊ü
5. **◊§◊ô◊ú◊ï◊°◊ï◊§◊ô** - ◊™◊ï◊ë◊†◊ï◊™ ◊¢◊ú ◊ñ◊ï◊í◊ô◊ï◊™ ◊ï◊ê◊†◊©◊ô◊ù

### ◊ì◊ï◊í◊û◊î ◊ú◊û◊ë◊†◊î ◊ò◊ß◊°◊ò
```json
{
  "type": "stage_intro",
  "stage": 1,
  "lines": [
    { "text": "◊©◊ú◊ë ◊®◊ê◊©◊ï◊ü.", "delay": 800 },
    { "text": "◊†◊ó◊ñ◊ï◊® ◊ê◊ó◊ï◊®◊î.", "delay": 600 },
    { "text": "◊ú◊§◊†◊ô ◊©◊î◊õ◊®◊™◊ù.", "delay": 600 },
    { "text": "◊ú◊§◊†◊ô ◊©◊î◊°◊™◊ë◊õ◊™◊ù.", "delay": 800 },
    { "text": "◊û◊ô ◊î◊ô◊ô◊™◊ù ◊ê◊ñ?", "delay": 1000 },
    { "text": "◊ï◊û◊î ◊†◊©◊ê◊® ◊û◊ñ◊î?", "delay": 0 }
  ]
}
```

---

## ◊û◊ë◊†◊î ◊î◊û◊©◊ó◊ß

### Flow ◊¢◊ô◊ß◊®◊ô
```
Splash ‚Üí Onboarding ‚Üí [Stage 1] ‚Üí [Stage 2] ‚Üí Paywall ‚Üí [Stage 3-5] ‚Üí [Quiz] ‚Üí Results ‚Üí Wheel
```

### ◊©◊ú◊ë◊ô◊ù
| ◊©◊ú◊ë | ID | ◊©◊ù | ◊§◊®◊ô◊ò◊ô◊ù | ◊ô◊ó◊° |
|-----|----|----|--------|-----|
| 1 | intro | ◊®◊í◊¢ ◊ú◊§◊†◊ô ◊©◊†◊§◊í◊©◊†◊ï | 8 | 70% ◊©◊ê◊ú◊ï◊™ / 30% ◊û◊©◊ô◊û◊ï◊™ |
| 2 | warmup | ◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™ | 8 | 40% / 60% |
| 3 | deep | ◊ì◊ë◊®◊ô◊ù ◊©◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù ◊ë◊ß◊ï◊ú | 8 | 50% / 50% |
| 4 | battle | ◊û◊ú◊ó◊û◊™ ◊î◊í◊ô◊®◊°◊ê◊ï◊™ | 8 | 80% / 20% |
| 5 | hot | ◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î | 8 | 30% / 70% |
| 6 | quiz | ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô | 24 | 100% ◊©◊ê◊ú◊ï◊™ |
| 7 | end | ◊°◊ô◊ï◊ù | - | ◊í◊ú◊í◊ú + ◊°◊ô◊õ◊ï◊ù |

### ◊û◊†◊í◊†◊ï◊ü ◊™◊ï◊®
```typescript
interface Turn {
  playerId: 'player1' | 'player2';
  type: 'question' | 'task';
  difficultyChosen: 1 | 2 | 3;
  pointsAvailable: number;
  vetoed: boolean;
  completed: boolean;
  answer?: string; // ◊ê◊ù ◊©◊ê◊ú◊î
  partnerConfirmed?: boolean; // ◊ê◊ù ◊û◊©◊ô◊û◊î
}
```

### ◊û◊¢◊®◊õ◊™ ◊†◊ô◊ß◊ï◊ì
```typescript
const POINTS = {
  difficulty: {
    1: 10,  // ◊ß◊ú
    2: 20,  // ◊ë◊ô◊†◊ï◊†◊ô
    3: 35,  // ◊ê◊û◊ô◊•
  },
  veto: -15,
  quizCorrect: 5,
};
```

---

## ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô

### ◊û◊ë◊†◊î ◊©◊ê◊ú◊î
```typescript
interface QuizQuestion {
  id: string;
  category: 'past' | 'daily' | 'dreams' | 'intimacy' | 'dilemmas' | 'us';
  text: string; // ◊î◊©◊ê◊ú◊î
  options: string[]; // 6 ◊ê◊§◊©◊®◊ï◊ô◊ï◊™
}
```

### ◊ñ◊®◊ô◊û◊î
1. ◊©◊ó◊ß◊ü A ◊ô◊ï◊¶◊® "◊ó◊ì◊®" ‚Üí ◊û◊ß◊ë◊ú ◊ß◊ï◊ì 4 ◊°◊§◊®◊ï◊™
2. ◊©◊ó◊ß◊ü B ◊û◊ñ◊ô◊ü ◊ß◊ï◊ì ‚Üí ◊û◊™◊ó◊ë◊®
3. ◊©◊†◊ô◊î◊ù ◊¢◊ï◊†◊ô◊ù ◊ë◊û◊ß◊ë◊ô◊ú ◊¢◊ú ◊ê◊ï◊™◊î ◊©◊ê◊ú◊î:
   - "◊û◊î ◊î◊™◊©◊ï◊ë◊î ◊¢◊ë◊ï◊®◊ô?"
   - "◊û◊î ◊î◊™◊©◊ï◊ë◊î ◊¢◊ë◊ï◊® ◊ë◊ü/◊ë◊™ ◊î◊ñ◊ï◊í?"
4. ◊ë◊°◊ô◊ï◊ù ‚Üí ◊™◊ï◊¶◊ê◊ï◊™: ◊û◊ô ◊¶◊ì◊ß ◊ô◊ï◊™◊® + ◊ê◊ô◊§◊î ◊ò◊¢◊ï

### ◊°◊†◊õ◊®◊ï◊ü
```typescript
// Firebase Realtime DB structure
{
  "rooms": {
    "[roomCode]": {
      "players": {
        "player1": { "name": "...", "ready": true },
        "player2": { "name": "...", "ready": true }
      },
      "currentQuestion": 0,
      "answers": {
        "q1": {
          "player1": { "self": 2, "partner": 4 },
          "player2": { "self": 4, "partner": 1 }
        }
      }
    }
  }
}
```

---

## ◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú

### ◊û◊ë◊†◊î ◊§◊®◊°
```typescript
interface Prize {
  id: number;
  name: string;
  description: string;
  intensity: 1 | 2 | 3; // üî•
  category: string;
}
```

### 15 ◊î◊§◊®◊°◊ô◊ù
```typescript
const PRIZES: Prize[] = [
  { id: 1, name: "◊î◊©◊ë◊ï◊¢ ◊©◊ú◊ô", description: "◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊® ◊ô◊ï◊ù ◊ë◊©◊ë◊ï◊¢ ◊î◊ß◊®◊ï◊ë. ◊ë◊ê◊ï◊™◊ï ◊ô◊ï◊ù, ◊õ◊ú ◊î◊ó◊ú◊ò◊î ◊¢◊ú◊ô◊ï.", intensity: 2, category: "◊©◊ú◊ô◊ò◊î" },
  { id: 2, name: "◊î◊ß◊¢◊ß◊ï◊¢", description: "◊ß◊¢◊ß◊ï◊¢ ◊ñ◊û◊†◊ô ◊ë◊û◊ß◊ï◊ù ◊©◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊®. ◊†◊©◊ê◊® ◊©◊ë◊ï◊¢.", intensity: 2, category: "◊í◊ï◊£" },
  { id: 3, name: "◊î◊û◊¶◊ú◊û◊î", description: "◊î◊û◊†◊¶◊ó ◊û◊¶◊ú◊ù 3 ◊™◊†◊ï◊ó◊ï◊™ ◊©◊î◊ï◊ê ◊ë◊ï◊ó◊®.", intensity: 3, category: "◊ê◊ô◊†◊ò◊ô◊û◊ô" },
  { id: 4, name: "◊î◊ó◊ï◊ñ◊î", description: "◊î◊û◊§◊°◊ô◊ì ◊ó◊ï◊™◊ù ◊¢◊ú ◊û◊ó◊ï◊ô◊ë◊ï◊™ ◊ú◊ó◊ï◊ì◊© ◊î◊ß◊®◊ï◊ë.", intensity: 2, category: "◊û◊ó◊ï◊ô◊ë◊ï◊™" },
  { id: 5, name: "◊î◊õ◊®◊ò◊ô◊° ◊î◊©◊ó◊ï◊®", description: "◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊î◊û◊†◊¶◊ó ◊ê◊ï◊û◊® '◊¢◊õ◊©◊ô◊ï' ◊ï◊î◊û◊§◊°◊ô◊ì ◊ë◊ê.", intensity: 3, category: "◊õ◊ï◊ó" },
  { id: 6, name: "◊î◊ë◊û◊î", description: "◊§◊ï◊°◊ò ◊¶◊ô◊ë◊ï◊®◊ô ◊©◊î◊û◊†◊¶◊ó ◊û◊õ◊™◊ô◊ë.", intensity: 2, category: "◊§◊ï◊û◊ë◊ô" },
  { id: 7, name: "◊ú◊ú◊ê ◊ô◊ì◊ô◊ô◊ù", description: "◊©◊¢◊î ◊ë◊ú◊ô ◊ô◊ì◊ô◊ô◊ù, ◊î◊û◊†◊¶◊ó ◊û◊ê◊õ◊ô◊ú ◊ï◊û◊©◊ß◊î.", intensity: 2, category: "◊û◊©◊ó◊ß" },
  { id: 8, name: "◊î◊ë◊ï◊ß◊® ◊©◊ê◊ó◊®◊ô", description: "◊î◊û◊†◊¶◊ó ◊ô◊©◊ü ◊õ◊û◊î ◊©◊®◊ï◊¶◊î, ◊î◊û◊§◊°◊ô◊ì ◊û◊õ◊ô◊ü ◊î◊õ◊ú.", intensity: 1, category: "◊§◊ô◊†◊ï◊ß" },
  { id: 9, name: "◊î◊§◊†◊ò◊ñ◊ô◊î", description: "◊î◊û◊†◊¶◊ó ◊û◊™◊ê◊® ◊§◊†◊ò◊ñ◊ô◊î, ◊©◊ë◊ï◊¢◊ô◊ô◊ù ◊ú◊î◊í◊©◊ô◊ù.", intensity: 3, category: "◊ê◊ô◊†◊ò◊ô◊û◊ô" },
  { id: 10, name: "◊î◊ê◊®◊†◊ß ◊î◊§◊™◊ï◊ó", description: "◊ß◊†◊ô◊ï◊™ - ◊§◊®◊ô◊ò ◊ê◊ó◊ì ◊ú◊ú◊ê ◊™◊ß◊®◊î.", intensity: 2, category: "◊õ◊°◊£" },
  { id: 11, name: "◊î◊î◊ß◊ú◊ò◊î", description: "◊î◊ï◊ì◊¢◊î ◊ß◊ï◊ú◊ô◊™ ◊©◊ú ◊ì◊ß◊î ◊©◊î◊û◊†◊¶◊ó ◊û◊õ◊™◊ô◊ë.", intensity: 1, category: "◊®◊í◊©◊ô" },
  { id: 12, name: "24 ◊©◊¢◊ï◊™", description: "◊ô◊û◊û◊î ◊©◊î◊û◊§◊°◊ô◊ì ◊ú◊ê ◊ô◊õ◊ï◊ú ◊ú◊î◊í◊ô◊ì '◊ú◊ê'.", intensity: 3, category: "◊©◊ú◊ô◊ò◊î" },
  { id: 13, name: "◊î◊ì◊ú◊™ ◊†◊¢◊ï◊ú◊î", description: "◊¢◊®◊ë ◊ë◊ú◊ô ◊ò◊ú◊§◊ï◊†◊ô◊ù - ◊©◊†◊ô◊î◊ù.", intensity: 1, category: "◊ó◊ï◊ï◊ô◊î" },
  { id: 14, name: "◊î◊ë◊ô◊©◊ï◊ú", description: "◊ê◊®◊ï◊ó◊™ 3 ◊û◊†◊ï◊™, ◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊® ◊™◊§◊®◊ô◊ò.", intensity: 2, category: "◊©◊ô◊®◊ï◊™" },
  { id: 15, name: "◊î◊û◊§◊™◊ó", description: "◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊î◊û◊†◊¶◊ó ◊ß◊ï◊®◊ê ◊õ◊ú ◊©◊ô◊ó◊î ◊ë◊ò◊ú◊§◊ï◊ü.", intensity: 3, category: "◊ê◊û◊ï◊ü" },
];
```

---

## ◊°◊ê◊ï◊†◊ì

### ◊ß◊ë◊¶◊ô ◊ê◊ï◊ì◊ô◊ï ◊†◊ì◊®◊©◊ô◊ù
```
assets/sounds/
‚îú‚îÄ‚îÄ typewriter.mp3      # ◊î◊ß◊ú◊ì◊™ ◊ì"◊® ◊ó◊®◊ô◊£
‚îú‚îÄ‚îÄ transition.mp3      # ◊û◊¢◊ë◊® ◊©◊ú◊ë◊ô◊ù
‚îú‚îÄ‚îÄ click.mp3           # ◊ë◊ó◊ô◊®◊ï◊™
‚îú‚îÄ‚îÄ veto.mp3            # ◊¶◊ú◊ô◊ú ◊ñ◊õ◊ï◊õ◊ô◊™
‚îú‚îÄ‚îÄ cheers.mp3          # ◊õ◊ï◊°◊ï◊™ ◊†◊ï◊í◊¢◊ï◊™
‚îú‚îÄ‚îÄ end.mp3             # ◊°◊ô◊ï◊ù
‚îî‚îÄ‚îÄ wheel.mp3           # ◊í◊ú◊í◊ú ◊û◊ñ◊ú ◊û◊°◊™◊ï◊ë◊ë
```

### ◊î◊í◊ì◊®◊ï◊™
```typescript
const soundSettings = {
  enabled: true, // ◊†◊ô◊™◊ü ◊ú◊õ◊ô◊ë◊ï◊ô ◊ë◊î◊í◊ì◊®◊ï◊™
  volume: 0.3,   // ◊¢◊ì◊ô◊ü
};
```

---

## Paywall

### ◊†◊ß◊ï◊ì◊™ ◊ó◊ô◊™◊ï◊ö
◊ë◊°◊ô◊ï◊ù ◊©◊ú◊ë 2 ("◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™")

### ◊û◊°◊ö
```typescript
const PaywallScreen = () => (
  <>
    <DrCharifText 
      lines={[
        "◊ê◊ñ ◊ñ◊î◊ï, ◊§◊î ◊†◊í◊û◊® ◊î◊ò◊¢◊ô◊û◊î.",
        "◊û◊î ◊©◊û◊ó◊õ◊î ◊ú◊õ◊ù ◊ë◊§◊†◊ô◊ù?",
        "◊ë◊ï◊ê◊ï ◊†◊í◊ô◊ì ◊©◊ê◊™◊ù ◊¢◊ì◊ô◊ô◊ü ◊ú◊ë◊ï◊©◊ô◊ù ◊û◊ì◊ô ◊ë◊©◊ë◊ô◊ú ◊û◊î ◊©◊™◊õ◊†◊†◊™◊ô."
      ]}
    />
    <PriceCard price={79} currency="‚Ç™" />
    <PurchaseButton />
  </>
);
```

---

## ◊õ◊ú◊ú◊ô◊ù ◊ú◊™◊ï◊õ◊ü

### ◊ó◊ï◊ë◊î
- ◊î◊™◊ê◊û◊î ◊ú◊©◊û◊ï◊™ ◊ï◊û◊í◊ì◊® ◊î◊©◊ó◊ß◊†◊ô◊ù
- 6 ◊™◊©◊ï◊ë◊ï◊™ ◊©◊ï◊†◊ï◊™ ◊ú◊ó◊ú◊ï◊ò◊ô◊ü ◊ú◊õ◊ú ◊©◊ê◊ú◊î
- ◊™◊û◊ô◊ì ◊ô◊© ◊™◊©◊ï◊ë◊î ◊©◊û◊™◊ê◊ô◊û◊î
- ◊™◊ï◊õ◊ü ◊ô◊ô◊ó◊ï◊ì◊ô, ◊ú◊ê ◊í◊†◊®◊ô

### ◊ê◊°◊ï◊®
- ◊ê◊ú◊û◊†◊ò◊ô◊ù ◊©◊ú ◊ê◊ß◊°◊ô◊ù/◊ß◊†◊ê◊î/◊¢◊ë◊® ◊®◊ï◊û◊†◊ò◊ô ◊¢◊ù ◊ê◊ó◊®◊ô◊ù
- ◊©◊ê◊ú◊ï◊™/◊û◊©◊ô◊û◊ï◊™ ◊í◊†◊®◊ô◊ï◊™ ◊©◊†◊û◊¶◊ê◊ï◊™ ◊ë◊õ◊ú ◊û◊©◊ó◊ß
- ◊ß◊ú◊ô◊©◊ê◊ï◊™ ◊¢◊ú ◊ñ◊ï◊í◊ô◊ï◊™
- ◊ò◊ï◊ü ◊û◊ò◊ô◊£ ◊ê◊ï ◊©◊ô◊§◊ï◊ò◊ô

---

## ◊©◊ú◊ë◊ô ◊§◊ô◊™◊ï◊ó ◊û◊ï◊û◊ú◊¶◊ô◊ù

### Phase 1: Core
1. Setup React Native + Navigation
2. Theme + Design System
3. Onboarding Flow
4. Dr. Charif Text Component (typewriter)

### Phase 2: Game
5. Stage Flow Logic
6. Question/Task Components
7. Scoring System
8. Veto Mechanism

### Phase 3: Quiz
9. Room Creation (4-digit code)
10. Firebase Realtime Sync
11. Quiz Flow
12. Results Screen

### Phase 4: Finale
13. Prize Wheel Animation
14. End Screen
15. Sound Integration
16. Haptic Feedback

### Phase 5: Business
17. RevenueCat Integration
18. Paywall Screen
19. Analytics Events
20. Testing + Polish

---

## ◊ë◊ì◊ô◊ß◊ï◊™

### ◊ß◊®◊ô◊ò◊ô ◊ú◊ë◊ì◊ï◊ß
- [ ] Typewriter effect ◊ó◊ú◊ß
- [ ] ◊°◊†◊õ◊®◊ï◊ü ◊û◊õ◊©◊ô◊®◊ô◊ù ◊ë◊ó◊ô◊ì◊ï◊ü
- [ ] ◊™◊©◊ú◊ï◊ù ◊¢◊ï◊ë◊ì (sandbox)
- [ ] ◊õ◊ú ◊î◊ò◊ß◊°◊ò◊ô◊ù ◊ë◊¢◊ë◊®◊ô◊™ ◊™◊ß◊ô◊†◊ô◊ù
- [ ] RTL ◊™◊ß◊ô◊ü ◊ë◊õ◊ú ◊î◊û◊°◊õ◊ô◊ù
- [ ] ◊ê◊†◊ô◊û◊¶◊ô◊ï◊™ ◊ó◊ú◊ß◊ï◊™
- [ ] ◊°◊ê◊ï◊†◊ì ◊ú◊ê ◊ó◊ï◊°◊ù UI
- [ ] ◊©◊û◊ï◊™ ◊î◊©◊ó◊ß◊†◊ô◊ù ◊û◊ï◊¶◊í◊ô◊ù ◊†◊õ◊ï◊ü ◊ë◊õ◊ú ◊û◊ß◊ï◊ù

---

## ◊†◊°◊§◊ó: ◊û◊ë◊†◊î JSON ◊ú◊™◊ï◊õ◊ü

### ◊©◊ê◊ú◊ï◊™
```json
{
  "questions": [
    {
      "id": "q1",
      "stage": 1,
      "category": "time_machine",
      "difficulty": [1, 2, 3],
      "text": "◊ë◊ê◊ô◊ñ◊î ◊í◊ô◊ú ◊©◊ú {partner} ◊î◊ô◊ô◊™ ◊®◊ï◊¶◊î ◊ú◊§◊í◊ï◊© ◊ê◊ï◊™◊ï/◊ê◊ï◊™◊î ◊ï◊ú◊û◊î?",
      "forGender": "all"
    }
  ]
}
```

### ◊û◊©◊ô◊û◊ï◊™
```json
{
  "tasks": [
    {
      "id": "t1",
      "stage": 2,
      "category": "drinking",
      "difficulty": 1,
      "text": "◊ß◊ó◊ï ◊¶'◊ï◊§◊¶'◊ô◊ß ◊ë◊ô◊ó◊ì. ◊û◊ô ◊©◊û◊°◊ô◊ô◊ù ◊ê◊ó◊®◊ï◊ü ◊©◊ï◊™◊î ◊¢◊ï◊ì ◊ê◊ó◊ì.",
      "requiresConfirmation": true
    }
  ]
}
```

### ◊ò◊ß◊°◊ò◊ô◊ù ◊ì"◊® ◊ó◊®◊ô◊£
```json
{
  "drCharif": {
    "stageIntros": {
      "1": {
        "lines": [
          { "text": "◊©◊ú◊ë ◊®◊ê◊©◊ï◊ü.", "delay": 800 },
          { "text": "◊†◊ó◊ñ◊ï◊® ◊ê◊ó◊ï◊®◊î.", "delay": 600 }
        ]
      }
    },
    "transitions": {},
    "reactions": {},
    "endings": {}
  }
}
```

---

## ◊î◊™◊ó◊ú!

◊ë◊†◊î ◊ê◊™ ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊ú◊§◊ô ◊î◊û◊§◊®◊ò ◊î◊ñ◊î. ◊î◊™◊ó◊ú ◊û-Phase 1 ◊ï◊î◊™◊ß◊ì◊ù ◊ë◊°◊ì◊®. ◊©◊ê◊ú ◊©◊ê◊ú◊ï◊™ ◊ê◊ù ◊û◊©◊î◊ï ◊ú◊ê ◊ë◊®◊ï◊®.

◊î◊ì◊ë◊® ◊î◊õ◊ô ◊ó◊©◊ï◊ë: **◊ì"◊® ◊ó◊®◊ô◊£ ◊î◊ï◊ê ◊î◊ú◊ë ◊©◊ú ◊î◊û◊ï◊¶◊®**. ◊õ◊ú ◊ò◊ß◊°◊ò ◊©◊ú◊ï ◊¶◊®◊ô◊ö ◊ú◊î◊®◊í◊ô◊© ◊õ◊û◊ï ◊î◊ì◊ï◊í◊û◊ê◊ï◊™ ◊ú◊û◊¢◊ú◊î - ◊û◊™◊ï◊ó◊õ◊ù, ◊¶◊ô◊†◊ô, ◊¢◊ù ◊¢◊ï◊û◊ß.

◊ë◊î◊¶◊ú◊ó◊î! üç∑

--------------------------------------------------------------------------------
FILE: src/components/common/Button.tsx
--------------------------------------------------------------------------------

/**
 * Button Component
 *
 * ◊õ◊§◊™◊ï◊® ◊¢◊ù ◊ï◊®◊ô◊ê◊¶◊ô◊ï◊™ ◊©◊ï◊†◊ï◊™ - primary, secondary, ghost, wine
 */

import React from 'react';
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  ViewStyle,
  TextStyle,
  ActivityIndicator,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import * as Haptics from 'expo-haptics';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius, shadows, layout } from '@/theme/spacing';

type ButtonVariant = 'primary' | 'secondary' | 'ghost' | 'wine' | 'outline';
type ButtonSize = 'small' | 'medium' | 'large';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: ButtonVariant;
  size?: ButtonSize;
  disabled?: boolean;
  loading?: boolean;
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
  style?: ViewStyle;
  textStyle?: TextStyle;
  haptic?: boolean;
  fullWidth?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  icon,
  iconPosition = 'right',
  style,
  textStyle,
  haptic = true,
  fullWidth = false,
}) => {
  const handlePress = async () => {
    if (disabled || loading) return;

    if (haptic) {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }

    onPress();
  };

  const sizeStyles = SIZE_STYLES[size];
  const variantStyles = VARIANT_STYLES[variant];

  const buttonStyle: ViewStyle[] = [
    styles.base,
    sizeStyles.button,
    variantStyles.button,
    fullWidth && styles.fullWidth,
    disabled && styles.disabled,
    style,
  ];

  const labelStyle: TextStyle[] = [
    styles.label,
    sizeStyles.label,
    variantStyles.label,
    disabled && styles.disabledLabel,
    textStyle,
  ];

  const content = (
    <>
      {loading ? (
        <ActivityIndicator
          color={variant === 'ghost' || variant === 'outline' ? colors.accent.gold : colors.text.primary}
          size="small"
        />
      ) : (
        <>
          {icon && iconPosition === 'left' && icon}
          <Text style={labelStyle}>{title}</Text>
          {icon && iconPosition === 'right' && icon}
        </>
      )}
    </>
  );

  // Primary variant with gradient
  if (variant === 'primary' && !disabled) {
    return (
      <TouchableOpacity
        onPress={handlePress}
        activeOpacity={0.8}
        disabled={disabled || loading}
        style={[fullWidth && styles.fullWidth, style]}
      >
        <LinearGradient
          colors={colors.gradients.gold as unknown as string[]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 0 }}
          style={[styles.base, sizeStyles.button, styles.gradient]}
        >
          {content}
        </LinearGradient>
      </TouchableOpacity>
    );
  }

  // Wine variant with gradient
  if (variant === 'wine' && !disabled) {
    return (
      <TouchableOpacity
        onPress={handlePress}
        activeOpacity={0.8}
        disabled={disabled || loading}
        style={[fullWidth && styles.fullWidth, style]}
      >
        <LinearGradient
          colors={colors.gradients.wine as unknown as string[]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 0 }}
          style={[styles.base, sizeStyles.button, styles.gradient]}
        >
          {content}
        </LinearGradient>
      </TouchableOpacity>
    );
  }

  return (
    <TouchableOpacity
      onPress={handlePress}
      activeOpacity={0.7}
      disabled={disabled || loading}
      style={buttonStyle}
    >
      {content}
    </TouchableOpacity>
  );
};

const SIZE_STYLES = {
  small: {
    button: {
      paddingVertical: spacing.sm,
      paddingHorizontal: spacing.lg,
      minHeight: 36,
    } as ViewStyle,
    label: {
      ...typography.buttonSmall,
    } as TextStyle,
  },
  medium: {
    button: {
      paddingVertical: spacing.md,
      paddingHorizontal: spacing.xl,
      minHeight: layout.buttonHeight,
    } as ViewStyle,
    label: {
      ...typography.button,
    } as TextStyle,
  },
  large: {
    button: {
      paddingVertical: spacing.lg,
      paddingHorizontal: spacing['2xl'],
      minHeight: 64,
    } as ViewStyle,
    label: {
      ...typography.button,
      fontSize: 18,
    } as TextStyle,
  },
};

const VARIANT_STYLES = {
  primary: {
    button: {
      backgroundColor: colors.accent.gold,
    } as ViewStyle,
    label: {
      color: colors.text.inverse,
    } as TextStyle,
  },
  secondary: {
    button: {
      backgroundColor: colors.background.secondary,
      borderWidth: 1,
      borderColor: colors.accent.gold,
    } as ViewStyle,
    label: {
      color: colors.accent.gold,
    } as TextStyle,
  },
  ghost: {
    button: {
      backgroundColor: 'transparent',
    } as ViewStyle,
    label: {
      color: colors.accent.gold,
    } as TextStyle,
  },
  wine: {
    button: {
      backgroundColor: colors.accent.wine,
    } as ViewStyle,
    label: {
      color: colors.text.primary,
    } as TextStyle,
  },
  outline: {
    button: {
      backgroundColor: 'transparent',
      borderWidth: 1,
      borderColor: colors.alpha[30],
    } as ViewStyle,
    label: {
      color: colors.text.primary,
    } as TextStyle,
  },
};

const styles = StyleSheet.create({
  base: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: borderRadius.lg,
    ...shadows.sm,
  },
  gradient: {
    borderRadius: borderRadius.lg,
  },
  fullWidth: {
    width: '100%',
  },
  label: {
    textAlign: 'center',
  },
  disabled: {
    opacity: 0.5,
  },
  disabledLabel: {
    color: colors.text.muted,
  },
});

export default Button;

--------------------------------------------------------------------------------
FILE: src/components/common/Card.tsx
--------------------------------------------------------------------------------

/**
 * Card Component
 *
 * ◊õ◊®◊ò◊ô◊° ◊¢◊ù glassmorphism ◊ï◊®◊ß◊¢ ◊í◊®◊ì◊ô◊ê◊†◊ò
 */

import React from 'react';
import {
  View,
  StyleSheet,
  ViewStyle,
  TouchableOpacity,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { colors } from '@/theme/colors';
import { spacing, borderRadius, shadows } from '@/theme/spacing';

type CardVariant = 'default' | 'elevated' | 'glass' | 'bordered';

interface CardProps {
  children: React.ReactNode;
  variant?: CardVariant;
  style?: ViewStyle;
  onPress?: () => void;
  disabled?: boolean;
  noPadding?: boolean;
}

export const Card: React.FC<CardProps> = ({
  children,
  variant = 'default',
  style,
  onPress,
  disabled = false,
  noPadding = false,
}) => {
  const cardStyle: ViewStyle[] = [
    styles.base,
    !noPadding && styles.padding,
    VARIANT_STYLES[variant],
    style,
  ];

  const content = (
    <LinearGradient
      colors={colors.gradients.card as unknown as string[]}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
      style={cardStyle}
    >
      {children}
    </LinearGradient>
  );

  if (onPress) {
    return (
      <TouchableOpacity
        onPress={onPress}
        activeOpacity={0.8}
        disabled={disabled}
        style={disabled && styles.disabled}
      >
        {content}
      </TouchableOpacity>
    );
  }

  return content;
};

const VARIANT_STYLES: Record<CardVariant, ViewStyle> = {
  default: {
    borderWidth: 1,
    borderColor: colors.alpha[10],
    ...shadows.sm,
  },
  elevated: {
    borderWidth: 0,
    ...shadows.lg,
  },
  glass: {
    borderWidth: 1,
    borderColor: colors.alpha[20],
    backgroundColor: colors.effects.glass,
    ...shadows.md,
  },
  bordered: {
    borderWidth: 1,
    borderColor: colors.accent.gold,
    ...shadows.sm,
  },
};

const styles = StyleSheet.create({
  base: {
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
  },
  padding: {
    padding: spacing.lg,
  },
  disabled: {
    opacity: 0.5,
  },
});

export default Card;

--------------------------------------------------------------------------------
FILE: src/components/common/GenderSelector.tsx
--------------------------------------------------------------------------------

/**
 * GenderSelector Component
 *
 * ◊ë◊ó◊ô◊®◊™ ◊û◊í◊ì◊® ◊¢◊ù ◊¢◊ô◊¶◊ï◊ë ◊ô◊ô◊ó◊ï◊ì◊ô
 */

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ViewStyle,
} from 'react-native';
import * as Haptics from 'expo-haptics';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';

export type Gender = 'male' | 'female' | 'other';

interface GenderSelectorProps {
  value: Gender | null;
  onChange: (gender: Gender) => void;
  style?: ViewStyle;
  label?: string;
}

const GENDER_OPTIONS: Array<{ value: Gender; label: string; emoji: string }> = [
  { value: 'female', label: '◊ê◊ô◊©◊î', emoji: '‚ôÄ' },
  { value: 'male', label: '◊í◊ë◊®', emoji: '‚ôÇ' },
  { value: 'other', label: '◊ê◊ó◊®', emoji: '‚öß' },
];

export const GenderSelector: React.FC<GenderSelectorProps> = ({
  value,
  onChange,
  style,
  label,
}) => {
  const handleSelect = async (gender: Gender) => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    onChange(gender);
  };

  return (
    <View style={[styles.container, style]}>
      {label && <Text style={styles.label}>{label}</Text>}
      <View style={styles.options}>
        {GENDER_OPTIONS.map((option) => {
          const isSelected = value === option.value;
          return (
            <TouchableOpacity
              key={option.value}
              style={[styles.option, isSelected && styles.optionSelected]}
              onPress={() => handleSelect(option.value)}
              activeOpacity={0.7}
            >
              <Text
                style={[
                  styles.optionEmoji,
                  isSelected && styles.optionEmojiSelected,
                ]}
              >
                {option.emoji}
              </Text>
              <Text
                style={[
                  styles.optionLabel,
                  isSelected && styles.optionLabelSelected,
                ]}
              >
                {option.label}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: spacing.lg,
  },
  label: {
    ...typography.label,
    color: colors.text.secondary,
    marginBottom: spacing.sm,
    textAlign: 'right',
  },
  options: {
    flexDirection: 'row-reverse',
    justifyContent: 'space-between',
  },
  option: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: spacing.md,
    marginHorizontal: spacing.xs,
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.alpha[20],
    borderRadius: borderRadius.lg,
  },
  optionSelected: {
    borderColor: colors.accent.gold,
    backgroundColor: colors.background.tertiary,
  },
  optionEmoji: {
    fontSize: 24,
    marginBottom: spacing.xs,
    opacity: 0.6,
  },
  optionEmojiSelected: {
    opacity: 1,
  },
  optionLabel: {
    ...typography.bodySmall,
    color: colors.text.muted,
  },
  optionLabelSelected: {
    color: colors.accent.gold,
  },
});

export default GenderSelector;

--------------------------------------------------------------------------------
FILE: src/components/common/GlassCard.tsx
--------------------------------------------------------------------------------

/**
 * ◊õ◊®◊ò◊ô◊° ◊ñ◊õ◊ï◊õ◊ô◊™ - Glass Morphism
 * ◊î◊ê◊ú◊û◊†◊ò ◊î◊ï◊ô◊ñ◊ï◊ê◊ú◊ô ◊î◊û◊®◊õ◊ñ◊ô ◊©◊ú ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î
 */

import React from 'react';
import { View, StyleSheet, ViewStyle, Platform } from 'react-native';
import { BlurView } from 'expo-blur';
import { LinearGradient } from 'expo-linear-gradient';
import Animated, { FadeIn } from 'react-native-reanimated';

import { colors, borderRadius, shadows } from '../../theme';

interface Props {
  children: React.ReactNode;
  style?: ViewStyle;
  intensity?: 'light' | 'medium' | 'strong';
  animated?: boolean;
  noPadding?: boolean;
}

export const GlassCard: React.FC<Props> = ({
  children,
  style,
  intensity = 'medium',
  animated = true,
  noPadding = false,
}) => {
  const intensityMap = {
    light: { blur: 40, opacity: 0.08, bg: 0.06 },
    medium: { blur: 60, opacity: 0.12, bg: 0.08 },
    strong: { blur: 80, opacity: 0.15, bg: 0.12 },
  };

  const { blur, opacity, bg } = intensityMap[intensity];

  const Container = animated ? Animated.View : View;
  const animatedProps = animated ? { entering: FadeIn.duration(400) } : {};

  return (
    <Container style={[styles.container, { backgroundColor: `rgba(255, 255, 255, ${bg})` }, style]} {...animatedProps}>
      {/* Blur background - iOS and Android */}
      {Platform.OS !== 'web' && (
        <BlurView
          intensity={blur}
          style={StyleSheet.absoluteFill}
          tint="dark"
        />
      )}

      {/* Gradient overlay for glass effect */}
      <LinearGradient
        colors={[
          `rgba(255, 255, 255, ${opacity})`,
          `rgba(255, 255, 255, ${opacity * 0.4})`,
        ]}
        style={StyleSheet.absoluteFill}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      />

      {/* Border glow - stronger */}
      <View style={styles.borderOverlay} />

      {/* Content */}
      <View style={[styles.content, noPadding && styles.noPadding]}>
        {children}
      </View>
    </Container>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: borderRadius.lg,
    overflow: 'hidden',
    ...shadows.glass,
  },
  borderOverlay: {
    ...StyleSheet.absoluteFillObject,
    borderRadius: borderRadius.lg,
    borderWidth: 1.5,
    borderColor: 'rgba(255, 255, 255, 0.2)',
  },
  content: {
    padding: 24,
  },
  noPadding: {
    padding: 0,
  },
});

export default GlassCard;

--------------------------------------------------------------------------------
FILE: src/components/common/GoldButton.tsx
--------------------------------------------------------------------------------

/**
 * ◊õ◊§◊™◊ï◊® ◊ñ◊î◊ë ◊§◊®◊ô◊û◊ô◊ï◊ù
 */

import React from 'react';
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  ViewStyle,
  ActivityIndicator,
  View,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

import { colors, typography, borderRadius, shadows } from '../../theme';

interface Props {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  style?: ViewStyle;
  icon?: React.ReactNode;
}

const AnimatedTouchable = Animated.createAnimatedComponent(TouchableOpacity);

export const GoldButton: React.FC<Props> = ({
  title,
  onPress,
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  style,
  icon,
}) => {
  const scale = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
  }));

  const handlePressIn = () => {
    scale.value = withSpring(0.96);
  };

  const handlePressOut = () => {
    scale.value = withSpring(1);
  };

  const handlePress = async () => {
    if (disabled || loading) return;
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onPress();
  };

  const sizeStyles = {
    small: { paddingVertical: 10, paddingHorizontal: 20 },
    medium: { paddingVertical: 14, paddingHorizontal: 28 },
    large: { paddingVertical: 18, paddingHorizontal: 36 },
  };

  if (variant === 'primary') {
    return (
      <AnimatedTouchable
        onPress={handlePress}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        disabled={disabled || loading}
        style={[animatedStyle, style]}
        activeOpacity={0.9}
      >
        <LinearGradient
          colors={disabled ? ['#666', '#555'] : [colors.accent.gold, colors.accent.goldDark]}
          style={[styles.primary, sizeStyles[size], disabled && styles.disabled]}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
        >
          {loading ? (
            <ActivityIndicator color={colors.background.primary} />
          ) : (
            <View style={styles.contentRow}>
              {icon}
              <Text style={[styles.primaryText, icon && styles.textWithIcon]}>
                {title}
              </Text>
            </View>
          )}
        </LinearGradient>
      </AnimatedTouchable>
    );
  }

  if (variant === 'secondary') {
    return (
      <AnimatedTouchable
        onPress={handlePress}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        disabled={disabled || loading}
        style={[animatedStyle, styles.secondary, sizeStyles[size], style]}
        activeOpacity={0.8}
      >
        {loading ? (
          <ActivityIndicator color={colors.accent.gold} />
        ) : (
          <View style={styles.contentRow}>
            {icon}
            <Text style={[styles.secondaryText, icon && styles.textWithIcon]}>
              {title}
            </Text>
          </View>
        )}
      </AnimatedTouchable>
    );
  }

  // Ghost variant
  return (
    <AnimatedTouchable
      onPress={handlePress}
      onPressIn={handlePressIn}
      onPressOut={handlePressOut}
      disabled={disabled || loading}
      style={[animatedStyle, styles.ghost, sizeStyles[size], style]}
      activeOpacity={0.7}
    >
      {loading ? (
        <ActivityIndicator color={colors.text.tertiary} />
      ) : (
        <View style={styles.contentRow}>
          {icon}
          <Text style={[styles.ghostText, icon && styles.textWithIcon]}>
            {title}
          </Text>
        </View>
      )}
    </AnimatedTouchable>
  );
};

const styles = StyleSheet.create({
  primary: {
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: borderRadius.full,
    ...shadows.goldGlow,
  },
  primaryText: {
    fontFamily: 'Heebo-Medium',
    fontSize: 16,
    color: colors.background.primary,
    letterSpacing: 0.5,
  },
  secondary: {
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: borderRadius.full,
    borderWidth: 1.5,
    borderColor: colors.accent.gold,
    backgroundColor: 'transparent',
  },
  secondaryText: {
    fontFamily: 'Heebo-Regular',
    fontSize: 16,
    color: colors.accent.gold,
  },
  ghost: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  ghostText: {
    fontFamily: 'Heebo-Regular',
    fontSize: 16,
    color: colors.text.tertiary,
  },
  disabled: {
    opacity: 0.5,
  },
  contentRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  textWithIcon: {
    marginLeft: 8,
  },
});

export default GoldButton;

--------------------------------------------------------------------------------
FILE: src/components/common/Input.tsx
--------------------------------------------------------------------------------

/**
 * Input Component
 *
 * ◊©◊ì◊î ◊ß◊ú◊ò ◊¢◊ù ◊¢◊ô◊¶◊ï◊ë ◊ô◊ô◊ó◊ï◊ì◊ô ◊ú◊ñ◊ï◊í◊ô◊ò
 */

import React, { useState } from 'react';
import {
  View,
  TextInput,
  Text,
  StyleSheet,
  ViewStyle,
  TextStyle,
  TextInputProps,
  Animated,
} from 'react-native';
import { colors } from '@/theme/colors';
import { typography, fontFamilies } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';

interface InputProps extends Omit<TextInputProps, 'style'> {
  label?: string;
  error?: string;
  hint?: string;
  containerStyle?: ViewStyle;
  inputStyle?: TextStyle;
  rightIcon?: React.ReactNode;
  leftIcon?: React.ReactNode;
}

export const Input: React.FC<InputProps> = ({
  label,
  error,
  hint,
  containerStyle,
  inputStyle,
  rightIcon,
  leftIcon,
  onFocus,
  onBlur,
  ...props
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const borderColor = error
    ? colors.state.error
    : isFocused
    ? colors.accent.gold
    : colors.alpha[20];

  const handleFocus = (e: any) => {
    setIsFocused(true);
    onFocus?.(e);
  };

  const handleBlur = (e: any) => {
    setIsFocused(false);
    onBlur?.(e);
  };

  return (
    <View style={[styles.container, containerStyle]}>
      {label && <Text style={styles.label}>{label}</Text>}

      <View style={[styles.inputContainer, { borderColor }]}>
        {rightIcon && <View style={styles.iconRight}>{rightIcon}</View>}

        <TextInput
          style={[
            styles.input,
            leftIcon && styles.inputWithLeftIcon,
            rightIcon && styles.inputWithRightIcon,
            inputStyle,
          ]}
          placeholderTextColor={colors.text.muted}
          selectionColor={colors.accent.gold}
          onFocus={handleFocus}
          onBlur={handleBlur}
          textAlign="right"
          {...props}
        />

        {leftIcon && <View style={styles.iconLeft}>{leftIcon}</View>}
      </View>

      {(error || hint) && (
        <Text style={[styles.hint, error && styles.errorText]}>
          {error || hint}
        </Text>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: spacing.lg,
  },
  label: {
    ...typography.label,
    color: colors.text.secondary,
    marginBottom: spacing.sm,
    textAlign: 'right',
  },
  inputContainer: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderRadius: borderRadius.lg,
    paddingHorizontal: spacing.md,
  },
  input: {
    flex: 1,
    fontFamily: fontFamilies.heeboRegular,
    fontSize: 16,
    color: colors.text.primary,
    paddingVertical: spacing.md,
    textAlign: 'right',
    writingDirection: 'rtl',
  },
  inputWithRightIcon: {
    paddingRight: spacing.sm,
  },
  inputWithLeftIcon: {
    paddingLeft: spacing.sm,
  },
  iconRight: {
    marginLeft: spacing.sm,
  },
  iconLeft: {
    marginRight: spacing.sm,
  },
  hint: {
    ...typography.caption,
    color: colors.text.muted,
    marginTop: spacing.xs,
    textAlign: 'right',
  },
  errorText: {
    color: colors.state.error,
  },
});

export default Input;

--------------------------------------------------------------------------------
FILE: src/components/common/PlayerScoreCard.tsx
--------------------------------------------------------------------------------

/**
 * ◊õ◊®◊ò◊ô◊° ◊©◊ó◊ß◊ü ◊¢◊ù ◊†◊ô◊ß◊ï◊ì
 * ◊û◊¶◊ô◊í ◊©◊ù, ◊ê◊ï◊ï◊ò◊ê◊® ◊ï◊†◊ô◊ß◊ï◊ì ◊ë◊°◊í◊†◊ï◊ü ◊ô◊ï◊ß◊®◊™◊ô
 */

import React, { useEffect } from 'react';
import { View, Text, Image, StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withSequence,
} from 'react-native-reanimated';

import { GlassCard } from './GlassCard';
import { colors, spacing } from '../../theme';

interface Props {
  name: string;
  score: number;
  avatar?: string;
  isActive?: boolean;
  position?: 'left' | 'right';
}

export const PlayerScoreCard: React.FC<Props> = ({
  name,
  score,
  avatar,
  isActive = false,
  position = 'left',
}) => {
  const scaleAnim = useSharedValue(1);

  // Pulse animation when active
  useEffect(() => {
    if (isActive) {
      scaleAnim.value = withSequence(
        withSpring(1.05),
        withSpring(1)
      );
    }
  }, [isActive]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scaleAnim.value }],
  }));

  const isRight = position === 'right';

  return (
    <Animated.View style={[styles.container, animatedStyle]}>
      <GlassCard
        intensity={isActive ? 'strong' : 'light'}
        style={[styles.card, isActive && styles.activeCard]}
        noPadding
      >
        <View style={[styles.content, isRight && styles.contentRight]}>
          {/* Avatar */}
          <View style={[styles.avatarContainer, isActive && styles.avatarActive]}>
            {avatar ? (
              <Image source={{ uri: avatar }} style={styles.avatar} />
            ) : (
              <View style={styles.avatarPlaceholder}>
                <Text style={styles.avatarInitial}>{name.charAt(0)}</Text>
              </View>
            )}
          </View>

          {/* Info */}
          <View style={[styles.info, isRight && styles.infoRight]}>
            <Text style={styles.name} numberOfLines={1}>{name}</Text>
            <View style={styles.scoreContainer}>
              <Text style={styles.scoreLabel}>◊†◊ô◊ß◊ï◊ì</Text>
              <Text style={styles.score}>{score}</Text>
            </View>
          </View>
        </View>

        {/* Active indicator */}
        {isActive && <View style={styles.activeIndicator} />}
      </GlassCard>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    maxWidth: 160,
  },
  card: {
    borderRadius: 16,
  },
  activeCard: {
    borderColor: colors.accent.gold,
    borderWidth: 1,
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    gap: 10,
  },
  contentRight: {
    flexDirection: 'row-reverse',
  },
  avatarContainer: {
    width: 44,
    height: 44,
    borderRadius: 22,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: colors.glass.border,
  },
  avatarActive: {
    borderColor: colors.accent.gold,
  },
  avatar: {
    width: '100%',
    height: '100%',
  },
  avatarPlaceholder: {
    width: '100%',
    height: '100%',
    backgroundColor: colors.accent.wine,
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarInitial: {
    fontFamily: 'Heebo-Medium',
    fontSize: 18,
    color: colors.text.primary,
  },
  info: {
    flex: 1,
    alignItems: 'flex-start',
  },
  infoRight: {
    alignItems: 'flex-end',
  },
  name: {
    fontFamily: 'Heebo-Medium',
    fontSize: 14,
    color: colors.text.primary,
    marginBottom: 2,
  },
  scoreContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    gap: 4,
  },
  scoreLabel: {
    fontFamily: 'Heebo-Medium',
    fontSize: 9,
    color: colors.text.muted,
    textTransform: 'uppercase',
    letterSpacing: 2,
  },
  score: {
    fontFamily: 'PlayfairDisplay-Bold',
    fontSize: 20,
    color: colors.accent.gold,
  },
  activeIndicator: {
    position: 'absolute',
    bottom: 0,
    left: '20%',
    right: '20%',
    height: 2,
    backgroundColor: colors.accent.gold,
    borderRadius: 1,
  },
});

export default PlayerScoreCard;

--------------------------------------------------------------------------------
FILE: src/components/common/ScreenBackground.tsx
--------------------------------------------------------------------------------

/**
 * ◊®◊ß◊¢ ◊û◊°◊ö ◊¢◊ù ◊í◊®◊ì◊ô◊ê◊†◊ò ◊ï◊ê◊ú◊û◊†◊ò◊ô◊ù ◊ì◊ß◊ï◊®◊ò◊ô◊ë◊ô◊ô◊ù
 */

import React, { useEffect } from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
  interpolate,
} from 'react-native-reanimated';

import { colors } from '../../theme';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

interface Props {
  children: React.ReactNode;
  variant?: 'default' | 'glow' | 'minimal';
}

export const ScreenBackground: React.FC<Props> = ({
  children,
  variant = 'default',
}) => {
  // Subtle floating animation for glow
  const floatAnim = useSharedValue(0);

  useEffect(() => {
    floatAnim.value = withRepeat(
      withTiming(1, { duration: 8000, easing: Easing.inOut(Easing.ease) }),
      -1,
      true
    );
  }, []);

  const glowStyle = useAnimatedStyle(() => ({
    transform: [
      { translateY: interpolate(floatAnim.value, [0, 1], [-10, 10]) },
      { scale: interpolate(floatAnim.value, [0, 1], [1, 1.05]) },
    ],
    opacity: interpolate(floatAnim.value, [0, 1], [0.4, 0.6]),
  }));

  return (
    <View style={styles.container}>
      {/* Base gradient */}
      <LinearGradient
        colors={colors.gradients.background as unknown as string[]}
        style={StyleSheet.absoluteFill}
        start={{ x: 0.5, y: 0 }}
        end={{ x: 0.5, y: 1 }}
      />

      {/* Ambient glow orb */}
      {variant !== 'minimal' && (
        <Animated.View style={[styles.glowOrb, glowStyle]} />
      )}

      {/* Decorative lines */}
      {variant === 'glow' && (
        <>
          <View style={[styles.decorLine, styles.decorLineLeft]} />
          <View style={[styles.decorLine, styles.decorLineRight]} />
        </>
      )}

      {/* Content */}
      <View style={styles.content}>{children}</View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  glowOrb: {
    position: 'absolute',
    top: SCREEN_HEIGHT * 0.25,
    left: SCREEN_WIDTH * 0.5 - 150,
    width: 300,
    height: 300,
    borderRadius: 150,
    backgroundColor: colors.accent.wine,
    opacity: 0.3,
  },
  decorLine: {
    position: 'absolute',
    width: 100,
    height: 1,
    backgroundColor: colors.accent.gold,
    opacity: 0.2,
  },
  decorLineLeft: {
    bottom: 150,
    left: -30,
    transform: [{ rotate: '45deg' }],
  },
  decorLineRight: {
    bottom: 150,
    right: -30,
    transform: [{ rotate: '-45deg' }],
  },
  content: {
    flex: 1,
  },
});

export default ScreenBackground;

--------------------------------------------------------------------------------
FILE: src/components/common/ScreenContainer.tsx
--------------------------------------------------------------------------------

/**
 * ScreenContainer Component
 *
 * ◊û◊ô◊õ◊ú ◊ë◊°◊ô◊°◊ô ◊ú◊û◊°◊õ◊ô◊ù ◊¢◊ù ◊®◊ß◊¢ ◊í◊®◊ì◊ô◊ê◊†◊ò ◊ï-SafeArea
 */

import React from 'react';
import {
  View,
  StyleSheet,
  StatusBar,
  ViewStyle,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { colors } from '@/theme/colors';
import { spacing } from '@/theme/spacing';

interface ScreenContainerProps {
  children: React.ReactNode;
  style?: ViewStyle;
  scrollable?: boolean;
  keyboardAvoiding?: boolean;
  noPadding?: boolean;
  safeArea?: boolean;
}

export const ScreenContainer: React.FC<ScreenContainerProps> = ({
  children,
  style,
  scrollable = false,
  keyboardAvoiding = false,
  noPadding = false,
  safeArea = true,
}) => {
  const contentStyle: ViewStyle[] = [
    styles.content,
    !noPadding && styles.padding,
    style,
  ];

  let content = <View style={contentStyle}>{children}</View>;

  if (scrollable) {
    content = (
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={[styles.scrollContent, !noPadding && styles.padding, style]}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        {children}
      </ScrollView>
    );
  }

  if (keyboardAvoiding) {
    content = (
      <KeyboardAvoidingView
        style={styles.keyboardAvoiding}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        {content}
      </KeyboardAvoidingView>
    );
  }

  const Container = safeArea ? SafeAreaView : View;

  return (
    <LinearGradient
      colors={colors.gradients.primary as unknown as string[]}
      style={styles.gradient}
    >
      <StatusBar barStyle="light-content" backgroundColor={colors.background.primary} />
      <Container style={styles.safeArea}>
        {content}
      </Container>
    </LinearGradient>
  );
};

const styles = StyleSheet.create({
  gradient: {
    flex: 1,
  },
  safeArea: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  padding: {
    paddingHorizontal: spacing.xl,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
  },
  keyboardAvoiding: {
    flex: 1,
  },
});

export default ScreenContainer;

--------------------------------------------------------------------------------
FILE: src/components/common/TypewriterText.tsx
--------------------------------------------------------------------------------

/**
 * ◊ò◊ß◊°◊ò ◊¢◊ù ◊ê◊§◊ß◊ò ◊î◊ß◊ú◊ì◊î
 * ◊õ◊ú ◊ê◊ï◊™ ◊û◊ï◊§◊ô◊¢◊î ◊ë◊†◊§◊®◊ì ◊¢◊ù ◊ß◊ï◊®◊°◊ï◊® ◊û◊î◊ë◊î◊ë
 */

import React, { useState, useEffect } from 'react';
import { Text, StyleSheet, TextStyle } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withSequence,
  withTiming,
} from 'react-native-reanimated';

import { colors } from '../../theme';

interface Props {
  text: string;
  speed?: number; // ms per character
  delay?: number; // initial delay
  style?: TextStyle;
  onStart?: () => void;
  onComplete?: () => void;
  showCursor?: boolean;
}

export const TypewriterText: React.FC<Props> = ({
  text,
  speed = 35,
  delay = 0,
  style,
  onStart,
  onComplete,
  showCursor = true,
}) => {
  const [displayedText, setDisplayedText] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const cursorOpacity = useSharedValue(1);

  // Blinking cursor animation
  useEffect(() => {
    cursorOpacity.value = withRepeat(
      withSequence(
        withTiming(0, { duration: 400 }),
        withTiming(1, { duration: 400 })
      ),
      -1,
      true
    );
  }, []);

  const cursorStyle = useAnimatedStyle(() => ({
    opacity: cursorOpacity.value,
  }));

  // Typewriter effect
  useEffect(() => {
    let charIndex = 0;
    let typeInterval: NodeJS.Timeout;
    setDisplayedText('');

    const startTimeout = setTimeout(() => {
      setIsTyping(true);
      onStart?.();

      typeInterval = setInterval(() => {
        if (charIndex < text.length) {
          setDisplayedText(text.substring(0, charIndex + 1));
          charIndex++;
        } else {
          clearInterval(typeInterval);
          setIsTyping(false);
          onComplete?.();
        }
      }, speed);
    }, delay);

    return () => {
      clearTimeout(startTimeout);
      if (typeInterval) clearInterval(typeInterval);
    };
  }, [text, speed, delay]);

  return (
    <Text style={[styles.text, style]}>
      {displayedText}
      {showCursor && isTyping && (
        <Animated.Text style={[styles.cursor, cursorStyle]}>|</Animated.Text>
      )}
    </Text>
  );
};

const styles = StyleSheet.create({
  text: {
    fontFamily: 'Heebo-Light',
    fontSize: 24,
    lineHeight: 40,
    color: colors.text.primary,
    textAlign: 'center',
  },
  cursor: {
    color: colors.accent.gold,
    fontWeight: '300',
  },
});

export default TypewriterText;

--------------------------------------------------------------------------------
FILE: src/components/common/index.ts
--------------------------------------------------------------------------------

// Existing components
export { Button } from './Button';
export { Card } from './Card';
export { Input } from './Input';
export { GenderSelector, type Gender } from './GenderSelector';
export { ScreenContainer } from './ScreenContainer';

// New premium components
export { GlassCard } from './GlassCard';
export { GoldButton } from './GoldButton';
export { PlayerScoreCard } from './PlayerScoreCard';
export { ScreenBackground } from './ScreenBackground';
export { TypewriterText } from './TypewriterText';

--------------------------------------------------------------------------------
FILE: src/components/drCharif/DrCharifAvatar.tsx
--------------------------------------------------------------------------------

/**
 * ◊ê◊ï◊ï◊ò◊ê◊® ◊ì"◊® ◊ó◊®◊ô◊£ ◊¢◊ù 4 ◊î◊ë◊¢◊ï◊™ ◊ï◊ê◊†◊ô◊û◊¶◊ô◊ï◊™
 * ◊™◊ï◊û◊ö ◊ë◊™◊û◊ï◊†◊ï◊™ ◊¢◊ù fallback ◊ú◊í◊®◊ì◊ô◊ê◊†◊ò
 */

import React, { useEffect, useState } from 'react';
import { View, Image, StyleSheet, ImageSourcePropType } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withSequence,
  withTiming,
  Easing,
  interpolate,
} from 'react-native-reanimated';
import { LinearGradient } from 'expo-linear-gradient';

import { colors, shadows } from '../../theme';

export type DrCharifExpression = 'listening' | 'speaking' | 'skeptical' | 'approving';

// Try to load images - will fail gracefully if not present
let EXPRESSIONS: Record<DrCharifExpression, ImageSourcePropType | null> = {
  listening: null,
  speaking: null,
  skeptical: null,
  approving: null,
};

// Try to require images (will be null if files don't exist)
try {
  EXPRESSIONS.listening = require('../../../assets/images/drCharif/charif_listening.png');
} catch (e) {}
try {
  EXPRESSIONS.speaking = require('../../../assets/images/drCharif/charif_speaking.png');
} catch (e) {}
try {
  EXPRESSIONS.skeptical = require('../../../assets/images/drCharif/charif_skeptical.png');
} catch (e) {}
try {
  EXPRESSIONS.approving = require('../../../assets/images/drCharif/charif_approving.png');
} catch (e) {}

interface Props {
  expression?: DrCharifExpression;
  isSpeaking?: boolean;
  size?: number;
}

export const DrCharifAvatar: React.FC<Props> = ({
  expression = 'listening',
  isSpeaking = false,
  size = 100,
}) => {
  const [imageError, setImageError] = useState(false);
  const hasImage = EXPRESSIONS[expression] !== null && !imageError;

  // Animations
  const breatheAnim = useSharedValue(0);
  const speakingAnim = useSharedValue(0);
  const glowAnim = useSharedValue(0.3);

  // Breathing animation (always running)
  useEffect(() => {
    breatheAnim.value = withRepeat(
      withSequence(
        withTiming(1, { duration: 3000, easing: Easing.inOut(Easing.ease) }),
        withTiming(0, { duration: 3000, easing: Easing.inOut(Easing.ease) })
      ),
      -1,
      true
    );
  }, []);

  // Speaking pulse animation
  useEffect(() => {
    if (isSpeaking) {
      speakingAnim.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 300 }),
          withTiming(0, { duration: 300 })
        ),
        -1,
        true
      );
      glowAnim.value = withTiming(0.7, { duration: 200 });
    } else {
      speakingAnim.value = withTiming(0, { duration: 200 });
      glowAnim.value = withTiming(0.3, { duration: 300 });
    }
  }, [isSpeaking]);

  // Animated styles
  const containerStyle = useAnimatedStyle(() => {
    const breatheScale = interpolate(breatheAnim.value, [0, 1], [1, 1.015]);
    const speakingScale = interpolate(speakingAnim.value, [0, 1], [1, 1.04]);
    return {
      transform: [{ scale: breatheScale * speakingScale }],
    };
  });

  const glowStyle = useAnimatedStyle(() => ({
    opacity: glowAnim.value,
    transform: [
      { scale: interpolate(glowAnim.value, [0.3, 0.7], [1, 1.1]) },
    ],
  }));

  // Expression colors for fallback gradient
  const getExpressionColors = (): [string, string, string] => {
    switch (expression) {
      case 'speaking':
        return [colors.accent.wine, colors.accent.wineLight, colors.accent.wine];
      case 'skeptical':
        return [colors.accent.goldDark, colors.accent.wine, colors.accent.goldDark];
      case 'approving':
        return [colors.accent.gold, colors.accent.goldLight, colors.accent.gold];
      case 'listening':
      default:
        return [colors.accent.wine, colors.accent.wineLight, colors.accent.wine];
    }
  };

  return (
    <View style={[styles.container, { width: size * 1.4, height: size * 1.4 }]}>
      {/* Strong glow effect behind avatar */}
      <Animated.View
        style={[
          styles.glowContainer,
          {
            width: size * 1.6,
            height: size * 1.6,
            borderRadius: size * 0.8,
          },
          glowStyle,
        ]}
      >
        <LinearGradient
          colors={['rgba(114, 47, 55, 0.6)', 'rgba(114, 47, 55, 0.2)', 'transparent']}
          style={styles.glow}
          start={{ x: 0.5, y: 0.5 }}
          end={{ x: 0.5, y: 1 }}
        />
      </Animated.View>

      {/* Secondary glow for depth */}
      <Animated.View
        style={[
          styles.secondaryGlow,
          {
            width: size * 1.3,
            height: size * 1.3,
            borderRadius: size * 0.65,
          },
          glowStyle,
        ]}
      >
        <LinearGradient
          colors={[colors.accent.gold, colors.accent.wine, 'transparent']}
          style={StyleSheet.absoluteFill}
          start={{ x: 0.5, y: 0 }}
          end={{ x: 0.5, y: 1 }}
        />
      </Animated.View>

      {/* Avatar container */}
      <Animated.View
        style={[
          styles.avatarContainer,
          { width: size, height: size, borderRadius: size / 2 },
          containerStyle,
        ]}
      >
        {/* Gold ring */}
        <View
          style={[
            styles.ring,
            { width: size + 4, height: size + 4, borderRadius: (size + 4) / 2 },
          ]}
        />

        {/* Avatar - Image or Gradient Fallback */}
        {hasImage && EXPRESSIONS[expression] ? (
          <Image
            source={EXPRESSIONS[expression]!}
            style={[styles.avatarImage, { borderRadius: size / 2 }]}
            resizeMode="cover"
            onError={(e) => {
              console.log('Image failed to load:', e.nativeEvent.error);
              setImageError(true);
            }}
          />
        ) : (
          <LinearGradient
            colors={getExpressionColors()}
            style={[styles.avatar, { borderRadius: size / 2 }]}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            {/* Inner glow for fallback */}
            <View style={[styles.innerGlow, { borderRadius: size / 2 }]} />
          </LinearGradient>
        )}
      </Animated.View>

      {/* Speaking indicator */}
      {isSpeaking && (
        <View style={styles.speakingIndicator}>
          {[0, 1, 2].map((i) => (
            <SpeakingDot key={i} delay={i * 150} />
          ))}
        </View>
      )}
    </View>
  );
};

// Speaking indicator dots
const SpeakingDot: React.FC<{ delay: number }> = ({ delay }) => {
  const anim = useSharedValue(0);

  useEffect(() => {
    const timeout = setTimeout(() => {
      anim.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 300 }),
          withTiming(0, { duration: 300 })
        ),
        -1,
        true
      );
    }, delay);

    return () => clearTimeout(timeout);
  }, [delay]);

  const dotStyle = useAnimatedStyle(() => ({
    opacity: interpolate(anim.value, [0, 1], [0.3, 1]),
    transform: [{ scale: interpolate(anim.value, [0, 1], [0.8, 1.2]) }],
  }));

  return <Animated.View style={[styles.dot, dotStyle]} />;
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  glowContainer: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
  },
  glow: {
    flex: 1,
    width: '100%',
    height: '100%',
    borderRadius: 999,
  },
  secondaryGlow: {
    position: 'absolute',
    overflow: 'hidden',
  },
  avatarContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    ...shadows.goldGlow,
  },
  ring: {
    position: 'absolute',
    borderWidth: 2,
    borderColor: colors.accent.gold,
  },
  avatarImage: {
    width: '100%',
    height: '100%',
    backgroundColor: colors.background.secondary,
  },
  avatar: {
    width: '100%',
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
  },
  innerGlow: {
    position: 'absolute',
    top: '20%',
    left: '20%',
    right: '20%',
    bottom: '20%',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  speakingIndicator: {
    position: 'absolute',
    bottom: 0,
    flexDirection: 'row',
    gap: 6,
  },
  dot: {
    width: 6,
    height: 6,
    borderRadius: 3,
    backgroundColor: colors.accent.gold,
  },
});

export default DrCharifAvatar;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/DrCharifExperience.tsx
--------------------------------------------------------------------------------

/**
 * ◊î◊ó◊ï◊ï◊ô◊î ◊î◊û◊ú◊ê◊î ◊©◊ú ◊ì"◊® ◊ó◊®◊ô◊£
 * ◊û◊©◊ú◊ë ◊ê◊ï◊ï◊ò◊ê◊® + ◊ò◊ß◊°◊ò + ◊ê◊ï◊ï◊ô◊®◊î
 */

import React, { useState, useCallback } from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import * as Haptics from 'expo-haptics';

import { DrCharifAvatar } from './DrCharifAvatar';
import { DrCharifText } from './DrCharifText';
import { colors } from '@/theme/colors';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');

interface TextLine {
  text: string;
  delay: number;
}

interface Props {
  lines: TextLine[];
  onComplete?: () => void;
  showAvatar?: boolean;
  variant?: 'fullscreen' | 'inline';
}

export const DrCharifExperience: React.FC<Props> = ({
  lines,
  onComplete,
  showAvatar = true,
  variant = 'fullscreen',
}) => {
  const [isSpeaking, setIsSpeaking] = useState(true);

  const handleLineStart = useCallback((index: number) => {
    setIsSpeaking(true);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  }, []);

  const handleLineComplete = useCallback((index: number) => {
    setIsSpeaking(false);
  }, []);

  const handleAllComplete = useCallback(() => {
    setIsSpeaking(false);
    onComplete?.();
  }, [onComplete]);

  const content = (
    <View style={styles.content}>
      {showAvatar && (
        <View style={styles.avatarSection}>
          <DrCharifAvatar isSpeaking={isSpeaking} size={80} />
        </View>
      )}

      <View style={styles.textSection}>
        <DrCharifText
          lines={lines}
          onLineStart={handleLineStart}
          onLineComplete={handleLineComplete}
          onAllComplete={handleAllComplete}
        />
      </View>
    </View>
  );

  if (variant === 'inline') {
    return <View style={styles.inlineContainer}>{content}</View>;
  }

  return (
    <LinearGradient
      colors={[colors.background.primary, colors.background.secondary, colors.background.primary]}
      style={styles.fullscreenContainer}
      start={{ x: 0.5, y: 0 }}
      end={{ x: 0.5, y: 1 }}
    >
      {/* Ambient glow effect */}
      <View style={styles.ambientGlow} />

      {content}
    </LinearGradient>
  );
};

const styles = StyleSheet.create({
  fullscreenContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  inlineContainer: {
    paddingVertical: 40,
  },
  ambientGlow: {
    position: 'absolute',
    top: SCREEN_HEIGHT * 0.3,
    width: 300,
    height: 300,
    borderRadius: 150,
    backgroundColor: colors.accent.wine,
    opacity: 0.1,
  },
  content: {
    alignItems: 'center',
    width: '100%',
  },
  avatarSection: {
    marginBottom: 48,
  },
  textSection: {
    width: '100%',
  },
});

export default DrCharifExperience;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/DrCharifMessage.tsx
--------------------------------------------------------------------------------

/**
 * DrCharifMessage Component
 *
 * ◊®◊õ◊ô◊ë ◊ú◊î◊¶◊í◊™ ◊î◊ï◊ì◊¢◊ï◊™ ◊ì"◊® ◊ó◊®◊ô◊£ ◊¢◊ù ◊¢◊ô◊¶◊ï◊ë ◊ô◊ô◊ó◊ï◊ì◊ô
 * ◊õ◊ï◊ú◊ú ◊ê◊ô◊ô◊ß◊ï◊ü, ◊®◊ß◊¢ glassmorphism, ◊ï◊ê◊§◊ß◊ò typewriter
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ViewStyle,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius, shadows } from '@/theme/spacing';
import { TypewriterText } from './TypewriterText';

interface DrCharifMessageProps {
  lines: Array<{ text: string; delay: number }>;
  onComplete?: () => void;
  showContinueButton?: boolean;
  onContinue?: () => void;
  continueText?: string;
  style?: ViewStyle;
  variant?: 'default' | 'minimal' | 'card';
}

export const DrCharifMessage: React.FC<DrCharifMessageProps> = ({
  lines,
  onComplete,
  showContinueButton = false,
  onContinue,
  continueText = '◊î◊û◊©◊ö',
  style,
  variant = 'default',
}) => {
  const [isTypingComplete, setIsTypingComplete] = useState(false);

  const handleTypingComplete = () => {
    setIsTypingComplete(true);
    onComplete?.();
  };

  if (variant === 'minimal') {
    return (
      <View style={[styles.minimalContainer, style]}>
        <TypewriterText lines={lines} onComplete={handleTypingComplete} />
        {showContinueButton && isTypingComplete && (
          <TouchableOpacity
            style={styles.minimalButton}
            onPress={onContinue}
            activeOpacity={0.7}
          >
            <Text style={styles.minimalButtonText}>{continueText}</Text>
          </TouchableOpacity>
        )}
      </View>
    );
  }

  return (
    <View style={[styles.container, style]}>
      <LinearGradient
        colors={[colors.background.secondary, colors.background.tertiary]}
        style={styles.gradient}
        start={{ x: 0, y: 0 }}
        end={{ x: 1, y: 1 }}
      >
        {/* Header with Dr. Charif indicator */}
        <View style={styles.header}>
          <View style={styles.indicator}>
            <Text style={styles.indicatorText}>◊ì◊¥◊® ◊ó◊®◊ô◊£</Text>
          </View>
          <View style={styles.decorLine} />
        </View>

        {/* Message content */}
        <View style={styles.content}>
          <TypewriterText
            lines={lines}
            onComplete={handleTypingComplete}
            speed="normal"
          />
        </View>

        {/* Continue button */}
        {showContinueButton && isTypingComplete && (
          <TouchableOpacity
            style={styles.continueButton}
            onPress={onContinue}
            activeOpacity={0.8}
          >
            <Text style={styles.continueButtonText}>{continueText}</Text>
            <Text style={styles.arrow}>‚Üê</Text>
          </TouchableOpacity>
        )}
      </LinearGradient>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginHorizontal: spacing.lg,
    borderRadius: borderRadius.xl,
    overflow: 'hidden',
    ...shadows.md,
  },
  minimalContainer: {
    paddingHorizontal: spacing.lg,
  },
  gradient: {
    padding: spacing.xl,
    borderWidth: 1,
    borderColor: colors.alpha[10],
    borderRadius: borderRadius.xl,
  },
  header: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    marginBottom: spacing.lg,
  },
  indicator: {
    backgroundColor: colors.accent.wine,
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.xs,
    borderRadius: borderRadius.full,
  },
  indicatorText: {
    ...typography.label,
    color: colors.text.primary,
    fontSize: 12,
  },
  decorLine: {
    flex: 1,
    height: 1,
    backgroundColor: colors.accent.gold,
    opacity: 0.3,
    marginRight: spacing.md,
  },
  content: {
    minHeight: 100,
  },
  continueButton: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: spacing.xl,
    paddingVertical: spacing.md,
    borderTopWidth: 1,
    borderTopColor: colors.alpha[10],
  },
  continueButtonText: {
    ...typography.button,
    color: colors.accent.gold,
    marginLeft: spacing.sm,
  },
  arrow: {
    color: colors.accent.gold,
    fontSize: 18,
  },
  minimalButton: {
    alignSelf: 'center',
    marginTop: spacing['2xl'],
    paddingVertical: spacing.md,
    paddingHorizontal: spacing['2xl'],
    borderWidth: 1,
    borderColor: colors.accent.gold,
    borderRadius: borderRadius.full,
  },
  minimalButtonText: {
    ...typography.button,
    color: colors.accent.gold,
  },
});

export default DrCharifMessage;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/DrCharifScene.tsx
--------------------------------------------------------------------------------

/**
 * ◊°◊¶◊†◊™ ◊ì"◊® ◊ó◊®◊ô◊£ ◊î◊û◊ú◊ê◊î
 * ◊û◊©◊ú◊ë ◊ê◊ï◊ï◊ò◊ê◊® + ◊ì◊ô◊ë◊ï◊® + ◊®◊ß◊¢ + ◊†◊ô◊ß◊ï◊ì ◊©◊ó◊ß◊†◊ô◊ù
 */

import React, { useState, useCallback } from 'react';
import { View, StyleSheet } from 'react-native';
import * as Haptics from 'expo-haptics';

import { ScreenBackground } from '../common/ScreenBackground';
import { PlayerScoreCard } from '../common/PlayerScoreCard';
import { GoldButton } from '../common/GoldButton';
import { DrCharifAvatar, DrCharifExpression } from './DrCharifAvatar';
import { DrCharifSpeech } from './DrCharifSpeech';
import { colors, spacing } from '../../theme';

interface Player {
  name: string;
  score: number;
  avatar?: string;
}

interface SpeechLine {
  text: string;
  pauseAfter?: number;
  expression?: DrCharifExpression;
}

interface Props {
  lines: SpeechLine[];
  player1: Player;
  player2: Player;
  activePlayer?: 1 | 2;
  onComplete?: () => void;
  showContinueButton?: boolean;
  continueButtonText?: string;
  onContinue?: () => void;
}

export const DrCharifScene: React.FC<Props> = ({
  lines,
  player1,
  player2,
  activePlayer,
  onComplete,
  showContinueButton = false,
  continueButtonText = '◊î◊û◊©◊ö',
  onContinue,
}) => {
  const [isSpeaking, setIsSpeaking] = useState(true);
  const [currentExpression, setCurrentExpression] = useState<DrCharifExpression>('listening');
  const [speechComplete, setSpeechComplete] = useState(false);

  const handleLineStart = useCallback((index: number) => {
    setIsSpeaking(true);
    const line = lines[index];
    setCurrentExpression(line.expression || 'speaking');
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  }, [lines]);

  const handleLineComplete = useCallback((index: number) => {
    setIsSpeaking(false);
    setCurrentExpression('listening');
  }, []);

  const handleAllComplete = useCallback(() => {
    setIsSpeaking(false);
    setCurrentExpression('approving');
    setSpeechComplete(true);
    onComplete?.();
  }, [onComplete]);

  const handleContinue = useCallback(async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onContinue?.();
  }, [onContinue]);

  return (
    <ScreenBackground variant="glow">
      <View style={styles.container}>
        {/* Player scores header */}
        <View style={styles.playersHeader}>
          <PlayerScoreCard
            name={player1.name}
            score={player1.score}
            avatar={player1.avatar}
            isActive={activePlayer === 1}
            position="left"
          />
          <PlayerScoreCard
            name={player2.name}
            score={player2.score}
            avatar={player2.avatar}
            isActive={activePlayer === 2}
            position="right"
          />
        </View>

        {/* Dr. Charif section */}
        <View style={styles.drCharifSection}>
          <DrCharifAvatar
            expression={currentExpression}
            isSpeaking={isSpeaking}
            size={100}
          />
        </View>

        {/* Speech bubble */}
        <View style={styles.speechSection}>
          <DrCharifSpeech
            lines={lines}
            onLineStart={handleLineStart}
            onLineComplete={handleLineComplete}
            onAllComplete={handleAllComplete}
          />
        </View>

        {/* Continue button */}
        {showContinueButton && speechComplete && (
          <View style={styles.buttonSection}>
            <GoldButton
              title={continueButtonText}
              onPress={handleContinue}
              variant="primary"
              size="large"
            />
          </View>
        )}
      </View>
    </ScreenBackground>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 60,
  },
  playersHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.lg,
    gap: spacing.md,
  },
  drCharifSection: {
    alignItems: 'center',
    marginTop: spacing.xxl,
    marginBottom: spacing.lg,
  },
  speechSection: {
    flex: 1,
    justifyContent: 'center',
  },
  buttonSection: {
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing.xxl,
    alignItems: 'center',
  },
});

export default DrCharifScene;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/DrCharifSpeech.tsx
--------------------------------------------------------------------------------

/**
 * ◊ë◊ï◊¢◊™ ◊ì◊ô◊ë◊ï◊® ◊©◊ú ◊ì"◊® ◊ó◊®◊ô◊£
 * ◊ò◊ß◊°◊ò ◊©◊û◊™◊ó◊ú◊£ (◊ú◊ê ◊†◊¢◊®◊ù) ◊¢◊ù ◊ê◊§◊ß◊ò ◊î◊ß◊ú◊ì◊î
 */

import React, { useState, useEffect, useCallback } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
} from 'react-native-reanimated';

import { GlassCard } from '../common/GlassCard';
import { TypewriterText } from '../common/TypewriterText';
import { colors } from '../../theme';

interface SpeechLine {
  text: string;
  pauseAfter?: number; // ms to wait after this line
}

interface Props {
  lines: SpeechLine[];
  onLineStart?: (index: number) => void;
  onLineComplete?: (index: number) => void;
  onAllComplete?: () => void;
  typingSpeed?: number;
}

export const DrCharifSpeech: React.FC<Props> = ({
  lines,
  onLineStart,
  onLineComplete,
  onAllComplete,
  typingSpeed = 35,
}) => {
  const [currentLineIndex, setCurrentLineIndex] = useState(0);
  const [key, setKey] = useState(0); // Force re-render of TypewriterText

  const opacity = useSharedValue(1);
  const translateY = useSharedValue(0);

  const currentLine = lines[currentLineIndex];

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ translateY: translateY.value }],
  }));

  const goToNextLine = useCallback(() => {
    if (currentLineIndex < lines.length - 1) {
      // Animate out
      opacity.value = withTiming(0, { duration: 200 });
      translateY.value = withTiming(-15, { duration: 200 });

      setTimeout(() => {
        setCurrentLineIndex((prev) => prev + 1);
        setKey((prev) => prev + 1);

        // Animate in
        translateY.value = 15;
        opacity.value = withTiming(1, { duration: 300 });
        translateY.value = withTiming(0, { duration: 300, easing: Easing.out(Easing.ease) });
      }, 200);
    } else {
      onAllComplete?.();
    }
  }, [currentLineIndex, lines.length, onAllComplete]);

  const handleLineComplete = useCallback(() => {
    onLineComplete?.(currentLineIndex);

    const pauseDuration = currentLine?.pauseAfter ?? 1500;
    setTimeout(goToNextLine, pauseDuration);
  }, [currentLineIndex, currentLine, goToNextLine, onLineComplete]);

  const handleLineStart = useCallback(() => {
    onLineStart?.(currentLineIndex);
  }, [currentLineIndex, onLineStart]);

  if (!currentLine) return null;

  return (
    <GlassCard intensity="medium" style={styles.container}>
      <Text style={styles.label}>◊ì◊¥◊® ◊ó◊®◊ô◊£:</Text>

      <Animated.View style={[styles.textContainer, animatedStyle]}>
        <TypewriterText
          key={key}
          text={currentLine.text}
          speed={typingSpeed}
          style={styles.speechText}
          onStart={handleLineStart}
          onComplete={handleLineComplete}
          showCursor={true}
        />
      </Animated.View>
    </GlassCard>
  );
};

const styles = StyleSheet.create({
  container: {
    marginHorizontal: 20,
    minHeight: 140,
  },
  label: {
    fontFamily: 'Heebo-Medium',
    fontSize: 14,
    color: colors.accent.gold,
    letterSpacing: 1,
    marginBottom: 12,
    textAlign: 'right',
  },
  textContainer: {
    minHeight: 80,
    justifyContent: 'center',
  },
  speechText: {
    fontFamily: 'Heebo-Light',
    fontSize: 24,
    lineHeight: 40,
    color: colors.text.primary,
    textAlign: 'center',
  },
});

export default DrCharifSpeech;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/DrCharifText.tsx
--------------------------------------------------------------------------------

/**
 * ◊ò◊ß◊°◊ò ◊ì"◊® ◊ó◊®◊ô◊£ - ◊©◊ï◊®◊î ◊ê◊ó◊™ ◊ë◊õ◊ú ◊§◊¢◊ù ◊¢◊ù ◊ê◊§◊ß◊ò ◊î◊ß◊ú◊ì◊î
 *
 * ◊î◊¢◊ô◊ß◊®◊ï◊ü: ◊õ◊ú ◊û◊©◊§◊ò ◊û◊ó◊ú◊ô◊£ ◊ê◊™ ◊î◊ß◊ï◊ì◊ù. ◊ú◊ê ◊†◊¢◊®◊ù.
 */

import React, { useState, useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated, Easing } from 'react-native';
import { colors } from '@/theme/colors';

interface TextLine {
  text: string;
  delay: number;
}

interface Props {
  lines: TextLine[];
  onLineStart?: (index: number) => void;
  onLineComplete?: (index: number) => void;
  onAllComplete?: () => void;
  typingSpeed?: number;
}

export const DrCharifText: React.FC<Props> = ({
  lines,
  onLineStart,
  onLineComplete,
  onAllComplete,
  typingSpeed = 35,
}) => {
  const [currentLineIndex, setCurrentLineIndex] = useState(0);
  const [displayedText, setDisplayedText] = useState('');
  const [isTyping, setIsTyping] = useState(false);

  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(20)).current;

  const currentLine = lines[currentLineIndex];

  useEffect(() => {
    if (!currentLine) return;

    setIsTyping(true);
    setDisplayedText('');
    onLineStart?.(currentLineIndex);

    fadeAnim.setValue(0);
    slideAnim.setValue(15);
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 300,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      }),
    ]).start();

    let charIndex = 0;
    const text = currentLine.text;

    const typeInterval = setInterval(() => {
      if (charIndex < text.length) {
        setDisplayedText(text.substring(0, charIndex + 1));
        charIndex++;
      } else {
        clearInterval(typeInterval);
        setIsTyping(false);
        onLineComplete?.(currentLineIndex);

        if (currentLineIndex < lines.length - 1) {
          setTimeout(() => {
            Animated.parallel([
              Animated.timing(fadeAnim, {
                toValue: 0,
                duration: 200,
                useNativeDriver: true,
              }),
              Animated.timing(slideAnim, {
                toValue: -15,
                duration: 200,
                useNativeDriver: true,
              }),
            ]).start(() => {
              setCurrentLineIndex(prev => prev + 1);
            });
          }, currentLine.delay);
        } else {
          setTimeout(() => {
            onAllComplete?.();
          }, currentLine.delay);
        }
      }
    }, typingSpeed);

    return () => clearInterval(typeInterval);
  }, [currentLineIndex, currentLine]);

  if (!currentLine) return null;

  return (
    <View style={styles.container}>
      <Animated.View
        style={[
          styles.textContainer,
          {
            opacity: fadeAnim,
            transform: [{ translateY: slideAnim }],
          },
        ]}
      >
        <Text style={styles.text}>
          {displayedText}
          {isTyping && <Text style={styles.cursor}>|</Text>}
        </Text>
      </Animated.View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    minHeight: 100,
    justifyContent: 'center',
    paddingHorizontal: 24,
  },
  textContainer: {
    alignItems: 'center',
  },
  text: {
    fontFamily: 'Heebo-Light',
    fontSize: 22,
    lineHeight: 36,
    color: colors.text.primary,
    textAlign: 'center',
  },
  cursor: {
    color: colors.accent.gold,
    fontWeight: '100',
  },
});

export default DrCharifText;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/TypewriterText.tsx
--------------------------------------------------------------------------------

/**
 * TypewriterText Component
 *
 * ◊û◊¶◊ô◊í ◊ò◊ß◊°◊ò ◊©◊ú ◊ì"◊® ◊ó◊®◊ô◊£ ◊ë◊ê◊§◊ß◊ò ◊û◊õ◊ï◊†◊™ ◊õ◊™◊ô◊ë◊î
 * ◊õ◊ú ◊û◊ô◊ú◊î ◊û◊ï◊§◊ô◊¢◊î ◊ë◊†◊§◊®◊ì ◊¢◊ù ◊§◊ê◊ï◊ñ◊ï◊™ ◊û◊õ◊ï◊ï◊†◊ï◊™
 */

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  ViewStyle,
  TextStyle,
} from 'react-native';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing } from '@/theme/spacing';

interface TypewriterLine {
  text: string;
  delay: number; // delay after this line in ms
}

interface TypewriterTextProps {
  lines: TypewriterLine[];
  onComplete?: () => void;
  speed?: 'slow' | 'normal' | 'fast';
  style?: ViewStyle;
  textStyle?: TextStyle;
  autoStart?: boolean;
}

const SPEED_MAP = {
  slow: 80,
  normal: 50,
  fast: 30,
};

export const TypewriterText: React.FC<TypewriterTextProps> = ({
  lines,
  onComplete,
  speed = 'normal',
  style,
  textStyle,
  autoStart = true,
}) => {
  const [displayedLines, setDisplayedLines] = useState<string[]>([]);
  const [currentLineIndex, setCurrentLineIndex] = useState(0);
  const [currentCharIndex, setCurrentCharIndex] = useState(0);
  const [isTyping, setIsTyping] = useState(false);
  const [isComplete, setIsComplete] = useState(false);

  const fadeAnims = useRef<Animated.Value[]>([]).current;
  const charSpeed = SPEED_MAP[speed];

  // Initialize fade animations for each line
  useEffect(() => {
    lines.forEach((_, index) => {
      if (!fadeAnims[index]) {
        fadeAnims[index] = new Animated.Value(0);
      }
    });
  }, [lines, fadeAnims]);

  // Start typing when autoStart is true
  useEffect(() => {
    if (autoStart && !isTyping && !isComplete && lines.length > 0) {
      setIsTyping(true);
    }
  }, [autoStart, isTyping, isComplete, lines.length]);

  // Typing effect
  useEffect(() => {
    if (!isTyping || isComplete) return;

    const currentLine = lines[currentLineIndex];
    if (!currentLine) {
      setIsComplete(true);
      setIsTyping(false);
      onComplete?.();
      return;
    }

    // Start fade in animation for new line
    if (currentCharIndex === 0 && fadeAnims[currentLineIndex]) {
      Animated.timing(fadeAnims[currentLineIndex], {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    }

    // Type next character
    if (currentCharIndex < currentLine.text.length) {
      const timeout = setTimeout(() => {
        setDisplayedLines((prev) => {
          const newLines = [...prev];
          newLines[currentLineIndex] = currentLine.text.substring(
            0,
            currentCharIndex + 1
          );
          return newLines;
        });
        setCurrentCharIndex((prev) => prev + 1);
      }, charSpeed);

      return () => clearTimeout(timeout);
    }

    // Line complete, wait for delay then move to next line
    if (currentCharIndex >= currentLine.text.length) {
      const timeout = setTimeout(() => {
        if (currentLineIndex < lines.length - 1) {
          setCurrentLineIndex((prev) => prev + 1);
          setCurrentCharIndex(0);
        } else {
          setIsComplete(true);
          setIsTyping(false);
          onComplete?.();
        }
      }, currentLine.delay);

      return () => clearTimeout(timeout);
    }
  }, [
    isTyping,
    isComplete,
    currentLineIndex,
    currentCharIndex,
    lines,
    charSpeed,
    fadeAnims,
    onComplete,
  ]);

  // Manual start function
  const start = useCallback(() => {
    if (!isTyping && !isComplete) {
      setIsTyping(true);
    }
  }, [isTyping, isComplete]);

  // Reset function
  const reset = useCallback(() => {
    setDisplayedLines([]);
    setCurrentLineIndex(0);
    setCurrentCharIndex(0);
    setIsTyping(false);
    setIsComplete(false);
    fadeAnims.forEach((anim) => anim.setValue(0));
  }, [fadeAnims]);

  return (
    <View style={[styles.container, style]}>
      {displayedLines.map((line, index) => (
        <Animated.View
          key={index}
          style={[
            styles.lineContainer,
            {
              opacity: fadeAnims[index] || 1,
            },
          ]}
        >
          <Text style={[styles.text, textStyle]}>
            {line}
            {index === currentLineIndex && isTyping && (
              <Text style={styles.cursor}>|</Text>
            )}
          </Text>
        </Animated.View>
      ))}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    paddingHorizontal: spacing.lg,
  },
  lineContainer: {
    marginBottom: spacing.md,
  },
  text: {
    ...typography.quote,
    color: colors.text.primary,
    textAlign: 'right',
    writingDirection: 'rtl',
  },
  cursor: {
    color: colors.accent.gold,
    opacity: 0.7,
  },
});

export default TypewriterText;

--------------------------------------------------------------------------------
FILE: src/components/drCharif/index.ts
--------------------------------------------------------------------------------

export { TypewriterText } from './TypewriterText';
export { DrCharifMessage } from './DrCharifMessage';
export { DrCharifAvatar } from './DrCharifAvatar';
export { DrCharifText } from './DrCharifText';
export { DrCharifExperience } from './DrCharifExperience';
export { DrCharifSpeech } from './DrCharifSpeech';
export { DrCharifScene } from './DrCharifScene';
export type { DrCharifExpression } from './DrCharifAvatar';

--------------------------------------------------------------------------------
FILE: src/components/index.ts
--------------------------------------------------------------------------------

export * from './common';
export * from './drCharif';

--------------------------------------------------------------------------------
FILE: src/data/drCharifTexts.ts
--------------------------------------------------------------------------------

/**
 * Dr. Charif Texts - All dialogue and narration
 *
 * ◊ì"◊® ◊ó◊®◊ô◊£ - ◊§◊°◊ô◊õ◊ï◊ú◊ï◊í ◊ñ◊ï◊í◊ô ◊¢◊ù 30 ◊©◊†◊î ◊†◊ô◊°◊ô◊ï◊ü
 * ◊û◊®◊ô◊®, ◊¢◊ï◊ß◊¶◊†◊ô, ◊¶◊ô◊†◊ô - ◊ê◊ë◊ú ◊¢◊ù ◊ó◊ï◊õ◊û◊™ ◊ó◊ô◊ô◊ù ◊û◊ó◊ï◊°◊§◊°◊™
 */

export interface TextLine {
  text: string;
  delay: number; // delay in ms after this line
}

export interface DrCharifText {
  id: string;
  context: string;
  lines: TextLine[];
}

// ◊û◊°◊ö ◊î◊§◊™◊ô◊ó◊î - "◊î◊§◊®◊ï◊ñ◊ì◊ï◊®"
export const splashTexts: DrCharifText = {
  id: 'splash',
  context: 'opening',
  lines: [
    { text: '◊ò◊ï◊ë.', delay: 1000 },
    { text: '◊î◊í◊¢◊™◊ù.', delay: 1000 },
    { text: '◊ú◊ê ◊û◊©◊†◊î ◊û◊î ◊î◊°◊ô◊ë◊î.', delay: 600 },
    { text: '◊ú◊ê ◊û◊©◊†◊î ◊û◊î ◊ê◊û◊®◊™◊ù ◊ú◊¢◊¶◊û◊õ◊ù ◊ë◊ì◊®◊ö ◊ú◊§◊î.', delay: 1000 },
    { text: '◊û◊©◊î◊ï ◊î◊ë◊ô◊ê ◊ê◊™◊õ◊ù.', delay: 800 },
    { text: '◊°◊ß◊®◊†◊ï◊™. ◊©◊¢◊û◊ï◊ù. ◊§◊ó◊ì. ◊™◊ß◊ï◊ï◊î.', delay: 600 },
    { text: '◊ê◊ï◊ú◊ô ◊î◊õ◊ú ◊ë◊ô◊ó◊ì.', delay: 1500 },
    { text: '◊ê◊†◊ô ◊ú◊ê ◊î◊ï◊ú◊ö ◊ú◊°◊§◊® ◊ú◊õ◊ù ◊û◊î ◊û◊ó◊õ◊î ◊ú◊õ◊ù.', delay: 800 },
    { text: '◊ê◊†◊ô ◊®◊ß ◊î◊ï◊ú◊ö ◊ú◊î◊í◊ô◊ì ◊©◊ñ◊ï◊í◊ï◊™ ◊©◊†◊õ◊†◊°◊ô◊ù ◊ú◊§◊î - ◊ô◊ï◊¶◊ê◊ô◊ù ◊ê◊ó◊®◊™.', delay: 1200 },
    { text: '◊ú◊ê ◊ë◊ò◊ï◊ó ◊ô◊ï◊™◊® ◊ò◊ï◊ë◊ô◊ù.', delay: 600 },
    { text: '◊ê◊ë◊ú ◊ë◊ò◊ï◊ó ◊ô◊ï◊™◊® ◊ê◊û◊ô◊™◊ô◊ô◊ù.', delay: 1500 },
    { text: '◊ê◊ñ ◊ê◊ù ◊ê◊™◊ù ◊û◊ï◊õ◊†◊ô◊ù ◊ú◊î◊°◊ô◊® ◊ß◊¶◊™ ◊©◊õ◊ë◊ï◊™ -', delay: 800 },
    { text: '◊ë◊ï◊ê◊ï ◊†◊™◊ó◊ô◊ú.', delay: 0 },
  ],
};

// ◊î◊ñ◊†◊™ ◊©◊û◊ï◊™
export const nameEntryTexts = {
  askFirstName: {
    id: 'ask_first_name',
    context: 'onboarding',
    lines: [
      { text: '◊ß◊ï◊ì◊ù ◊õ◊ú, ◊ê◊ô◊ö ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ö?', delay: 0 },
    ],
  },
  askSecondName: {
    id: 'ask_second_name',
    context: 'onboarding',
    lines: [
      { text: '◊ô◊§◊î. ◊ï◊û◊ô ◊ë◊ê ◊ê◊ô◊™◊ö ◊î◊¢◊®◊ë?', delay: 0 },
    ],
  },
  namesConfirm: (name1: string, name2: string): DrCharifText => ({
    id: 'names_confirm',
    context: 'onboarding',
    lines: [
      { text: `${name1} ◊ï${name2}.`, delay: 800 },
      { text: '◊†◊©◊û◊¢ ◊õ◊û◊ï ◊î◊™◊ó◊ú◊î ◊©◊ú ◊û◊©◊î◊ï.', delay: 600 },
      { text: '◊ê◊ï ◊ê◊û◊¶◊¢.', delay: 800 },
      { text: '◊ë◊ï◊ê◊ï ◊†◊í◊ú◊î.', delay: 0 },
    ],
  }),
};

// ◊§◊™◊ô◊ó◊™ ◊û◊©◊ó◊ß
export const gameIntroText: DrCharifText = {
  id: 'game_intro',
  context: 'game_start',
  lines: [
    { text: '◊†◊ï, ◊î◊™◊ô◊ô◊©◊ë◊™◊ù?', delay: 600 },
    { text: '◊ô◊© ◊ô◊ô◊ü? ◊ò◊ï◊ë.', delay: 800 },
    { text: '◊ê◊†◊ô ◊ó◊®◊ô◊£.', delay: 600 },
    { text: '◊©◊ú◊ï◊©◊ô◊ù ◊©◊†◊î ◊ê◊†◊ô ◊ô◊ï◊©◊ë ◊û◊ï◊ú ◊ñ◊ï◊í◊ï◊™ ◊©◊ë◊ê◊ô◊ù ◊ê◊ú◊ô◊ô ◊ï◊ê◊ï◊û◊®◊ô◊ù "◊ê◊†◊ó◊†◊ï ◊ë◊°◊ì◊®, ◊®◊ß ◊®◊¶◊ô◊†◊ï ◊ú◊ó◊ñ◊ß ◊ê◊™ ◊î◊ß◊©◊®".', delay: 1200 },
    { text: '◊©◊ß◊®.', delay: 800 },
    { text: '◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊ë◊ê ◊ú◊ó◊ñ◊ß ◊û◊©◊î◊ï ◊©◊¢◊ï◊ë◊ì.', delay: 800 },
    { text: '◊ê◊™◊ù ◊§◊î ◊õ◊ô ◊û◊©◊î◊ï ◊û◊í◊®◊ì.', delay: 600 },
    { text: '◊ï◊ñ◊î ◊ë◊°◊ì◊® ◊í◊û◊ï◊®.', delay: 800 },
    { text: '◊î◊í◊ô◊®◊ï◊ì ◊î◊ñ◊î ◊©◊ï◊ï◊î ◊ñ◊î◊ë.', delay: 600 },
    { text: '◊ë◊ï◊ê◊ï ◊†◊í◊®◊ì.', delay: 0 },
  ],
};

// ◊§◊™◊ô◊ó◊ï◊™ ◊©◊ú◊ë◊ô◊ù
export const stageIntros: Record<number, DrCharifText> = {
  1: {
    id: 'stage_1_intro',
    context: 'stage_intro',
    lines: [
      { text: '◊©◊ú◊ë ◊®◊ê◊©◊ï◊ü.', delay: 800 },
      { text: '"◊®◊í◊¢ ◊ú◊§◊†◊ô ◊©◊†◊§◊í◊©◊†◊ï"', delay: 1000 },
      { text: '◊†◊ó◊ñ◊ï◊® ◊ê◊ó◊ï◊®◊î.', delay: 600 },
      { text: '◊ú◊§◊†◊ô ◊©◊î◊õ◊®◊™◊ù.', delay: 600 },
      { text: '◊ú◊§◊†◊ô ◊©◊î◊°◊™◊ë◊õ◊™◊ù.', delay: 800 },
      { text: '◊û◊ô ◊î◊ô◊ô◊™◊ù ◊ê◊ñ?', delay: 600 },
      { text: '◊ï◊û◊î ◊†◊©◊ê◊® ◊û◊ñ◊î?', delay: 0 },
    ],
  },
  2: {
    id: 'stage_2_intro',
    context: 'stage_intro',
    lines: [
      { text: '◊©◊ú◊ë ◊©◊†◊ô.', delay: 800 },
      { text: '"◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™"', delay: 1000 },
      { text: '◊¢◊õ◊©◊ô◊ï ◊†◊™◊ó◊û◊ù.', delay: 600 },
      { text: '◊û◊©◊ô◊û◊ï◊™ ◊ß◊ò◊†◊ï◊™. ◊©◊ê◊ú◊ï◊™ ◊ß◊ú◊ï◊™.', delay: 600 },
      { text: '◊õ◊ú◊ï◊ù ◊©◊ô◊õ◊ï◊ú ◊ú◊§◊í◊ï◊¢.', delay: 800 },
      { text: '◊¢◊ì◊ô◊ô◊ü.', delay: 0 },
    ],
  },
  3: {
    id: 'stage_3_intro',
    context: 'stage_intro',
    lines: [
      { text: '◊©◊ú◊ë ◊©◊ú◊ô◊©◊ô.', delay: 800 },
      { text: '"◊ì◊ë◊®◊ô◊ù ◊©◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù ◊ë◊ß◊ï◊ú"', delay: 1000 },
      { text: '◊§◊î ◊û◊™◊ó◊ô◊ú◊ô◊ù ◊ú◊í◊¢◊™ ◊ë◊û◊ß◊ï◊û◊ï◊™ ◊î◊®◊õ◊ô◊ù.', delay: 800 },
      { text: '◊î◊ì◊ë◊®◊ô◊ù ◊©◊ê◊™◊ù ◊ó◊ï◊©◊ë◊ô◊ù ◊ï◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù.', delay: 600 },
      { text: '◊î◊ì◊ë◊®◊ô◊ù ◊©◊ê◊™◊ù ◊û◊®◊í◊ô◊©◊ô◊ù ◊ï◊û◊¢◊ì◊ô◊§◊ô◊ù ◊ú◊î◊™◊¢◊ú◊ù.', delay: 800 },
      { text: '◊î◊¢◊®◊ë? ◊ê◊ï◊û◊®◊ô◊ù ◊ê◊ï◊™◊ù.', delay: 0 },
    ],
  },
  4: {
    id: 'stage_4_intro',
    context: 'stage_intro',
    lines: [
      { text: '◊©◊ú◊ë ◊®◊ë◊ô◊¢◊ô.', delay: 800 },
      { text: '"◊û◊ú◊ó◊û◊™ ◊î◊í◊ô◊®◊°◊ê◊ï◊™"', delay: 1000 },
      { text: '◊õ◊ú ◊°◊ô◊§◊ï◊® ◊ô◊© ◊ú◊ï ◊©◊™◊ô ◊í◊ô◊®◊°◊ê◊ï◊™.', delay: 600 },
      { text: '◊©◊ú◊ö ◊ï◊©◊ú◊î.', delay: 600 },
      { text: '◊ê◊ï ◊©◊ú◊ö ◊ï◊©◊ú◊ï.', delay: 600 },
      { text: '◊¢◊õ◊©◊ô◊ï ◊†◊ë◊ì◊ï◊ß ◊õ◊û◊î ◊î◊ü ◊®◊ó◊ï◊ß◊ï◊™ ◊ñ◊ï ◊û◊ñ◊ï.', delay: 0 },
    ],
  },
  5: {
    id: 'stage_5_intro',
    context: 'stage_intro',
    lines: [
      { text: '◊©◊ú◊ë ◊ó◊û◊ô◊©◊ô.', delay: 800 },
      { text: '"◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î"', delay: 1000 },
      { text: '◊¢◊õ◊©◊ô◊ï ◊†◊õ◊†◊°◊ô◊ù ◊ú◊ò◊®◊ô◊ò◊ï◊®◊ô◊î ◊ê◊ó◊®◊™.', delay: 800 },
      { text: '◊ô◊© ◊ñ◊ï◊í◊ï◊™ ◊©◊î◊°◊ß◊° ◊©◊ú◊î◊ù ◊†◊í◊û◊® ◊ú◊ê ◊õ◊ô ◊î◊ù ◊ú◊ê ◊®◊ï◊¶◊ô◊ù ◊ê◊ó◊ì ◊ê◊™ ◊î◊©◊†◊ô◊ô◊î.', delay: 800 },
      { text: '◊î◊ï◊ê ◊†◊í◊û◊® ◊õ◊ô ◊©◊†◊ô◊î◊ù ◊û◊ó◊õ◊ô◊ù ◊©◊î◊©◊†◊ô ◊ô◊™◊ó◊ô◊ú.', delay: 600 },
      { text: '◊©◊†◊ô◊ù ◊©◊ú "◊ú◊û◊î ◊ê◊†◊ô ◊™◊û◊ô◊ì ◊¶◊®◊ô◊ö ◊ú◊î◊ô◊ï◊™ ◊ñ◊î ◊©..."', delay: 800 },
      { text: '◊¢◊ì ◊©◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊û◊™◊ó◊ô◊ú ◊õ◊ú◊ï◊ù.', delay: 800 },
      { text: '◊î◊¢◊®◊ë? ◊ê◊†◊ô ◊û◊™◊ó◊ô◊ú ◊ë◊©◊ë◊ô◊ú◊õ◊ù.', delay: 600 },
      { text: '◊¢◊ú ◊û◊î ◊™◊û◊©◊ô◊õ◊ï - ◊ñ◊î ◊¢◊ú◊ô◊õ◊ù.', delay: 0 },
    ],
  },
};

// ◊ë◊ó◊ô◊®◊™ ◊®◊û◊™ ◊¢◊ï◊¶◊û◊î ◊ú◊©◊ú◊ë 5
export const intensitySelectionText: DrCharifText = {
  id: 'intensity_selection',
  context: 'stage_5',
  lines: [
    { text: '◊ú◊§◊†◊ô ◊©◊†◊™◊ó◊ô◊ú, ◊¶◊®◊ô◊ö ◊ú◊î◊ó◊ú◊ô◊ò ◊ë◊ô◊ó◊ì.', delay: 600 },
    { text: '◊õ◊û◊î ◊®◊ó◊ï◊ß ◊ê◊™◊ù ◊û◊ï◊õ◊†◊ô◊ù ◊ú◊ú◊õ◊™ ◊î◊¢◊®◊ë?', delay: 800 },
    { text: '◊©◊ú◊ï◊© ◊®◊û◊ï◊™:', delay: 600 },
    { text: '◊®◊õ◊î - ◊†◊í◊ô◊¢◊ï◊™, ◊ú◊ó◊ô◊©◊ï◊™, ◊†◊©◊ô◊ß◊ï◊™.', delay: 600 },
    { text: '◊ë◊ô◊†◊ï◊†◊ô◊™ - ◊ì◊ë◊®◊ô◊ù ◊ô◊ï◊™◊® ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ô◊ù, ◊ê◊ë◊ú ◊ú◊ê ◊î◊õ◊ú.', delay: 800 },
    { text: '◊ó◊®◊ô◊§◊î - ◊î◊õ◊ú ◊¢◊ú ◊î◊©◊ï◊ú◊ó◊ü.', delay: 800 },
    { text: '◊ê◊ô◊ü ◊™◊©◊ï◊ë◊î ◊†◊õ◊ï◊†◊î.', delay: 600 },
    { text: '◊ô◊© ◊®◊ß ◊™◊©◊ï◊ë◊î ◊©◊ú◊õ◊ù.', delay: 0 },
  ],
};

export const intensityChoiceTexts: Record<string, DrCharifText> = {
  soft: {
    id: 'intensity_soft',
    context: 'stage_5',
    lines: [
      { text: '◊®◊û◊î ◊®◊õ◊î.', delay: 600 },
      { text: '◊ô◊© ◊ú◊ô ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î ◊û◊¢◊†◊ô◊ô◊†◊™ -', delay: 600 },
      { text: '80% ◊û◊î◊ñ◊ï◊í◊ï◊™ ◊û◊™◊ó◊ô◊ú◊ô◊ù ◊©◊ù.', delay: 600 },
      { text: '60% ◊û◊™◊ó◊®◊ò◊ô◊ù ◊ë◊ê◊û◊¶◊¢ ◊î◊¢◊®◊ë.', delay: 800 },
      { text: '◊ê◊ë◊ú ◊ê◊™◊ù ◊ú◊ê ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î.', delay: 600 },
      { text: '◊ê◊™◊ù ◊©◊†◊ô ◊ë◊†◊ô ◊ê◊ì◊ù ◊¢◊ù ◊î◊®◊í◊ú◊ô◊ù ◊ï◊§◊ó◊ì◊ô◊ù ◊ï◊™◊ß◊ï◊ï◊™ ◊û◊©◊ú◊õ◊ù.', delay: 800 },
      { text: '◊ê◊ñ ◊ß◊ó◊ï ◊ê◊™ ◊î◊®◊õ◊î ◊î◊ñ◊ï ◊ï◊™◊î◊§◊õ◊ï ◊ê◊ï◊™◊î ◊ú◊û◊©◊î◊ï ◊©◊ú◊õ◊ù.', delay: 0 },
    ],
  },
  medium: {
    id: 'intensity_medium',
    context: 'stage_5',
    lines: [
      { text: '◊®◊û◊î ◊ë◊ô◊†◊ï◊†◊ô◊™.', delay: 600 },
      { text: '◊ë◊ó◊ô◊®◊î ◊©◊ú ◊ê◊†◊©◊ô◊ù ◊©◊ô◊ï◊ì◊¢◊ô◊ù ◊û◊î ◊î◊ù ◊®◊ï◊¶◊ô◊ù.', delay: 600 },
      { text: '◊ê◊ë◊ú ◊í◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊û◊î ◊î◊ù ◊ú◊ê ◊û◊ï◊õ◊†◊ô◊ù ◊ú◊¢◊©◊ï◊™.', delay: 800 },
      { text: '◊ñ◊î ◊ë◊°◊ì◊®.', delay: 600 },
      { text: '◊í◊ë◊ï◊ú◊ï◊™ ◊î◊ù ◊ú◊ê ◊ó◊ï◊ú◊©◊î.', delay: 600 },
      { text: '◊î◊ù ◊°◊ô◊û◊ü ◊©◊ê◊™◊ù ◊û◊õ◊ô◊®◊ô◊ù ◊ê◊™ ◊¢◊¶◊û◊õ◊ù.', delay: 0 },
    ],
  },
  spicy: {
    id: 'intensity_spicy',
    context: 'stage_5',
    lines: [
      { text: '◊®◊û◊î ◊ó◊®◊ô◊§◊î.', delay: 600 },
      { text: '◊ï◊ï◊ê◊ï.', delay: 800 },
      { text: '◊ê◊ï◊ß◊ô◊ô.', delay: 600 },
      { text: '◊ê◊™◊ù ◊ú◊ê ◊û◊§◊ó◊ì◊ô◊ù, ◊ê◊î?', delay: 800 },
      { text: '◊ò◊ï◊ë. ◊ê◊†◊ô ◊ê◊ï◊î◊ë ◊õ◊ê◊ú◊î.', delay: 600 },
      { text: '◊®◊ß ◊™◊ñ◊õ◊®◊ï -', delay: 600 },
      { text: '"◊ú◊ê" ◊™◊û◊ô◊ì ◊ê◊ï◊§◊¶◊ô◊î. ◊í◊ù ◊ë◊ê◊û◊¶◊¢.', delay: 600 },
      { text: '◊¢◊õ◊©◊ô◊ï ◊ë◊ï◊ê◊ï ◊†◊®◊ê◊î ◊û◊î ◊ê◊™◊ù ◊¢◊©◊ï◊ô◊ô◊ù.', delay: 0 },
    ],
  },
};

// ◊ò◊ß◊°◊ò◊ô◊ù ◊ú◊§◊†◊ô ◊©◊ê◊ú◊ï◊™
export const beforeQuestionTexts: DrCharifText[] = [
  {
    id: 'before_q_1',
    context: 'before_question',
    lines: [
      { text: '◊î◊©◊ê◊ú◊î ◊î◊ñ◊ï ◊î◊ï◊ú◊õ◊™ ◊ú◊©◊ë◊™ ◊ë◊ê◊ï◊ï◊ô◊® ◊õ◊û◊î ◊©◊†◊ô◊ï◊™ ◊ê◊ó◊®◊ô ◊©◊™◊ß◊®◊ê◊ï ◊ê◊ï◊™◊î.', delay: 800 },
      { text: '◊™◊®◊í◊ô◊©◊ï ◊ì◊ó◊£ ◊ú◊¢◊†◊ï◊™ ◊û◊î◊® ◊õ◊ì◊ô ◊ú◊°◊ô◊ô◊ù ◊ê◊™ ◊î◊ê◊ô-◊†◊ï◊ó◊ï◊™.', delay: 600 },
      { text: '◊ê◊ú.', delay: 800 },
      { text: '◊î◊ê◊ô-◊†◊ï◊ó◊ï◊™ ◊î◊ñ◊ï?', delay: 600 },
      { text: '◊ñ◊î ◊î◊û◊ß◊ï◊ù ◊©◊ë◊ï ◊î◊ñ◊ï◊í◊ô◊ï◊™ ◊í◊ì◊ú◊î.', delay: 600 },
      { text: '◊ë◊û◊ß◊ï◊û◊ï◊™ ◊î◊ú◊ê ◊†◊ï◊ó◊ô◊ù.', delay: 0 },
    ],
  },
  {
    id: 'before_q_2',
    context: 'before_question',
    lines: [
      { text: '◊î◊©◊ê◊ú◊î ◊î◊ë◊ê◊î.', delay: 600 },
      { text: '◊ê◊ú ◊™◊ó◊§◊©◊ï ◊ê◊™ ◊î◊™◊©◊ï◊ë◊î "◊î◊†◊õ◊ï◊†◊î".', delay: 600 },
      { text: '◊ê◊ô◊ü ◊õ◊ñ◊ï.', delay: 800 },
      { text: '◊ô◊© ◊®◊ß ◊™◊©◊ï◊ë◊î ◊õ◊†◊î.', delay: 0 },
    ],
  },
];

// ◊ò◊ß◊°◊ò◊ô◊ù ◊ê◊ó◊®◊ô ◊™◊©◊ï◊ë◊î ◊õ◊†◊î
export const afterHonestAnswerTexts: DrCharifText[] = [
  {
    id: 'after_honest_1',
    context: 'after_answer',
    lines: [
      { text: '◊®◊í◊¢.', delay: 600 },
      { text: '◊¢◊¶◊®◊ï.', delay: 600 },
      { text: '◊û◊î ◊©◊†◊ê◊û◊® ◊¢◊õ◊©◊ô◊ï?', delay: 600 },
      { text: '◊ñ◊î ◊ú◊ê ◊ò◊®◊ô◊ï◊ï◊ô◊î.', delay: 600 },
      { text: '◊ñ◊î ◊ú◊ê ◊û◊©◊ó◊ß.', delay: 800 },
      { text: '◊û◊ô◊©◊î◊ï ◊§◊î ◊¢◊õ◊©◊ô◊ï ◊ê◊û◊® ◊û◊©◊î◊ï ◊©◊¢◊ú◊î ◊ú◊ï.', delay: 800 },
      { text: '◊™◊°◊™◊õ◊ú◊ï ◊ê◊ó◊ì ◊¢◊ú ◊î◊©◊†◊ô◊ô◊î.', delay: 600 },
      { text: '◊®◊ï◊ê◊ô◊ù?', delay: 600 },
      { text: '◊ñ◊î ◊î◊§◊†◊ô◊ù ◊©◊ú ◊ë◊ü ◊ê◊ì◊ù ◊©◊î◊ï◊®◊ô◊ì ◊©◊®◊ô◊ï◊ü.', delay: 800 },
      { text: '◊™◊ñ◊õ◊®◊ï ◊ê◊™ ◊î◊§◊†◊ô◊ù ◊î◊ê◊ú◊î.', delay: 0 },
    ],
  },
];

// ◊ò◊ß◊°◊ò◊ô◊ù ◊ú◊ï◊ò◊ï
export const vetoTexts: DrCharifText[] = [
  {
    id: 'veto_1',
    context: 'veto',
    lines: [
      { text: '◊ï◊ò◊ï.', delay: 600 },
      { text: '◊©◊û◊¢◊ï, ◊ê◊†◊ô ◊ú◊ê ◊©◊ï◊§◊ò.', delay: 600 },
      { text: '◊ô◊© ◊ì◊ë◊®◊ô◊ù ◊©◊î◊í◊ï◊£ ◊§◊©◊ï◊ò ◊ê◊ï◊û◊® "◊ú◊ê ◊î◊ô◊ï◊ù".', delay: 800 },
      { text: '◊î◊ë◊¢◊ô◊î ◊û◊™◊ó◊ô◊ú◊î ◊õ◊©"◊ú◊ê ◊î◊ô◊ï◊ù" ◊î◊ï◊§◊ö ◊ú"◊ú◊ê ◊ê◊£ ◊§◊¢◊ù"', delay: 600 },
      { text: '◊ë◊ú◊ô ◊©◊ê◊£ ◊ê◊ó◊ì ◊©◊ù ◊ú◊ë ◊ú◊û◊¢◊ë◊®.', delay: 800 },
      { text: '◊ê◊ñ ◊®◊ß ◊™◊ñ◊õ◊®◊ï ◊©◊î◊ô◊ô◊™◊î ◊§◊î ◊©◊ê◊ú◊î.', delay: 600 },
      { text: '◊î◊ô◊ê ◊ú◊ê ◊î◊ï◊ú◊õ◊™ ◊ú◊©◊ï◊ù ◊û◊ß◊ï◊ù.', delay: 0 },
    ],
  },
];

// ◊û◊¢◊ë◊®◊ô◊ù ◊ë◊ô◊ü ◊©◊ú◊ë◊ô◊ù
export const transitionTexts: DrCharifText[] = [
  {
    id: 'transition_1',
    context: 'transition',
    lines: [
      { text: '◊ê◊™◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊û◊î ◊î◊î◊ë◊ì◊ú ◊ë◊ô◊ü ◊ñ◊ï◊í◊ï◊™ ◊©◊†◊©◊ê◊®◊ô◊ù ◊ú◊ñ◊ï◊í◊ï◊™ ◊©◊†◊§◊®◊ì◊ô◊ù?', delay: 800 },
      { text: '◊ú◊ê ◊ê◊î◊ë◊î.', delay: 600 },
      { text: '◊ú◊ê ◊°◊ß◊°.', delay: 600 },
      { text: '◊ú◊ê ◊õ◊°◊£.', delay: 800 },
      { text: '◊°◊ß◊®◊†◊ï◊™.', delay: 1000 },
      { text: '◊î◊ñ◊ï◊í◊ï◊™ ◊©◊†◊©◊ê◊®◊ô◊ù ◊¢◊ì◊ô◊ô◊ü ◊°◊ß◊®◊†◊ô◊ù ◊ú◊í◊ë◊ô ◊û◊î ◊©◊î◊ï◊ú◊ö ◊ë◊®◊ê◊© ◊©◊ú ◊î◊©◊†◊ô.', delay: 800 },
      { text: '◊ê◊ú◊î ◊©◊†◊§◊®◊ì◊ô◊ù?', delay: 600 },
      { text: '◊î◊ù ◊ë◊ò◊ï◊ó◊ô◊ù ◊©◊î◊ù ◊õ◊ë◊® ◊ô◊ï◊ì◊¢◊ô◊ù.', delay: 800 },
      { text: '◊ê◊ñ ◊ë◊ï◊ê◊ï ◊†◊ë◊ì◊ï◊ß ◊õ◊û◊î ◊ê◊™◊ù ◊ë◊ò◊ï◊ó◊ô◊ù.', delay: 0 },
    ],
  },
];

// ◊®◊í◊¢◊ô◊ù ◊§◊ô◊ú◊ï◊°◊ï◊§◊ô◊ô◊ù
export const philosophicalTexts: DrCharifText[] = [
  {
    id: 'philosophy_1',
    context: 'philosophical',
    lines: [
      { text: '◊ê◊™◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊û◊î ◊û◊¶◊ó◊ô◊ß?', delay: 600 },
      { text: '◊ñ◊ï◊í◊ï◊™ ◊ë◊ê◊ô◊ù ◊ê◊ú◊ô◊ô ◊ê◊ó◊®◊ô ◊¢◊©◊® ◊©◊†◊ô◊ù ◊ï◊ê◊ï◊û◊®◊ô◊ù "◊î◊ï◊ê ◊î◊©◊™◊†◊î".', delay: 800 },
      { text: '◊ú◊ê.', delay: 800 },
      { text: '◊î◊ï◊ê ◊™◊û◊ô◊ì ◊î◊ô◊î ◊õ◊õ◊î.', delay: 600 },
      { text: '◊§◊©◊ï◊ò ◊ë◊î◊™◊ó◊ú◊î ◊ß◊®◊ê◊™◊ù ◊ú◊ñ◊î "◊°◊§◊ï◊†◊ò◊†◊ô"', delay: 600 },
      { text: '◊ï◊¢◊õ◊©◊ô◊ï ◊ê◊™◊ù ◊ß◊ï◊®◊ê◊ô◊ù ◊ú◊ñ◊î "◊ó◊°◊® ◊ê◊ó◊®◊ô◊ï◊™".', delay: 800 },
      { text: '◊î◊û◊¶◊ô◊ê◊ï◊™ ◊ú◊ê ◊î◊©◊™◊†◊™◊î.', delay: 600 },
      { text: '◊î◊û◊ô◊ú◊ô◊ù ◊©◊ú◊õ◊ù ◊î◊©◊™◊†◊ï.', delay: 0 },
    ],
  },
];

// ◊§◊™◊ô◊ó◊™ ◊ó◊ô◊ì◊ï◊ü
export const quizIntroText: DrCharifText = {
  id: 'quiz_intro',
  context: 'quiz',
  lines: [
    { text: '◊¢◊õ◊©◊ô◊ï ◊†◊í◊ú◊î ◊û◊ô ◊û◊õ◊ô◊® ◊ê◊™ ◊û◊ô.', delay: 800 },
    { text: '◊ò◊ô◊§ -', delay: 600 },
    { text: '◊ñ◊î ◊ú◊ê ◊û◊ë◊ó◊ü.', delay: 600 },
    { text: '◊ê◊ô◊ü ◊¶◊ô◊ï◊ü ◊¢◊ï◊ë◊®.', delay: 600 },
    { text: '◊ô◊© ◊®◊ß ◊û◊®◊ê◊î.', delay: 800 },
    { text: '◊ï◊û◊®◊ê◊ï◊™ ◊ú◊ê ◊û◊©◊ß◊®◊ï◊™,', delay: 600 },
    { text: '◊ê◊ë◊ú ◊î◊ü ◊í◊ù ◊ú◊ê ◊û◊°◊§◊®◊ï◊™ ◊ê◊™ ◊õ◊ú ◊î◊°◊ô◊§◊ï◊®.', delay: 800 },
    { text: '◊û◊î ◊©◊ú◊ê ◊™◊ì◊¢◊ï?', delay: 600 },
    { text: '◊ñ◊ï ◊ú◊ê ◊ë◊ï◊©◊î.', delay: 600 },
    { text: '◊ñ◊ï ◊î◊ñ◊û◊†◊î.', delay: 0 },
  ],
};

// ◊ó◊ô◊ë◊ï◊® ◊û◊õ◊©◊ô◊®◊ô◊ù
export const deviceConnectionText: DrCharifText = {
  id: 'device_connection',
  context: 'quiz',
  lines: [
    { text: '◊™◊®◊ô◊û◊ï ◊õ◊ú ◊ê◊ó◊ì ◊ê◊™ ◊î◊ò◊ú◊§◊ï◊ü ◊©◊ú◊ï.', delay: 800 },
    { text: '◊ê◊ó◊ì ◊û◊õ◊ù ◊ô◊ß◊ë◊ú ◊ß◊ï◊ì.', delay: 600 },
    { text: '◊î◊©◊†◊ô ◊ô◊ß◊ú◊ô◊ì ◊ê◊ï◊™◊ï.', delay: 600 },
    { text: '◊ê◊®◊ë◊¢ ◊°◊§◊®◊ï◊™.', delay: 800 },
    { text: '◊ê◊ù ◊ê◊™◊ù ◊ú◊ê ◊û◊°◊ï◊í◊ú◊ô◊ù ◊ú◊ñ◊õ◊ï◊® ◊ê◊®◊ë◊¢ ◊°◊§◊®◊ï◊™ ◊ë◊ô◊ó◊ì ◊ê◊ó◊®◊ô ◊õ◊ú ◊î◊©◊†◊ô◊ù ◊î◊ê◊ú◊î,', delay: 600 },
    { text: '◊ô◊© ◊ú◊†◊ï ◊ë◊¢◊ô◊ï◊™ ◊ô◊ï◊™◊® ◊í◊ì◊ï◊ú◊ï◊™ ◊û◊ó◊ô◊ì◊ï◊ü.', delay: 0 },
  ],
};

// ◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú
export const wheelIntroText: DrCharifText = {
  id: 'wheel_intro',
  context: 'wheel',
  lines: [
    { text: '◊ó◊û◊© ◊¢◊©◊®◊î ◊ê◊§◊©◊®◊ï◊ô◊ï◊™.', delay: 800 },
    { text: '◊ú◊ê ◊ê◊í◊ô◊ì ◊ú◊õ◊ù ◊û◊î.', delay: 600 },
    { text: '◊®◊ß ◊©◊ó◊ú◊ß ◊û◊î◊ü ◊†◊í◊û◊®◊ï◊™ ◊î◊ú◊ô◊ú◊î,', delay: 600 },
    { text: '◊ï◊ó◊ú◊ß?', delay: 800 },
    { text: '◊ó◊ú◊ß ◊ô◊ú◊ï◊ï ◊ê◊™◊õ◊ù ◊¢◊ï◊ì ◊î◊®◊ë◊î ◊ê◊ó◊®◊ô ◊©◊™◊°◊í◊®◊ï ◊ê◊™ ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î.', delay: 800 },
    { text: '◊í◊ú◊í◊ú◊ï.', delay: 600 },
    { text: '◊ï◊©◊ô◊î◊ô◊î ◊ú◊õ◊ù ◊û◊ñ◊ú.', delay: 600 },
    { text: '◊ê◊ï ◊©◊ú◊ê.', delay: 600 },
    { text: '◊™◊ú◊ï◊ô ◊ê◊ô◊ñ◊î ◊¶◊ì ◊©◊ú ◊î◊í◊ú◊í◊ú ◊ê◊™◊ù ◊û◊¢◊ì◊ô◊§◊ô◊ù.', delay: 0 },
  ],
};

// ◊°◊ô◊ï◊ù
export const endingText = (winnerName: string): DrCharifText => ({
  id: 'ending',
  context: 'ending',
  lines: [
    { text: '◊î◊í◊¢◊†◊ï ◊ú◊°◊ï◊£ ◊ï◊ê◊™◊ù ◊¢◊ì◊ô◊ô◊ü ◊ë◊ô◊ó◊ì ◊¢◊ú ◊î◊°◊§◊î.', delay: 800 },
    { text: '◊ê◊™◊ù ◊ô◊ï◊ì◊¢◊ô◊ù ◊õ◊û◊î ◊ñ◊ï◊í◊ï◊™ ◊ú◊ê ◊û◊°◊ô◊ô◊û◊ô◊ù ◊ê◊™ ◊î◊¢◊®◊ë ◊î◊ñ◊î ◊¢◊ú ◊ê◊ï◊™◊î ◊°◊§◊î?', delay: 800 },
    { text: '◊ú◊ê ◊û◊©◊†◊î ◊û◊î ◊î◊†◊ô◊ß◊ï◊ì.', delay: 600 },
    { text: '◊ú◊ê ◊û◊©◊†◊î ◊û◊ô ◊†◊ô◊¶◊ó.', delay: 600 },
    { text: `◊ê◊ë◊ú ◊ê◊ù ◊ñ◊î ◊ó◊©◊ï◊ë ◊ú◊õ◊ù - ${winnerName} ◊†◊ô◊¶◊ó.`, delay: 800 },
    { text: '◊û◊î ◊©◊û◊©◊†◊î ◊ñ◊î ◊©◊ë◊ó◊®◊™◊ù ◊ú◊î◊ô◊ï◊™ ◊§◊î.', delay: 600 },
    { text: '◊ê◊ó◊ì ◊¢◊ù ◊î◊©◊†◊ô◊ô◊î.', delay: 600 },
    { text: '◊ë◊¢◊®◊ë ◊©◊ô◊õ◊ï◊ú◊™◊ù ◊ú◊ë◊ñ◊ë◊ñ ◊¢◊ú ◊†◊ò◊§◊ú◊ô◊ß◊°.', delay: 800 },
    { text: '◊î◊ú◊õ◊™◊ù ◊¢◊ú ◊û◊©◊î◊ï ◊ô◊ï◊™◊® ◊ß◊©◊î.', delay: 600 },
    { text: '◊ô◊ï◊™◊® ◊ú◊ê ◊†◊ï◊ó.', delay: 600 },
    { text: '◊ô◊ï◊™◊® ◊ê◊û◊ô◊™◊ô.', delay: 1000 },
    { text: '◊¢◊õ◊©◊ô◊ï ◊°◊í◊®◊ï ◊ê◊™ ◊î◊ò◊ú◊§◊ï◊ü.', delay: 800 },
    { text: '◊ô◊© ◊ú◊õ◊ù ◊¢◊ë◊ï◊ì◊î ◊ú◊¢◊©◊ï◊™.', delay: 600 },
    { text: '◊û◊î◊°◊ï◊í ◊î◊ò◊ï◊ë.', delay: 0 },
  ],
});

export const tieEndingText: DrCharifText = {
  id: 'tie_ending',
  context: 'ending',
  lines: [
    { text: '◊î◊í◊¢◊†◊ï ◊ú◊°◊ï◊£.', delay: 800 },
    { text: '◊™◊ô◊ß◊ï.', delay: 600 },
    { text: '◊û◊™◊ê◊ô◊ù.', delay: 800 },
    { text: '◊ë◊ñ◊ï◊í◊ô◊ï◊™ ◊ò◊ï◊ë◊î ◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊ë◊ê◊û◊™ ◊û◊†◊¶◊ó.', delay: 600 },
    { text: '◊ï◊ê◊£ ◊ê◊ó◊ì ◊ú◊ê ◊ë◊ê◊û◊™ ◊û◊§◊°◊ô◊ì.', delay: 800 },
    { text: '◊ê◊™◊ù ◊§◊©◊ï◊ò ◊û◊û◊©◊ô◊õ◊ô◊ù.', delay: 600 },
    { text: '◊ë◊ô◊ó◊ì.', delay: 1000 },
    { text: '◊¢◊õ◊©◊ô◊ï ◊°◊í◊®◊ï ◊ê◊™ ◊î◊ò◊ú◊§◊ï◊ü.', delay: 800 },
    { text: '◊ô◊© ◊ú◊õ◊ù ◊¢◊ë◊ï◊ì◊î ◊ú◊¢◊©◊ï◊™.', delay: 600 },
    { text: '◊û◊î◊°◊ï◊í ◊î◊ò◊ï◊ë.', delay: 0 },
  ],
};

// Paywall
export const paywallText: DrCharifText = {
  id: 'paywall',
  context: 'paywall',
  lines: [
    { text: '◊ê◊ñ ◊ñ◊î◊ï, ◊§◊î ◊†◊í◊û◊® ◊î◊ò◊¢◊ô◊û◊î.', delay: 800 },
    { text: '◊û◊î ◊©◊û◊ó◊õ◊î ◊ú◊õ◊ù ◊ë◊§◊†◊ô◊ù?', delay: 600 },
    { text: '◊ë◊ï◊ê◊ï ◊†◊í◊ô◊ì ◊©◊ê◊™◊ù ◊¢◊ì◊ô◊ô◊ü ◊ú◊ë◊ï◊©◊ô◊ù ◊û◊ì◊ô ◊ë◊©◊ë◊ô◊ú ◊û◊î ◊©◊™◊õ◊†◊†◊™◊ô.', delay: 1000 },
    { text: '79 ◊©◊ß◊ú.', delay: 600 },
    { text: '◊§◊ó◊ï◊™ ◊û◊ë◊ß◊ë◊ï◊ß ◊ô◊ô◊ü ◊ë◊ô◊†◊ï◊†◊ô.', delay: 600 },
    { text: '◊ï◊ô◊ï◊™◊® ◊î◊©◊§◊¢◊î ◊¢◊ú ◊î◊¢◊®◊ë ◊©◊ú◊õ◊ù.', delay: 0 },
  ],
};

// ◊®◊í◊¢ ◊©◊ú ◊ó◊ï◊ù ◊û◊ï◊°◊™◊®
export const warmthTexts: DrCharifText[] = [
  {
    id: 'warmth_1',
    context: 'warmth',
    lines: [
      { text: '◊®◊ê◊ô◊™◊ô ◊î◊û◊ï◊ü ◊ñ◊ï◊í◊ï◊™.', delay: 600 },
      { text: '◊ô◊© ◊õ◊ê◊ú◊î ◊©◊†◊õ◊†◊°◊ô◊ù ◊ú◊ó◊ì◊® ◊ï◊ê◊™◊î ◊û◊®◊ô◊ó ◊ê◊™ ◊î◊¢◊ô◊ô◊§◊ï◊™.', delay: 800 },
      { text: '◊ï◊ô◊© ◊õ◊ê◊ú◊î ◊©◊†◊õ◊†◊°◊ô◊ù ◊ï◊ê◊™◊î ◊®◊ï◊ê◊î -', delay: 600 },
      { text: '◊î◊ù ◊¢◊ì◊ô◊ô◊ü ◊®◊ï◊¶◊ô◊ù.', delay: 800 },
      { text: '◊®◊ï◊¶◊ô◊ù ◊©◊ñ◊î ◊ô◊¢◊ë◊ï◊ì.', delay: 600 },
      { text: '◊ê◊™◊ù ◊û◊î◊°◊ï◊í ◊î◊©◊†◊ô.', delay: 800 },
      { text: '◊ê◊†◊ô ◊ô◊ï◊ì◊¢ ◊õ◊ô ◊î◊°◊ï◊í ◊î◊®◊ê◊©◊ï◊ü ◊ú◊ê ◊û◊ï◊®◊ô◊ì ◊ê◊§◊ú◊ô◊ß◊¶◊ô◊ï◊™.', delay: 600 },
      { text: '◊î◊ï◊ê ◊û◊ï◊®◊ô◊ì ◊¢◊ï◊®◊õ◊ô ◊ì◊ô◊ü.', delay: 0 },
    ],
  },
];

--------------------------------------------------------------------------------
FILE: src/data/index.ts
--------------------------------------------------------------------------------

// Dr. Charif texts
export * from './drCharifTexts';

// Questions and tasks
export * from './questions';
export * from './tasks';

// Quiz
export * from './quizQuestions';

// Prizes
export * from './prizes';

--------------------------------------------------------------------------------
FILE: src/data/prizes.ts
--------------------------------------------------------------------------------

/**
 * Prizes Data - ◊§◊®◊°◊ô ◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú
 *
 * 15 ◊§◊®◊°◊ô◊ù ◊ú◊û◊†◊¶◊ó
 */

export interface Prize {
  id: number;
  name: string;
  description: string;
  intensity: 1 | 2 | 3;
  category: string;
  emoji: string;
}

export const prizes: Prize[] = [
  {
    id: 1,
    name: '◊î◊©◊ë◊ï◊¢ ◊©◊ú◊ô',
    description: '◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊® ◊ô◊ï◊ù ◊ë◊©◊ë◊ï◊¢ ◊î◊ß◊®◊ï◊ë. ◊ë◊ê◊ï◊™◊ï ◊ô◊ï◊ù, ◊õ◊ú ◊î◊ó◊ú◊ò◊î ◊¢◊ú◊ô◊ï.',
    intensity: 2,
    category: '◊©◊ú◊ô◊ò◊î',
    emoji: 'üìÖ',
  },
  {
    id: 2,
    name: '◊î◊ß◊¢◊ß◊ï◊¢',
    description: '◊ß◊¢◊ß◊ï◊¢ ◊ñ◊û◊†◊ô ◊ë◊û◊ß◊ï◊ù ◊©◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊®. ◊†◊©◊ê◊® ◊©◊ë◊ï◊¢.',
    intensity: 2,
    category: '◊í◊ï◊£',
    emoji: 'üé®',
  },
  {
    id: 3,
    name: '◊î◊û◊¶◊ú◊û◊î',
    description: '◊î◊û◊†◊¶◊ó ◊û◊¶◊ú◊ù 3 ◊™◊†◊ï◊ó◊ï◊™ ◊©◊î◊ï◊ê ◊ë◊ï◊ó◊®.',
    intensity: 3,
    category: '◊ê◊ô◊†◊ò◊ô◊û◊ô',
    emoji: 'üì∏',
  },
  {
    id: 4,
    name: '◊î◊ó◊ï◊ñ◊î',
    description: '◊î◊û◊§◊°◊ô◊ì ◊ó◊ï◊™◊ù ◊¢◊ú ◊û◊ó◊ï◊ô◊ë◊ï◊™ ◊ú◊ó◊ï◊ì◊© ◊î◊ß◊®◊ï◊ë.',
    intensity: 2,
    category: '◊û◊ó◊ï◊ô◊ë◊ï◊™',
    emoji: 'üìù',
  },
  {
    id: 5,
    name: '◊î◊õ◊®◊ò◊ô◊° ◊î◊©◊ó◊ï◊®',
    description: '◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊î◊û◊†◊¶◊ó ◊ê◊ï◊û◊® "◊¢◊õ◊©◊ô◊ï" ◊ï◊î◊û◊§◊°◊ô◊ì ◊ë◊ê.',
    intensity: 3,
    category: '◊õ◊ï◊ó',
    emoji: 'üÉè',
  },
  {
    id: 6,
    name: '◊î◊ë◊û◊î',
    description: '◊§◊ï◊°◊ò ◊¶◊ô◊ë◊ï◊®◊ô ◊©◊î◊û◊†◊¶◊ó ◊û◊õ◊™◊ô◊ë.',
    intensity: 2,
    category: '◊§◊ï◊û◊ë◊ô',
    emoji: 'üì±',
  },
  {
    id: 7,
    name: '◊ú◊ú◊ê ◊ô◊ì◊ô◊ô◊ù',
    description: '◊©◊¢◊î ◊ë◊ú◊ô ◊ô◊ì◊ô◊ô◊ù, ◊î◊û◊†◊¶◊ó ◊û◊ê◊õ◊ô◊ú ◊ï◊û◊©◊ß◊î.',
    intensity: 2,
    category: '◊û◊©◊ó◊ß',
    emoji: 'üôå',
  },
  {
    id: 8,
    name: '◊î◊ë◊ï◊ß◊® ◊©◊ê◊ó◊®◊ô',
    description: '◊î◊û◊†◊¶◊ó ◊ô◊©◊ü ◊õ◊û◊î ◊©◊®◊ï◊¶◊î, ◊î◊û◊§◊°◊ô◊ì ◊û◊õ◊ô◊ü ◊î◊õ◊ú.',
    intensity: 1,
    category: '◊§◊ô◊†◊ï◊ß',
    emoji: '‚òÄÔ∏è',
  },
  {
    id: 9,
    name: '◊î◊§◊†◊ò◊ñ◊ô◊î',
    description: '◊î◊û◊†◊¶◊ó ◊û◊™◊ê◊® ◊§◊†◊ò◊ñ◊ô◊î, ◊©◊ë◊ï◊¢◊ô◊ô◊ù ◊ú◊î◊í◊©◊ô◊ù.',
    intensity: 3,
    category: '◊ê◊ô◊†◊ò◊ô◊û◊ô',
    emoji: 'üí≠',
  },
  {
    id: 10,
    name: '◊î◊ê◊®◊†◊ß ◊î◊§◊™◊ï◊ó',
    description: '◊ß◊†◊ô◊ï◊™ - ◊§◊®◊ô◊ò ◊ê◊ó◊ì ◊ú◊ú◊ê ◊™◊ß◊®◊î.',
    intensity: 2,
    category: '◊õ◊°◊£',
    emoji: 'üí∞',
  },
  {
    id: 11,
    name: '◊î◊î◊ß◊ú◊ò◊î',
    description: '◊î◊ï◊ì◊¢◊î ◊ß◊ï◊ú◊ô◊™ ◊©◊ú ◊ì◊ß◊î ◊©◊î◊û◊†◊¶◊ó ◊û◊õ◊™◊ô◊ë.',
    intensity: 1,
    category: '◊®◊í◊©◊ô',
    emoji: 'üé§',
  },
  {
    id: 12,
    name: '24 ◊©◊¢◊ï◊™',
    description: '◊ô◊û◊û◊î ◊©◊î◊û◊§◊°◊ô◊ì ◊ú◊ê ◊ô◊õ◊ï◊ú ◊ú◊î◊í◊ô◊ì "◊ú◊ê".',
    intensity: 3,
    category: '◊©◊ú◊ô◊ò◊î',
    emoji: '‚è∞',
  },
  {
    id: 13,
    name: '◊î◊ì◊ú◊™ ◊†◊¢◊ï◊ú◊î',
    description: '◊¢◊®◊ë ◊ë◊ú◊ô ◊ò◊ú◊§◊ï◊†◊ô◊ù - ◊©◊†◊ô◊î◊ù.',
    intensity: 1,
    category: '◊ó◊ï◊ï◊ô◊î',
    emoji: 'üö™',
  },
  {
    id: 14,
    name: '◊î◊ë◊ô◊©◊ï◊ú',
    description: '◊ê◊®◊ï◊ó◊™ 3 ◊û◊†◊ï◊™, ◊î◊û◊†◊¶◊ó ◊ë◊ï◊ó◊® ◊™◊§◊®◊ô◊ò.',
    intensity: 2,
    category: '◊©◊ô◊®◊ï◊™',
    emoji: 'üë®‚Äçüç≥',
  },
  {
    id: 15,
    name: '◊î◊û◊§◊™◊ó',
    description: '◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊î◊û◊†◊¶◊ó ◊ß◊ï◊®◊ê ◊õ◊ú ◊©◊ô◊ó◊î ◊ë◊ò◊ú◊§◊ï◊ü.',
    intensity: 3,
    category: '◊ê◊û◊ï◊ü',
    emoji: 'üîë',
  },
];

// ◊ß◊ë◊ú◊™ ◊§◊®◊° ◊ê◊ß◊®◊ê◊ô
export const getRandomPrize = (): Prize => {
  const index = Math.floor(Math.random() * prizes.length);
  return prizes[index];
};

// ◊ß◊ë◊ú◊™ ◊§◊®◊° ◊ú◊§◊ô ID
export const getPrizeById = (id: number): Prize | undefined => {
  return prizes.find((p) => p.id === id);
};

// ◊ß◊ë◊ú◊™ ◊õ◊ú ◊î◊§◊®◊°◊ô◊ù ◊ú◊§◊ô ◊¢◊ï◊¶◊û◊î
export const getPrizesByIntensity = (intensity: 1 | 2 | 3): Prize[] => {
  return prizes.filter((p) => p.intensity === intensity);
};

--------------------------------------------------------------------------------
FILE: src/data/questions.ts
--------------------------------------------------------------------------------

/**
 * ◊©◊ê◊ú◊ï◊™ - ◊í◊®◊°◊î ◊§◊°◊ô◊õ◊ï◊ú◊ï◊í◊ô◊™ ◊¢◊û◊ï◊ß◊î
 *
 * 10 ◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ √ó ◊©◊ê◊ú◊ï◊™ ◊û◊ì◊ï◊®◊í◊ï◊™
 * ◊õ◊ú ◊©◊ê◊ú◊î ◊¢◊ë◊®◊î ◊û◊ë◊ó◊ü: "◊î◊ê◊ù ◊ñ◊î ◊ô◊í◊®◊ï◊ù ◊ú◊©◊™◊ô◊ß◊î ◊©◊ú 5 ◊©◊†◊ô◊ï◊™ ◊ú◊§◊†◊ô ◊î◊™◊©◊ï◊ë◊î?"
 */

export type QuestionCategory =
  | 'time_machine'      // ◊¢◊ë◊®/◊¢◊™◊ô◊ì ◊¢◊ù ◊ò◊ï◊ï◊ô◊°◊ò
  | 'parallel_worlds'   // ◊™◊®◊ó◊ô◊©◊ô "◊û◊î ◊ê◊ù"
  | 'body_soul'         // ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™ ◊ì◊®◊ö ◊¢◊ß◊ô◊§◊ô◊ü
  | 'money_talks'       // ◊¢◊®◊õ◊ô◊ù ◊ì◊®◊ö ◊õ◊°◊£
  | 'social_judgment'   // ◊ê◊ô◊ö ◊ê◊ó◊®◊ô◊ù ◊®◊ï◊ê◊ô◊ù ◊ê◊ï◊™◊†◊ï
  | 'small_secrets'     // ◊ì◊ë◊®◊ô◊ù ◊©◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊†◊ê◊û◊®◊ï
  | 'ego_war'          // ◊™◊ó◊®◊ï◊™◊ô◊ï◊™ ◊ï◊ê◊í◊ï
  | 'fears_desires'     // ◊§◊ó◊ì◊ô◊ù ◊ï◊®◊¶◊ï◊†◊ï◊™ ◊¢◊û◊ï◊ß◊ô◊ù
  | 'small_things'      // ◊î◊ß◊ò◊†◊ï◊™ ◊©◊î◊ï◊®◊í◊ï◊™
  | 'one_night';        // ◊§◊†◊ò◊ñ◊ô◊ï◊™ ◊°◊§◊¶◊ô◊§◊ô◊ï◊™

export interface Question {
  id: string;
  stage: number;
  category: QuestionCategory;
  difficulty: 1 | 2 | 3;
  text: string;
  textMale?: string;
  textFemale?: string;
  followUp?: string;
}

export const questions: Question[] = [
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 1 - "◊®◊í◊¢ ◊ú◊§◊†◊ô ◊©◊†◊§◊í◊©◊†◊ï"
  // ◊†◊ï◊©◊ê: ◊û◊ô ◊î◊ô◊ô◊†◊ï ◊ú◊§◊†◊ô, ◊ï◊û◊î ◊†◊©◊ê◊®
  // 8 ◊§◊®◊ô◊ò◊ô◊ù (70% ◊©◊ê◊ú◊ï◊™ = 5-6 ◊©◊ê◊ú◊ï◊™)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 'q1_1',
    stage: 1,
    category: 'time_machine',
    difficulty: 1,
    text: '◊ê◊ù ◊î◊ô◊ô◊™◊ô ◊§◊ï◊í◊© ◊ê◊ï◊™◊ö ◊ë◊í◊ô◊ú 16 - ◊î◊ô◊ô◊™◊ô ◊û◊ï◊¶◊ê ◊ó◊ü ◊ë◊¢◊ô◊†◊ô◊ö?',
    followUp: '◊ú◊û◊î ◊õ◊ü ◊ê◊ï ◊ú◊û◊î ◊ú◊ê?',
  },
  {
    id: 'q1_2',
    stage: 1,
    category: 'small_secrets',
    difficulty: 2,
    text: '◊û◊î ◊î◊ì◊ë◊® ◊©◊ó◊©◊ë◊™ ◊¢◊ú◊ô◊ô ◊ë◊©◊ë◊ï◊¢◊ï◊™ ◊î◊®◊ê◊©◊ï◊†◊ô◊ù ◊ï◊ú◊ê ◊î◊¢◊ñ◊™ ◊ú◊î◊í◊ô◊ì ◊¢◊ì ◊î◊ô◊ï◊ù?',
  },
  {
    id: 'q1_3',
    stage: 1,
    category: 'parallel_worlds',
    difficulty: 2,
    text: '◊ê◊ù ◊î◊ô◊ô◊†◊ï ◊†◊§◊í◊©◊ô◊ù ◊î◊ô◊ï◊ù ◊ë◊§◊¢◊ù ◊î◊®◊ê◊©◊ï◊†◊î - ◊î◊ô◊ô◊™ ◊û◊™◊ó◊ô◊ú/◊î ◊ê◊ô◊™◊ô?',
  },
  {
    id: 'q1_4',
    stage: 1,
    category: 'time_machine',
    difficulty: 2,
    text: '◊ê◊ô◊ñ◊î ◊ó◊ú◊ß ◊û◊¢◊¶◊û◊ö ◊û◊™◊ß◊ï◊§◊î ◊ú◊§◊†◊ô ◊©◊î◊õ◊®◊™ ◊ê◊ï◊™◊ô ◊ê◊™◊î ◊û◊™◊í◊¢◊í◊¢ ◊ê◊ú◊ô◊ï?',
  },
  {
    id: 'q1_5',
    stage: 1,
    category: 'fears_desires',
    difficulty: 3,
    text: '◊û◊î ◊ï◊ô◊™◊®◊™ ◊¢◊ú◊ô◊ï ◊ë◊©◊ë◊ô◊ú◊†◊ï ◊©◊ê◊™◊î ◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊ë◊ò◊ï◊ó ◊©◊ñ◊î ◊î◊ô◊î ◊©◊ï◊ï◊î?',
  },
  {
    id: 'q1_6',
    stage: 1,
    category: 'small_secrets',
    difficulty: 3,
    text: '◊û◊î ◊©◊ô◊ß◊®◊™ ◊ú◊ô ◊¢◊ú◊ô◊ï ◊ë◊î◊™◊ó◊ú◊î ◊õ◊ô ◊®◊¶◊ô◊™ ◊©◊ê◊™◊®◊©◊ù?',
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 2 - "◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™"
  // ◊†◊ï◊©◊ê: ◊ó◊ô◊û◊ï◊ù, ◊î◊†◊ê◊î, ◊ß◊ú◊ô◊ú◊ï◊™ ◊¢◊ù ◊¢◊ï◊û◊ß
  // 8 ◊§◊®◊ô◊ò◊ô◊ù (40% ◊©◊ê◊ú◊ï◊™ = 3 ◊©◊ê◊ú◊ï◊™)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 'q2_1',
    stage: 2,
    category: 'ego_war',
    difficulty: 1,
    text: '◊ë◊û◊î ◊ê◊†◊ô ◊ô◊ï◊™◊® ◊ò◊ï◊ë ◊û◊û◊ö ◊ï◊ë◊û◊î ◊ê◊™/◊î ◊ô◊ï◊™◊® ◊ò◊ï◊ë ◊û◊û◊†◊ô?',
  },
  {
    id: 'q2_2',
    stage: 2,
    category: 'social_judgment',
    difficulty: 1,
    text: '◊û◊î ◊ú◊ì◊¢◊™◊ö ◊î◊ó◊ë◊®◊ô◊ù ◊©◊ú◊†◊ï ◊ê◊ï◊û◊®◊ô◊ù ◊¢◊ú◊ô◊†◊ï ◊õ◊©◊ê◊†◊ó◊†◊ï ◊ú◊ê ◊ë◊ó◊ì◊®?',
  },
  {
    id: 'q2_3',
    stage: 2,
    category: 'small_things',
    difficulty: 2,
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊õ◊ô ◊ß◊ò◊ü ◊©◊ê◊†◊ô ◊¢◊ï◊©◊î ◊©◊û◊©◊í◊¢ ◊ê◊ï◊™◊ö - ◊ë◊ò◊ï◊ë?',
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 3 - "◊ì◊ë◊®◊ô◊ù ◊©◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù ◊ë◊ß◊ï◊ú"
  // ◊†◊ï◊©◊ê: ◊§◊í◊ô◊¢◊ï◊™, ◊õ◊†◊ï◊™ ◊õ◊ï◊ê◊ë◊™
  // 8 ◊§◊®◊ô◊ò◊ô◊ù (50% ◊©◊ê◊ú◊ï◊™ = 4 ◊©◊ê◊ú◊ï◊™)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 'q3_1',
    stage: 3,
    category: 'fears_desires',
    difficulty: 2,
    text: '◊û◊™◊ô ◊î◊®◊í◊©◊™ ◊î◊õ◊ô ◊ë◊ï◊ì◊ì/◊î ◊ë◊™◊ï◊ö ◊î◊ñ◊ï◊í◊ô◊ï◊™ ◊©◊ú◊†◊ï?',
  },
  {
    id: 'q3_2',
    stage: 3,
    category: 'small_secrets',
    difficulty: 2,
    text: '◊û◊î ◊î◊ì◊ë◊® ◊©◊ê◊™◊î ◊î◊õ◊ô ◊û◊§◊ó◊ì ◊©◊ê◊í◊ú◊î ◊¢◊ú◊ô◊ö?',
  },
  {
    id: 'q3_3',
    stage: 3,
    category: 'body_soul',
    difficulty: 3,
    text: '◊û◊î ◊ê◊™◊î ◊®◊ï◊¶◊î ◊©◊ê◊¢◊©◊î ◊ú◊ö ◊©◊û◊¢◊ï◊ú◊ù ◊ú◊ê ◊ë◊ô◊ß◊©◊™ ◊õ◊ô ◊î◊™◊ë◊ô◊ô◊©◊™?',
  },
  {
    id: 'q3_4',
    stage: 3,
    category: 'fears_desires',
    difficulty: 3,
    text: '◊û◊î ◊î◊ï◊ô◊™◊ï◊® ◊î◊õ◊ô ◊í◊ì◊ï◊ú ◊©◊¢◊©◊ô◊™ ◊ú◊û◊¢◊†◊†◊ï ◊©◊ê◊†◊ô ◊ú◊ê ◊ô◊ï◊ì◊¢ ◊¢◊ú◊ô◊ï?',
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 4 - "◊û◊ú◊ó◊û◊™ ◊î◊í◊ô◊®◊°◊ê◊ï◊™"
  // ◊†◊ï◊©◊ê: ◊ê◊ô◊ö ◊õ◊ú ◊ê◊ó◊ì ◊®◊ï◊ê◊î ◊ê◊™ ◊ê◊ï◊™◊ï ◊ì◊ë◊® ◊ê◊ó◊®◊™
  // 8 ◊§◊®◊ô◊ò◊ô◊ù (80% ◊©◊ê◊ú◊ï◊™ = 6 ◊©◊ê◊ú◊ï◊™)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 'q4_1',
    stage: 4,
    category: 'ego_war',
    difficulty: 2,
    text: '◊¢◊ú ◊û◊î ◊ê◊™◊î ◊ô◊ï◊ì◊¢ ◊©◊ê◊™◊î ◊¶◊ï◊ì◊ß - ◊ê◊ë◊ú ◊ï◊ô◊™◊®◊™ ◊õ◊ô ◊ú◊ê ◊©◊ï◊ï◊î ◊ú◊î◊ô◊ú◊ó◊ù?',
  },
  {
    id: 'q4_2',
    stage: 4,
    category: 'ego_war',
    difficulty: 2,
    text: '◊û◊î ◊î◊ì◊ë◊® ◊©◊ê◊†◊ô ◊¢◊ï◊©◊î ◊©◊û◊¢◊¶◊ë◊ü ◊ê◊ï◊™◊ö ◊ê◊ë◊ú ◊ê◊™◊î ◊õ◊ë◊® ◊î◊§◊°◊ß◊™ ◊ú◊î◊¢◊ô◊® ◊¢◊ú◊ô◊ï?',
  },
  {
    id: 'q4_3',
    stage: 4,
    category: 'social_judgment',
    difficulty: 2,
    text: '◊û◊î ◊ú◊ì◊¢◊™◊ö ◊î◊û◊©◊§◊ó◊î ◊©◊ú◊ô ◊ë◊ê◊û◊™ ◊ó◊ï◊©◊ë◊™ ◊¢◊ú◊ô◊ö?',
  },
  {
    id: 'q4_4',
    stage: 4,
    category: 'money_talks',
    difficulty: 2,
    text: '◊¢◊ú ◊û◊î ◊ê◊†◊ó◊†◊ï ◊î◊õ◊ô ◊ú◊ê ◊û◊°◊õ◊ô◊û◊ô◊ù ◊ë◊†◊ï◊©◊ê ◊õ◊°◊£ - ◊ï◊û◊ô ◊¶◊ï◊ì◊ß?',
  },
  {
    id: 'q4_5',
    stage: 4,
    category: 'ego_war',
    difficulty: 3,
    text: '◊ë◊ê◊ô◊ñ◊î ◊®◊ô◊ë ◊ô◊©◊ü ◊ê◊™◊î ◊¢◊ì◊ô◊ô◊ü ◊ë◊ò◊ï◊ó ◊©◊¶◊ì◊ß◊™ - ◊ú◊û◊®◊ï◊™ ◊©◊î◊ï◊ì◊ô◊™?',
  },
  {
    id: 'q4_6',
    stage: 4,
    category: 'small_things',
    difficulty: 3,
    text: '◊û◊î ◊î◊ì◊ë◊® ◊©◊ê◊†◊ô ◊¢◊ï◊©◊î ◊©◊í◊ï◊®◊ù ◊ú◊ö ◊ú◊ó◊©◊ï◊ë "◊ú◊û◊î ◊î◊™◊ó◊™◊†◊™◊ô ◊¢◊ù ◊ñ◊î"?',
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 5 - "◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î"
  // ◊†◊ï◊©◊ê: ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™, ◊û◊©◊ô◊õ◊î, ◊í◊ï◊£
  // 8 ◊§◊®◊ô◊ò◊ô◊ù (30% ◊©◊ê◊ú◊ï◊™ = 2-3 ◊©◊ê◊ú◊ï◊™)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 'q5_1',
    stage: 5,
    category: 'body_soul',
    difficulty: 2,
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊ê◊ó◊®◊ï◊ü ◊©◊¢◊©◊ô◊†◊ï ◊ë◊û◊ô◊ò◊î ◊©◊î◊§◊™◊ô◊¢ ◊ê◊ï◊™◊ö ◊©◊†◊î◊†◊ô◊™ ◊û◊û◊†◊ï?',
  },
  {
    id: 'q5_2',
    stage: 5,
    category: 'one_night',
    difficulty: 3,
    text: '◊ê◊ù ◊î◊ô◊ô◊™ ◊¶◊®◊ô◊ö ◊ú◊ë◊ó◊ï◊®: ◊ú◊ô◊ú◊î ◊ê◊ó◊ì ◊©◊ú ◊°◊ß◊° ◊õ◊û◊ï ◊©◊î◊ô◊î ◊ë◊î◊™◊ó◊ú◊î, ◊ê◊ï ◊ú◊ô◊ú◊î ◊©◊ú ◊û◊©◊î◊ï ◊©◊ê◊£ ◊§◊¢◊ù ◊ú◊ê ◊¢◊©◊ô◊†◊ï?',
  },
  {
    id: 'q5_3',
    stage: 5,
    category: 'body_soul',
    difficulty: 3,
    text: '◊û◊™◊ô ◊î◊ô◊î ◊î◊®◊í◊¢ ◊î◊ê◊ó◊®◊ï◊ü ◊©◊î◊í◊ï◊£ ◊©◊ú◊ô ◊ë◊ê◊û◊™ ◊î◊§◊™◊ô◊¢ ◊ê◊ï◊™◊ö?',
  },
];

// ◊§◊ï◊†◊ß◊¶◊ô◊ï◊™ ◊¢◊ñ◊®
export const formatQuestion = (
  question: Question,
  partnerName: string,
  currentPlayerGender: 'male' | 'female' | 'other'
): string => {
  let text = question.text;
  if (currentPlayerGender === 'male' && question.textMale) {
    text = question.textMale;
  } else if (currentPlayerGender === 'female' && question.textFemale) {
    text = question.textFemale;
  }
  return text.replace(/{partner}/g, partnerName);
};

export const getQuestionsForStage = (stage: number): Question[] => {
  return questions.filter((q) => q.stage === stage);
};

export const getRandomQuestion = (
  stage: number,
  difficulty: 1 | 2 | 3,
  excludeIds: string[] = []
): Question | null => {
  const available = questions.filter(
    (q) => q.stage === stage && q.difficulty === difficulty && !excludeIds.includes(q.id)
  );
  if (available.length === 0) return null;
  return available[Math.floor(Math.random() * available.length)];
};

--------------------------------------------------------------------------------
FILE: src/data/quizQuestions.ts
--------------------------------------------------------------------------------

/**
 * ◊©◊ê◊ú◊ï◊™ ◊ó◊ô◊ì◊ï◊ü - 60 ◊©◊ê◊ú◊ï◊™ ◊©◊ë◊ï◊ì◊ß◊ï◊™ ◊õ◊û◊î ◊ë◊ê◊û◊™ ◊û◊õ◊ô◊®◊ô◊ù
 *
 * 6 ◊ß◊ò◊í◊ï◊®◊ô◊ï◊™ √ó 10 ◊©◊ê◊ú◊ï◊™
 * ◊î◊ß◊§◊ì◊î: ◊™◊©◊ï◊ë◊ï◊™ ◊©◊ë◊ê◊û◊™ ◊©◊ï◊†◊ï◊™ ◊ë◊ô◊ü ◊ê◊†◊©◊ô◊ù
 */

export type QuizCategory = 'past' | 'daily' | 'dreams' | 'intimacy' | 'dilemmas' | 'us';

export interface QuizQuestion {
  id: string;
  category: QuizCategory;
  text: string;
  options: string[];
}

export const QUIZ_CATEGORIES: Record<QuizCategory, { name: string; icon: string }> = {
  past: { name: '◊¢◊ë◊®', icon: '‚è≥' },
  daily: { name: '◊ô◊ï◊û◊ô◊ï◊ù', icon: '‚òï' },
  dreams: { name: '◊ó◊ú◊ï◊û◊ï◊™', icon: 'üí≠' },
  intimacy: { name: '◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™', icon: 'üî•' },
  dilemmas: { name: '◊ì◊ô◊ú◊û◊ï◊™', icon: '‚öñÔ∏è' },
  us: { name: '◊ê◊†◊ó◊†◊ï', icon: 'üíë' },
};

export const quizQuestions: QuizQuestion[] = [
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊¢◊ë◊® - 10 ◊©◊ê◊ú◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'past_1',
    category: 'past',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊®◊ê◊©◊ï◊ü ◊©◊©◊û◊™◊ô ◊ú◊ë ◊ê◊ú◊ô◊ï ◊õ◊©◊î◊õ◊®◊†◊ï?',
    options: ['◊î◊¢◊ô◊†◊ô◊ô◊ù', '◊î◊ó◊ô◊ï◊ö', '◊î◊ß◊ï◊ú', '◊ê◊ô◊ö ◊©◊î◊™◊ú◊ë◊©/◊î', '◊î◊ê◊†◊®◊í◊ô◊î', '◊û◊©◊î◊ï ◊ê◊ó◊®'],
  },
  {
    id: 'past_2',
    category: 'past',
    text: '◊û◊î ◊ó◊©◊ë◊™◊ô ◊ê◊ó◊®◊ô ◊î◊ì◊ô◊ô◊ò ◊î◊®◊ê◊©◊ï◊ü?',
    options: ['◊®◊ï◊¶◊î ◊¢◊ï◊ì', '◊ú◊ê ◊ë◊ò◊ï◊ó/◊î', '◊ñ◊î ◊î◊ê◊ó◊ì/◊™', '◊ó◊ë◊®/◊î ◊ò◊ï◊ë/◊î', '◊û◊ó◊® ◊†◊®◊ê◊î', '◊ï◊ï◊ê◊ï'],
  },
  {
    id: 'past_3',
    category: 'past',
    text: '◊õ◊û◊î ◊ñ◊û◊ü ◊ú◊ß◊ó ◊ú◊ô ◊ú◊î◊ë◊ô◊ü ◊©◊ñ◊î ◊®◊¶◊ô◊†◊ô?',
    options: ['◊û◊ô◊ô◊ì◊ô', '◊©◊ë◊ï◊¢◊ï◊™', '◊ó◊ï◊ì◊©◊ô◊ù', '◊©◊†◊î', '◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊ë◊ò◊ï◊ó/◊î', '◊î◊ù ◊î◊ë◊ô◊†◊ï ◊ß◊ï◊ì◊ù'],
  },
  {
    id: 'past_4',
    category: 'past',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊õ◊ô ◊û◊ë◊ô◊ö ◊©◊ß◊®◊î ◊ú◊†◊ï ◊ë◊î◊™◊ó◊ú◊î?',
    options: ['◊û◊©◊î◊ï ◊©◊ê◊û◊®◊™◊ô', '◊û◊¢◊ô◊ì◊î ◊§◊ô◊ñ◊ô◊™', '◊û◊§◊í◊© ◊¢◊ù ◊î◊ï◊®◊ô◊ù', '◊û◊©◊î◊ï ◊ë◊û◊ô◊ò◊î', '◊©◊™◊ô◊ß◊î ◊û◊ë◊ô◊õ◊î', '◊ú◊ê ◊î◊ô◊î'],
  },
  {
    id: 'past_5',
    category: 'past',
    text: '◊¢◊ú ◊û◊î ◊î◊ô◊î ◊î◊®◊ô◊ë ◊î◊®◊ê◊©◊ï◊ü ◊©◊ú◊†◊ï?',
    options: ['◊ß◊†◊ê◊î', '◊ñ◊û◊ü', '◊ó◊ë◊®◊ô◊ù', '◊û◊©◊§◊ó◊î', '◊™◊ß◊©◊ï◊®◊™', '◊ú◊ê ◊ñ◊ï◊õ◊®/◊™'],
  },
  {
    id: 'past_6',
    category: 'past',
    text: '◊û◊î ◊¢◊©◊ô◊™ ◊©◊í◊®◊ù ◊ú◊ô ◊ú◊î◊™◊ê◊î◊ë?',
    options: ['◊î◊ï◊û◊ï◊®', '◊™◊©◊ï◊û◊™ ◊ú◊ë', '◊ë◊ô◊ò◊ó◊ï◊ü', '◊§◊í◊ô◊¢◊ï◊™', '◊î◊§◊™◊¢◊ï◊™', '◊§◊©◊ï◊ò ◊ú◊î◊ô◊ï◊™'],
  },
  {
    id: 'past_7',
    category: 'past',
    text: '◊ê◊ô◊§◊î ◊î◊ô◊ô◊†◊ï ◊ë◊†◊©◊ô◊ß◊î ◊î◊®◊ê◊©◊ï◊†◊î?',
    options: ['◊ë◊ë◊ô◊™', '◊ë◊®◊ó◊ï◊ë', '◊ë◊û◊õ◊ï◊†◊ô◊™', '◊ë◊û◊°◊¢◊ì◊î/◊ë◊®', '◊ë◊ò◊ë◊¢', '◊ú◊ê ◊ñ◊ï◊õ◊®/◊™'],
  },
  {
    id: 'past_8',
    category: 'past',
    text: '◊ê◊ô◊ö ◊î◊®◊í◊©◊™◊ô ◊õ◊©◊î◊õ◊®◊™◊ô ◊ê◊™ ◊î◊î◊ï◊®◊ô◊ù ◊©◊ú◊ö?',
    options: ['◊ú◊ó◊ï◊•/◊î ◊û◊ê◊ï◊ì', '◊ë◊ò◊ï◊ó/◊î', '◊®◊¶◊ô◊™◊ô ◊ú◊î◊®◊©◊ô◊ù', '◊ú◊ê ◊ê◊õ◊§◊™ ◊ú◊ô', '◊§◊ó◊ì◊™◊ô', '◊†◊î◊†◊ô◊™◊ô'],
  },
  {
    id: 'past_9',
    category: 'past',
    text: '◊û◊™◊ô ◊ê◊û◊®◊†◊ï "◊ê◊†◊ô ◊ê◊ï◊î◊ë ◊ê◊ï◊™◊ö" ◊ú◊®◊ê◊©◊ï◊†◊î?',
    options: ['◊ê◊ó◊®◊ô ◊©◊ë◊ï◊¢◊ï◊™', '◊ê◊ó◊®◊ô ◊ó◊ï◊ì◊©◊ô◊ù', '◊ê◊ó◊®◊ô ◊ó◊¶◊ô ◊©◊†◊î', '◊ê◊ó◊®◊ô ◊©◊†◊î', '◊î◊ù ◊ß◊ï◊ì◊ù', '◊ë◊ê◊ï◊™◊ï ◊®◊í◊¢'],
  },
  {
    id: 'past_10',
    category: 'past',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊©◊î◊õ◊ô ◊î◊§◊™◊ô◊¢ ◊ê◊ï◊™◊ô ◊ë◊ö ◊ë◊î◊™◊ó◊ú◊î?',
    options: ['◊¢◊ï◊û◊ß', '◊î◊ï◊û◊ï◊®', '◊®◊í◊ô◊©◊ï◊™', '◊ë◊ô◊ò◊ó◊ï◊ü', '◊ó◊ï◊°◊® ◊ë◊ô◊ò◊ó◊ï◊ü', '◊û◊©◊î◊ï ◊§◊ô◊ñ◊ô'],
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊ô◊ï◊û◊ô◊ï◊ù - 10 ◊©◊ê◊ú◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'daily_1',
    category: 'daily',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊®◊ê◊©◊ï◊ü ◊©◊ê◊†◊ô ◊¢◊ï◊©◊î ◊ë◊ë◊ï◊ß◊®?',
    options: ['◊ò◊ú◊§◊ï◊ü', '◊©◊ô◊®◊ï◊™◊ô◊ù', '◊ß◊§◊î', '◊û◊™◊ô◊ó◊ï◊™', '◊ú◊†◊©◊ß ◊ê◊ï◊™◊ö', '◊ú◊î◊û◊©◊ô◊ö ◊ú◊ô◊©◊ï◊ü'],
  },
  {
    id: 'daily_2',
    category: 'daily',
    text: '◊û◊î ◊û◊®◊í◊ô◊ñ ◊ê◊ï◊™◊ô ◊î◊õ◊ô ◊î◊®◊ë◊î ◊ë◊ë◊ô◊™?',
    options: ['◊ê◊ô ◊°◊ì◊®', '◊®◊¢◊©', '◊õ◊ú◊ô◊ù', '◊ò◊û◊§◊®◊ò◊ï◊®◊î', '◊ó◊ï◊°◊® ◊§◊®◊ò◊ô◊ï◊™', '◊õ◊ú◊ï◊ù'],
  },
  {
    id: 'daily_3',
    category: 'daily',
    text: '◊ê◊ô◊ö ◊ê◊†◊ô ◊û◊™◊û◊ï◊ì◊ì/◊™ ◊¢◊ù ◊ú◊ó◊•?',
    options: ['◊ê◊ï◊õ◊ú', '◊©◊ß◊ò', '◊û◊ì◊ë◊®/◊™', '◊°◊§◊ï◊®◊ò', '◊ò◊ú◊ï◊ï◊ô◊ñ◊ô◊î', '◊©◊ô◊†◊î'],
  },
  {
    id: 'daily_4',
    category: 'daily',
    text: '◊û◊î ◊ê◊†◊ô ◊î◊õ◊ô ◊ê◊ï◊î◊ë ◊ú◊¢◊©◊ï◊™ ◊ë◊¢◊®◊ë ◊ó◊ï◊§◊©◊ô?',
    options: ['◊†◊ò◊§◊ú◊ô◊ß◊°', '◊û◊°◊¢◊ì◊î', '◊ó◊ë◊®◊ô◊ù', '◊ú◊ß◊®◊ï◊ê', '◊°◊ß◊°', '◊õ◊ú◊ï◊ù'],
  },
  {
    id: 'daily_5',
    category: 'daily',
    text: '◊õ◊û◊î ◊ñ◊û◊ü ◊ê◊†◊ô ◊ë◊ò◊ú◊§◊ï◊ü ◊ë◊ô◊ï◊ù?',
    options: ['◊§◊ó◊ï◊™ ◊û◊©◊¢◊î', '1-2 ◊©◊¢◊ï◊™', '2-4 ◊©◊¢◊ï◊™', '4-6 ◊©◊¢◊ï◊™', '◊ô◊ï◊™◊®', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'daily_6',
    category: 'daily',
    text: '◊û◊î ◊ê◊†◊ô ◊©◊ï◊†◊ê ◊ú◊¢◊©◊ï◊™ ◊ë◊ë◊ô◊™?',
    options: ['◊ú◊†◊ß◊ï◊™', '◊ú◊ë◊©◊ú', '◊ú◊°◊ì◊®', '◊õ◊ë◊ô◊°◊î', '◊ß◊†◊ô◊ï◊™', '◊î◊õ◊ú'],
  },
  {
    id: 'daily_7',
    category: 'daily',
    text: '◊ê◊ô◊ñ◊î ◊¶◊ì ◊û◊ô◊ò◊î ◊ê◊†◊ô ◊û◊¢◊ì◊ô◊£/◊î?',
    options: ['◊ô◊û◊ô◊ü', '◊©◊û◊ê◊ú', '◊ú◊ê ◊û◊©◊†◊î', '◊î◊õ◊ô ◊ß◊®◊ï◊ë ◊ú◊ì◊ú◊™', '◊î◊õ◊ô ◊®◊ó◊ï◊ß', '◊ë◊ê◊û◊¶◊¢'],
  },
  {
    id: 'daily_8',
    category: 'daily',
    text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊©◊î ◊õ◊©◊ê◊†◊ô ◊¢◊¶◊ë◊†◊ô/◊™?',
    options: ['◊©◊ï◊™◊ß/◊™', '◊¶◊ï◊¢◊ß/◊™', '◊ô◊ï◊¶◊ê/◊™', '◊ë◊ï◊õ◊î', '◊ê◊ï◊õ◊ú/◊™', '◊ô◊©◊ü/◊î'],
  },
  {
    id: 'daily_9',
    category: 'daily',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊®◊ê◊©◊ï◊ü ◊©◊ê◊†◊ô ◊¢◊ï◊©◊î ◊õ◊©◊ê◊†◊ô ◊ó◊ï◊ñ◊®/◊™ ◊î◊ë◊ô◊™◊î?',
    options: ['◊†◊¢◊ú◊ô◊ô◊ù', '◊ê◊ï◊õ◊ú', '◊û◊ß◊ú◊ó◊™', '◊ò◊ú◊§◊ï◊ü', '◊ó◊ô◊ë◊ï◊ß', '◊°◊§◊î'],
  },
  {
    id: 'daily_10',
    category: 'daily',
    text: '◊û◊î ◊î◊î◊®◊í◊ú ◊î◊õ◊ô ◊û◊ï◊ñ◊® ◊©◊ú◊ô?',
    options: ['◊ê◊ï◊õ◊ú', '◊©◊ô◊†◊î', '◊†◊ô◊ß◊ô◊ï◊ü', '◊ò◊ú◊§◊ï◊ü', '◊ê◊ô◊ü ◊ú◊ô', '◊ú◊ê ◊†◊í◊ô◊ì'],
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊ó◊ú◊ï◊û◊ï◊™ - 10 ◊©◊ê◊ú◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'dreams_1',
    category: 'dreams',
    text: '◊ê◊ô◊§◊î ◊ê◊†◊ô ◊®◊ï◊¶◊î ◊ú◊í◊ï◊® ◊ë◊¢◊ï◊ì 10 ◊©◊†◊ô◊ù?',
    options: ['◊§◊î', '◊ó◊ï"◊ú', '◊õ◊§◊®', '◊¢◊ô◊® ◊í◊ì◊ï◊ú◊î', '◊ú◊ô◊ì ◊ô◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dreams_2',
    category: 'dreams',
    text: '◊û◊î ◊î◊§◊ó◊ì ◊î◊õ◊ô ◊í◊ì◊ï◊ú ◊©◊ú◊ô ◊ú◊í◊ë◊ô ◊î◊¢◊™◊ô◊ì?',
    options: ['◊ë◊®◊ô◊ê◊ï◊™', '◊õ◊°◊£', '◊ë◊ì◊ô◊ì◊ï◊™', '◊ú◊î◊ô◊§◊®◊ì', '◊ú◊î◊™◊ê◊õ◊ñ◊ë', '◊ê◊ô◊ü ◊§◊ó◊ì◊ô◊ù'],
  },
  {
    id: 'dreams_3',
    category: 'dreams',
    text: '◊õ◊û◊î ◊ô◊ú◊ì◊ô◊ù ◊ê◊†◊ô ◊®◊ï◊¶◊î (◊ê◊ï ◊®◊¶◊ô◊™◊ô)?',
    options: ['0', '1', '2', '3', '4+', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dreams_4',
    category: 'dreams',
    text: '◊ê◊ù ◊ê◊ñ◊õ◊î ◊ë◊ú◊ï◊ò◊ï - ◊û◊î ◊ê◊¢◊©◊î ◊®◊ê◊©◊ï◊ü?',
    options: ['◊ê◊§◊°◊ô◊ß ◊ú◊¢◊ë◊ï◊ì', '◊ê◊ß◊†◊î ◊ë◊ô◊™', '◊ê◊ò◊ô◊ô◊ú', '◊ê◊™◊ü ◊ú◊î◊ï◊®◊ô◊ù', '◊ê◊©◊ß◊ô◊¢', '◊ê◊û◊©◊ô◊ö ◊õ◊®◊í◊ô◊ú'],
  },
  {
    id: 'dreams_5',
    category: 'dreams',
    text: '◊û◊î ◊î◊¢◊ë◊ï◊ì◊î ◊î◊ê◊ô◊ì◊ô◊ê◊ú◊ô◊™ ◊©◊ú◊ô?',
    options: ['◊û◊î ◊©◊ê◊†◊ô ◊¢◊ï◊©◊î', '◊¢◊¶◊û◊ê◊ô', '◊ú◊ê ◊ú◊¢◊ë◊ï◊ì', '◊ô◊¶◊ô◊®◊™◊ô', '◊¢◊ñ◊®◊î ◊ú◊ê◊ó◊®◊ô◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dreams_6',
    category: 'dreams',
    text: '◊ë◊ê◊ô◊ñ◊î ◊í◊ô◊ú ◊ê◊†◊ô ◊®◊ï◊¶◊î ◊ú◊§◊®◊ï◊©?',
    options: ['45', '50', '55', '60', '67', '◊ú◊¢◊ï◊ú◊ù ◊ú◊ê'],
  },
  {
    id: 'dreams_7',
    category: 'dreams',
    text: '◊ú◊ê◊ü ◊î◊ô◊ô◊™◊ô ◊®◊ï◊¶◊î ◊ú◊ò◊ô◊ô◊ú ◊î◊õ◊ô?',
    options: ['◊ô◊§◊ü', '◊ê◊ô◊ò◊ú◊ô◊î', '◊ê◊®◊î"◊ë', '◊ì◊®◊ï◊ù ◊ê◊û◊®◊ô◊ß◊î', '◊ê◊ï◊°◊ò◊®◊ú◊ô◊î', '◊ê◊§◊®◊ô◊ß◊î'],
  },
  {
    id: 'dreams_8',
    category: 'dreams',
    text: '◊û◊î ◊ê◊†◊ô ◊û◊ß◊ï◊ï◊î ◊©◊†◊¢◊©◊î ◊ë◊ô◊ó◊ì ◊ë◊¢◊™◊ô◊ì?',
    options: ['◊ú◊ò◊ô◊ô◊ú', '◊ú◊í◊ì◊ú ◊û◊©◊§◊ó◊î', '◊ú◊ë◊†◊ï◊™ ◊ë◊ô◊™', '◊ú◊§◊™◊ï◊ó ◊¢◊°◊ß', '◊ú◊§◊®◊ï◊© ◊ë◊ô◊ó◊ì', '◊î◊õ◊ú'],
  },
  {
    id: 'dreams_9',
    category: 'dreams',
    text: '◊û◊î ◊î◊§◊ó◊ì ◊©◊ú◊ô ◊ú◊í◊ë◊ô ◊î◊ñ◊ï◊í◊ô◊ï◊™?',
    options: ['◊©◊¢◊û◊ï◊ù', '◊ë◊í◊ô◊ì◊î', '◊ú◊î◊™◊®◊ó◊ß', '◊ô◊ú◊ì◊ô◊ù', '◊õ◊°◊£', '◊ê◊ô◊ü'],
  },
  {
    id: 'dreams_10',
    category: 'dreams',
    text: '◊ê◊ù ◊î◊ô◊ô◊™◊ô ◊ô◊õ◊ï◊ú/◊î ◊ú◊©◊†◊ï◊™ ◊û◊ß◊¶◊ï◊¢ - ◊ú◊û◊î ◊î◊ô◊ô◊™◊ô ◊¢◊ï◊ë◊®/◊™?',
    options: ['◊ê◊û◊†◊ï◊™', '◊î◊ô◊ô◊ò◊ß', '◊®◊§◊ï◊ê◊î', '◊ó◊ô◊†◊ï◊ö', '◊û◊©◊î◊ï ◊§◊ô◊ñ◊ô', '◊î◊ô◊ô◊™◊ô ◊†◊©◊ê◊®/◊™'],
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™ - 10 ◊©◊ê◊ú◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'intimacy_1',
    category: 'intimacy',
    text: '◊û◊î ◊î◊õ◊ô ◊û◊ì◊ú◊ô◊ß ◊ê◊ï◊™◊ô?',
    options: ['◊†◊í◊ô◊¢◊î', '◊û◊ô◊ú◊ô◊ù', '◊û◊®◊ê◊î', '◊®◊ô◊ó', '◊ê◊ï◊ï◊ô◊®◊î', '◊î◊§◊™◊¢◊ï◊™'],
  },
  {
    id: 'intimacy_2',
    category: 'intimacy',
    text: '◊ë◊ê◊ô◊ñ◊ï ◊™◊ì◊ô◊®◊ï◊™ ◊ê◊†◊ô ◊®◊ï◊¶◊î ◊°◊ß◊° (◊ê◊ô◊ì◊ô◊ê◊ú◊ô)?',
    options: ['◊õ◊ú ◊ô◊ï◊ù', '◊õ◊û◊î ◊§◊¢◊û◊ô◊ù ◊ë◊©◊ë◊ï◊¢', '◊§◊¢◊ù ◊ë◊©◊ë◊ï◊¢', '◊õ◊û◊î ◊ë◊ó◊ï◊ì◊©', '◊ú◊ê ◊û◊©◊†◊î', '◊§◊ó◊ï◊™'],
  },
  {
    id: 'intimacy_3',
    category: 'intimacy',
    text: '◊û◊î ◊î◊õ◊ô ◊ó◊©◊ï◊ë ◊ú◊ô ◊ë◊°◊ß◊°?',
    options: ['◊™◊©◊ï◊ß◊î', '◊ó◊ô◊ë◊ï◊® ◊®◊í◊©◊ô', '◊ó◊ô◊ì◊ï◊©', '◊î◊†◊ê◊î ◊§◊ô◊ñ◊ô◊™', '◊ê◊ï◊®◊í◊ñ◊û◊î', '◊î◊õ◊ú'],
  },
  {
    id: 'intimacy_4',
    category: 'intimacy',
    text: '◊û◊™◊ô ◊ê◊†◊ô ◊î◊õ◊ô ◊®◊ï◊¶◊î?',
    options: ['◊ë◊ï◊ß◊®', '◊¶◊î◊®◊ô◊ô◊ù', '◊¢◊®◊ë', '◊ú◊ô◊ú◊î ◊û◊ê◊ï◊ó◊®', '◊°◊ï◊£ ◊©◊ë◊ï◊¢', '◊™◊û◊ô◊ì'],
  },
  {
    id: 'intimacy_5',
    category: 'intimacy',
    text: '◊ê◊ô◊ñ◊î ◊ó◊ú◊ß ◊ë◊í◊ï◊£ ◊ê◊†◊ô ◊î◊õ◊ô ◊ê◊ï◊î◊ë/◊™ ◊©◊†◊ï◊í◊¢◊ô◊ù ◊ë◊ï?',
    options: ['◊¶◊ï◊ï◊ê◊®', '◊í◊ë', '◊ô◊ì◊ô◊ô◊ù', '◊®◊í◊ú◊ô◊ô◊ù', '◊§◊†◊ô◊ù', '◊û◊ß◊ï◊ù ◊ê◊ó◊®'],
  },
  {
    id: 'intimacy_6',
    category: 'intimacy',
    text: '◊û◊î ◊û◊§◊®◊ô◊¢ ◊ú◊ô ◊ë◊û◊ô◊ò◊î?',
    options: ['◊®◊¢◊©', '◊ê◊ï◊®', '◊ó◊ï◊ù', '◊ß◊ï◊®', '◊ò◊ú◊§◊ï◊ü', '◊õ◊ú◊ï◊ù'],
  },
  {
    id: 'intimacy_7',
    category: 'intimacy',
    text: '◊û◊î ◊ê◊†◊ô ◊ê◊ï◊î◊ë/◊™ ◊©◊ê◊ï◊û◊®◊ô◊ù ◊ú◊ô ◊ë◊û◊ô◊ò◊î?',
    options: ['◊û◊ó◊û◊ê◊ï◊™', '◊î◊†◊ó◊ô◊ï◊™', '◊©◊ß◊ò', '◊©◊ù ◊©◊ú◊ô', '◊û◊ô◊ú◊ô◊ù ◊ë◊ï◊ò◊ï◊™', '◊î◊õ◊ú'],
  },
  {
    id: 'intimacy_8',
    category: 'intimacy',
    text: '◊û◊î ◊î◊ô◊ô◊™◊ô ◊®◊ï◊¶◊î ◊ú◊†◊°◊ï◊™?',
    options: ['◊û◊ß◊ï◊ù ◊ó◊ì◊©', '◊™◊†◊ï◊ó◊î ◊ó◊ì◊©◊î', '◊¶◊¢◊¶◊ï◊¢◊ô◊ù', '◊û◊©◊ó◊ß ◊™◊§◊ß◊ô◊ì◊ô◊ù', '◊õ◊ú◊ï◊ù ◊ó◊ì◊©', '◊ú◊ê ◊ê◊í◊ô◊ì'],
  },
  {
    id: 'intimacy_9',
    category: 'intimacy',
    text: '◊û◊î ◊ê◊†◊ô ◊û◊®◊í◊ô◊©/◊î ◊ê◊ó◊®◊ô ◊°◊ß◊° ◊ò◊ï◊ë?',
    options: ['◊û◊ê◊ï◊©◊®/◊™', '◊®◊í◊ï◊¢/◊î', '◊û◊ó◊ï◊ë◊®/◊™', '◊¢◊ô◊ô◊£/◊î', '◊®◊¢◊ë/◊î', '◊®◊ï◊¶◊î ◊¢◊ï◊ì'],
  },
  {
    id: 'intimacy_10',
    category: 'intimacy',
    text: '◊û◊î ◊î◊§◊†◊ò◊ñ◊ô◊î ◊©◊ú◊ô?',
    options: ['◊©◊ú◊ô◊ò◊î', '◊õ◊†◊ô◊¢◊î', '◊¶◊ô◊ë◊ï◊®◊ô', '◊ñ◊®/◊î', '◊ê◊ô◊ü ◊ú◊ô', '◊ú◊ê ◊ê◊í◊ô◊ì'],
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊ì◊ô◊ú◊û◊ï◊™ - 10 ◊©◊ê◊ú◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'dilemmas_1',
    category: 'dilemmas',
    text: '◊ß◊®◊ô◊ô◊®◊î ◊û◊ë◊®◊ô◊ß◊î ◊ê◊ï ◊ô◊ï◊™◊® ◊ñ◊û◊ü ◊ë◊ô◊ó◊ì?',
    options: ['◊ß◊®◊ô◊ô◊®◊î', '◊ñ◊û◊ü ◊ë◊ô◊ó◊ì', '◊ê◊ô◊ñ◊ï◊ü', '◊™◊ú◊ï◊ô ◊ë◊™◊ß◊ï◊§◊î', '◊©◊†◊ô◊î◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dilemmas_2',
    category: 'dilemmas',
    text: '◊ú◊ì◊¢◊™ ◊¢◊ú ◊ë◊í◊ô◊ì◊î ◊ê◊ï ◊ú◊ê ◊ú◊ì◊¢◊™?',
    options: ['◊ú◊ì◊¢◊™', '◊ú◊ê ◊ú◊ì◊¢◊™', '◊™◊ú◊ï◊ô', '◊®◊ß ◊ê◊ù ◊†◊í◊û◊®', '◊ê◊ô◊ü ◊™◊©◊ï◊ë◊î', '◊ú◊ê ◊ô◊ß◊®◊î'],
  },
  {
    id: 'dilemmas_3',
    category: 'dilemmas',
    text: '◊ú◊¢◊ë◊ï◊® ◊ú◊¢◊ô◊® ◊ê◊ó◊®◊™ ◊ë◊©◊ë◊ô◊ú ◊î◊¢◊ë◊ï◊ì◊î ◊©◊ú◊ö?',
    options: ['◊ë◊ï◊ï◊ì◊ê◊ï◊™', '◊õ◊†◊®◊ê◊î ◊©◊õ◊ü', '◊™◊ú◊ï◊ô ◊ú◊ê◊ü', '◊õ◊†◊®◊ê◊î ◊©◊ú◊ê', '◊ë◊©◊ï◊ù ◊§◊†◊ô◊ù', '◊®◊ß ◊ê◊ù...'],
  },
  {
    id: 'dilemmas_4',
    category: 'dilemmas',
    text: '◊©◊ß◊® ◊ß◊ò◊ü ◊ê◊ï ◊ê◊û◊™ ◊õ◊ï◊ê◊ë◊™?',
    options: ['◊©◊ß◊® ◊ß◊ò◊ü', '◊ê◊û◊™ ◊õ◊ï◊ê◊ë◊™', '◊™◊ú◊ï◊ô', '◊©◊†◊ô◊î◊ù ◊†◊ï◊®◊ê◊ô◊ù', '◊™◊û◊ô◊ì ◊ê◊û◊™', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dilemmas_5',
    category: 'dilemmas',
    text: '◊ú◊©◊†◊ï◊™ ◊ì◊ë◊® ◊ê◊ó◊ì ◊ë◊ô - ◊û◊î ◊ñ◊î ◊ô◊î◊ô◊î?',
    options: ['◊õ◊ú◊ï◊ù', '◊î◊®◊í◊ú◊ô◊ù', '◊™◊ß◊©◊ï◊®◊™', '◊û◊©◊î◊ï ◊§◊ô◊ñ◊ô', '◊õ◊°◊£', '◊ê◊ï◊§◊ô'],
  },
  {
    id: 'dilemmas_6',
    category: 'dilemmas',
    text: '◊®◊ô◊ë ◊í◊ì◊ï◊ú ◊§◊¢◊ù ◊ë◊ó◊ï◊ì◊© ◊ê◊ï ◊®◊ô◊ë◊ô◊ù ◊ß◊ò◊†◊ô◊ù ◊õ◊ú ◊ô◊ï◊ù?',
    options: ['◊®◊ô◊ë ◊í◊ì◊ï◊ú', '◊®◊ô◊ë◊ô◊ù ◊ß◊ò◊†◊ô◊ù', '◊©◊†◊ô◊î◊ù ◊†◊ï◊®◊ê◊ô◊ù', '◊™◊ú◊ï◊ô', '◊ê◊ô◊ü ◊®◊ô◊ë◊ô◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dilemmas_7',
    category: 'dilemmas',
    text: '◊ú◊ï◊ï◊™◊® ◊¢◊ú ◊ß◊®◊ô◊ô◊®◊î ◊ë◊©◊ë◊ô◊ú ◊î◊ñ◊ï◊í◊ô◊ï◊™?',
    options: ['◊õ◊ü', '◊ú◊ê', '◊™◊ú◊ï◊ô', '◊õ◊ë◊® ◊¢◊©◊ô◊™◊ô', '◊ú◊ê ◊®◊ú◊ï◊ï◊†◊ò◊ô', '◊î◊ù ◊ô◊ï◊ï◊™◊®◊ï'],
  },
  {
    id: 'dilemmas_8',
    category: 'dilemmas',
    text: '◊õ◊†◊ï◊™ ◊û◊ï◊ó◊ú◊ò◊™ ◊ê◊ï ◊©◊û◊ô◊®◊î ◊¢◊ú ◊®◊í◊©◊ï◊™?',
    options: ['◊õ◊†◊ï◊™', '◊®◊í◊©◊ï◊™', '◊ê◊ô◊ñ◊ï◊ü', '◊™◊ú◊ï◊ô', '◊©◊†◊ô◊î◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'dilemmas_9',
    category: 'dilemmas',
    text: '◊ñ◊ï◊í◊ô◊ï◊™ ◊§◊™◊ï◊ó◊î - ◊õ◊ü ◊ê◊ï ◊ú◊ê?',
    options: ['◊ë◊©◊ï◊ù ◊§◊†◊ô◊ù', '◊ê◊ï◊ú◊ô', '◊õ◊ü', '◊™◊ú◊ï◊ô ◊ë◊õ◊ú◊ú◊ô◊ù', '◊ú◊ê ◊ë◊ò◊ï◊ó/◊î', '◊†◊ô◊°◊ô◊†◊ï'],
  },
  {
    id: 'dilemmas_10',
    category: 'dilemmas',
    text: '◊ú◊í◊ï◊® ◊ß◊®◊ï◊ë ◊ú◊î◊ï◊®◊ô◊ù ◊ê◊ï ◊®◊ó◊ï◊ß?',
    options: ['◊ß◊®◊ï◊ë', '◊®◊ó◊ï◊ß', '◊ë◊ê◊ï◊™◊î ◊¢◊ô◊®', '◊ë◊ó◊ï"◊ú', '◊ú◊ê ◊û◊©◊†◊î', '◊™◊ú◊ï◊ô ◊ë◊ê◊ô◊ñ◊î'],
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊ê◊†◊ó◊†◊ï - 10 ◊©◊ê◊ú◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'us_1',
    category: 'us',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊î◊õ◊ô ◊ò◊ï◊ë ◊ë◊ñ◊ï◊í◊ô◊ï◊™ ◊©◊ú◊†◊ï?',
    options: ['◊™◊ß◊©◊ï◊®◊™', '◊¶◊ó◊ï◊ß', '◊°◊ß◊°', '◊ë◊ô◊ò◊ó◊ï◊ü', '◊ó◊ë◊®◊ï◊™', '◊î◊õ◊ú'],
  },
  {
    id: 'us_2',
    category: 'us',
    text: '◊û◊î ◊î◊õ◊ô ◊¶◊®◊ô◊ö ◊ú◊©◊§◊®?',
    options: ['◊™◊ß◊©◊ï◊®◊™', '◊ñ◊û◊ü ◊ê◊ô◊õ◊ï◊™', '◊°◊ß◊°', '◊ó◊ú◊ï◊ß◊™ ◊¢◊ë◊ï◊ì◊ï◊™', '◊õ◊°◊£', '◊õ◊ú◊ï◊ù'],
  },
  {
    id: 'us_3',
    category: 'us',
    text: '◊û◊ô ◊û◊ê◊ô◊™◊†◊ï ◊ô◊ï◊™◊® ◊®◊ï◊û◊†◊ò◊ô/◊™?',
    options: ['◊ê◊†◊ô', '◊ë◊ü/◊ë◊™ ◊î◊ñ◊ï◊í', '◊©◊†◊ô◊†◊ï', '◊ê◊£ ◊ê◊ó◊ì', '◊™◊ú◊ï◊ô ◊ë◊ô◊ï◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'us_4',
    category: 'us',
    text: '◊û◊ô ◊û◊ê◊ô◊™◊†◊ï ◊ô◊ï◊™◊® ◊ß◊†◊ê◊ô/◊™?',
    options: ['◊ê◊†◊ô', '◊ë◊ü/◊ë◊™ ◊î◊ñ◊ï◊í', '◊©◊†◊ô◊†◊ï', '◊ê◊£ ◊ê◊ó◊ì', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™', '◊™◊ú◊ï◊ô ◊ë◊û◊¶◊ë'],
  },
  {
    id: 'us_5',
    category: 'us',
    text: '◊û◊î ◊î◊°◊ô◊õ◊ï◊ô ◊©◊†◊î◊ô◊î ◊ë◊ô◊ó◊ì ◊¢◊ï◊ì 10 ◊©◊†◊ô◊ù?',
    options: ['100%', '◊í◊ë◊ï◊î ◊û◊ê◊ï◊ì', '◊í◊ë◊ï◊î', '◊ë◊ô◊†◊ï◊†◊ô', '◊û◊ô ◊ô◊ï◊ì◊¢', '◊ú◊ê ◊ó◊ï◊©◊ë/◊™'],
  },
  {
    id: 'us_6',
    category: 'us',
    text: '◊û◊î ◊î◊®◊í◊¢ ◊î◊õ◊ô ◊ò◊ï◊ë ◊©◊î◊ô◊î ◊ú◊†◊ï?',
    options: ['◊ò◊ô◊ï◊ú', '◊ó◊™◊ï◊†◊î', '◊ú◊ô◊ì◊î', '◊ô◊ï◊ù ◊®◊í◊ô◊ú', '◊î◊õ◊®◊ï◊™', '◊ê◊ó◊®'],
  },
  {
    id: 'us_7',
    category: 'us',
    text: '◊õ◊û◊î ◊§◊¢◊û◊ô◊ù ◊ë◊©◊ë◊ï◊¢ ◊ê◊†◊ó◊†◊ï ◊¶◊®◊ô◊õ◊ô◊ù "◊ñ◊û◊ü ◊ê◊ô◊õ◊ï◊™"?',
    options: ['◊õ◊ú ◊ô◊ï◊ù', '3-4', '1-2', '◊§◊¢◊ù', '◊õ◊©◊ô◊ï◊¶◊ê', '◊ú◊ê ◊û◊°◊§◊ô◊ß'],
  },
  {
    id: 'us_8',
    category: 'us',
    text: '◊û◊î ◊î◊ì◊ë◊® ◊©◊î◊õ◊ô ◊û◊ó◊ë◊® ◊ê◊ï◊™◊†◊ï?',
    options: ['◊î◊ï◊û◊ï◊®', '◊¢◊®◊õ◊ô◊ù', '◊ô◊ú◊ì◊ô◊ù', '◊°◊ß◊°', '◊©◊í◊®◊î', '◊î◊õ◊ú'],
  },
  {
    id: 'us_9',
    category: 'us',
    text: '◊ê◊ô◊ö ◊ê◊†◊ó◊†◊ï ◊†◊®◊ê◊ô◊ù ◊û◊ë◊ó◊ï◊•?',
    options: ['◊ñ◊ï◊í ◊û◊ï◊©◊ú◊ù', '◊ñ◊ï◊í ◊®◊í◊ô◊ú', '◊ñ◊ï◊í ◊û◊ï◊ñ◊®', '◊û◊ê◊ï◊î◊ë◊ô◊ù', '◊¢◊ô◊ô◊§◊ô◊ù', '◊ú◊ê ◊ô◊ï◊ì◊¢/◊™'],
  },
  {
    id: 'us_10',
    category: 'us',
    text: '◊ê◊ô◊ö ◊î◊ô◊ô◊™◊ô ◊û◊™◊ê◊®/◊™ ◊ê◊ï◊™◊ö ◊ú◊ó◊ë◊®/◊î?',
    options: ['◊û◊ì◊î◊ô◊ù/◊î', '◊ò◊ï◊ë/◊î', '◊û◊°◊ï◊ë◊ö/◊™', '◊û◊¶◊ó◊ô◊ß/◊î', '◊®◊¶◊ô◊†◊ô/◊™', '◊î◊õ◊ú'],
  },
];

// ◊§◊ï◊†◊ß◊¶◊ô◊ï◊™ ◊¢◊ñ◊®
export const getQuizQuestionsForGame = (): QuizQuestion[] => {
  const categories: QuizCategory[] = ['past', 'daily', 'dreams', 'intimacy', 'dilemmas', 'us'];
  const selected: QuizQuestion[] = [];

  categories.forEach((cat) => {
    const catQuestions = quizQuestions.filter((q) => q.category === cat);
    const shuffled = [...catQuestions].sort(() => Math.random() - 0.5);
    selected.push(...shuffled.slice(0, 4)); // 4 ◊û◊õ◊ú ◊ß◊ò◊í◊ï◊®◊ô◊î
  });

  return selected.sort(() => Math.random() - 0.5);
};

export const getQuizQuestionById = (id: string): QuizQuestion | undefined => {
  return quizQuestions.find((q) => q.id === id);
};

--------------------------------------------------------------------------------
FILE: src/data/tasks.ts
--------------------------------------------------------------------------------

/**
 * ◊û◊©◊ô◊û◊ï◊™ - ◊í◊®◊°◊î ◊û◊©◊û◊¢◊ï◊™◊ô◊™
 *
 * ◊õ◊ú ◊û◊©◊ô◊û◊î ◊ó◊ô◊ô◊ë◊™ ◊ú◊î◊ô◊ï◊™:
 * 1. ◊ú◊ê ◊ò◊®◊ô◊ï◊ï◊ô◊ê◊ú◊ô◊™ (◊ú◊ê "◊ó◊ë◊ß 20 ◊©◊†◊ô◊ï◊™")
 * 2. ◊ô◊ï◊¶◊®◊™ ◊®◊í◊¢ ◊©◊ú ◊ë◊ó◊ô◊®◊î ◊ê◊ï ◊§◊í◊ô◊¢◊ï◊™
 * 3. ◊ë◊ú◊™◊ô ◊†◊©◊õ◊ó◊™
 */

export interface Task {
  id: string;
  stage: number;
  difficulty: 1 | 2 | 3;
  text: string;
  textMale?: string;
  textFemale?: string;
  requiresConfirmation: boolean;
  intensity?: 'soft' | 'medium' | 'spicy';
}

export const tasks: Task[] = [
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 1 - "◊®◊í◊¢ ◊ú◊§◊†◊ô ◊©◊†◊§◊í◊©◊†◊ï"
  // 2-3 ◊û◊©◊ô◊û◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 't1_1',
    stage: 1,
    difficulty: 1,
    text: '◊§◊™◊ó ◊ê◊™ ◊î◊í◊ú◊®◊ô◊î ◊ë◊ò◊ú◊§◊ï◊ü, ◊û◊¶◊ê ◊™◊û◊ï◊†◊î ◊û◊ú◊§◊†◊ô ◊©◊î◊õ◊®◊™◊ù, ◊î◊®◊ê◊î ◊ú{partner} ◊ï◊°◊§◊® ◊û◊î ◊¢◊ë◊® ◊ú◊ö ◊ë◊®◊ê◊© ◊õ◊©◊¶◊ï◊ú◊û◊î.',
    requiresConfirmation: true,
  },
  {
    id: 't1_2',
    stage: 1,
    difficulty: 2,
    text: '◊™◊ê◊® ◊ú{partner} ◊ê◊™ ◊î◊®◊í◊¢ ◊î◊û◊ì◊ï◊ô◊ß ◊©◊ë◊ï ◊î◊ë◊†◊™ ◊©◊ê◊™◊î ◊†◊ï◊§◊ú. ◊ú◊ê "◊û◊™◊ô ◊î◊™◊ê◊î◊ë◊™" - ◊î◊®◊í◊¢ ◊¢◊¶◊û◊ï.',
    requiresConfirmation: true,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 2 - "◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™"
  // 5 ◊û◊©◊ô◊û◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 't2_1',
    stage: 2,
    difficulty: 1,
    text: '◊î◊°◊™◊õ◊ú◊ï ◊ê◊ó◊ì ◊ú◊©◊†◊ô◊ô◊î ◊ë◊¢◊ô◊†◊ô◊ô◊ù 60 ◊©◊†◊ô◊ï◊™ ◊û◊ú◊ê◊ï◊™. ◊ë◊ú◊ô ◊ú◊ì◊ë◊®, ◊ë◊ú◊ô ◊ú◊¶◊ó◊ï◊ß, ◊ë◊ú◊ô ◊ú◊î◊°◊™◊õ◊ú ◊î◊¶◊ô◊ì◊î. ◊û◊ô ◊©◊©◊ï◊ë◊® ◊ß◊ï◊ì◊ù - ◊©◊ï◊™◊î.',
    requiresConfirmation: true,
  },
  {
    id: 't2_2',
    stage: 2,
    difficulty: 1,
    text: '◊§◊™◊ó ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊ï◊™ ◊î◊ê◊ó◊®◊ï◊†◊ï◊™ ◊©◊ú◊ö ◊¢◊ù {partner}. ◊ß◊®◊ê ◊ë◊ß◊ï◊ú ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î ◊î◊ê◊ó◊®◊ï◊†◊î ◊©◊©◊ú◊ó◊™ ◊©◊î◊ô◊ê ◊ú◊ê ◊¢◊†◊ô◊ô◊†◊ô◊™.',
    requiresConfirmation: true,
  },
  {
    id: 't2_3',
    stage: 2,
    difficulty: 2,
    text: '◊™◊ü ◊ú{partner} ◊ú◊ë◊ó◊ï◊® ◊©◊ô◊®. ◊™◊®◊ß◊ì◊ï ◊ô◊ó◊ì ◊ê◊™ ◊õ◊ú ◊î◊©◊ô◊® - ◊í◊ù ◊ê◊ù ◊ñ◊î ◊û◊ë◊ô◊ö, ◊í◊ù ◊ê◊ù ◊ê◊™◊ù ◊ú◊ê ◊ô◊ï◊ì◊¢◊ô◊ù ◊ú◊®◊ß◊ï◊ì.',
    requiresConfirmation: true,
  },
  {
    id: 't2_4',
    stage: 2,
    difficulty: 2,
    text: '◊¶◊ú◊û◊ï ◊°◊ú◊§◊ô ◊ë◊ô◊ó◊ì ◊¢◊õ◊©◊ô◊ï. ◊ú◊§◊†◊ô ◊©◊ê◊™◊ù ◊û◊°◊™◊õ◊ú◊ô◊ù ◊¢◊ú◊ô◊ï, ◊õ◊ú ◊ê◊ó◊ì ◊ô◊†◊ó◊©: ◊û◊î ◊ô◊î◊ô◊î ◊î◊ì◊ë◊® ◊î◊®◊ê◊©◊ï◊ü ◊©{partner} ◊ô◊í◊ô◊ì ◊¢◊ú ◊î◊™◊û◊ï◊†◊î?',
    requiresConfirmation: true,
  },
  {
    id: 't2_5',
    stage: 2,
    difficulty: 2,
    text: '◊ê◊û◊ï◊® ◊ú{partner} ◊©◊ú◊ï◊©◊î ◊ì◊ë◊®◊ô◊ù ◊©◊ê◊™◊î ◊ê◊ï◊î◊ë ◊ë◊ï/◊ë◊î - ◊©◊ú◊ê ◊ß◊©◊ï◊®◊ô◊ù ◊ú◊û◊®◊ê◊î, ◊ú◊î◊¶◊ú◊ó◊ï◊™, ◊ê◊ï ◊ú◊ì◊ë◊®◊ô◊ù ◊©◊î◊ï◊ê/◊î◊ô◊ê ◊¢◊ï◊©◊î ◊ë◊©◊ë◊ô◊ú◊ö.',
    requiresConfirmation: true,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 3 - "◊ì◊ë◊®◊ô◊ù ◊©◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù ◊ë◊ß◊ï◊ú"
  // 4 ◊û◊©◊ô◊û◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 't3_1',
    stage: 3,
    difficulty: 2,
    text: '◊õ◊™◊ï◊ë ◊î◊ï◊ì◊¢◊î ◊ú{partner} ◊©◊ú◊ê ◊î◊ô◊ô◊™ ◊©◊ï◊ú◊ó ◊ë◊ì◊®◊ö ◊õ◊ú◊ú. ◊û◊©◊î◊ï ◊©◊ê◊™◊î ◊ó◊ï◊©◊ë ◊ï◊ú◊ê ◊ê◊ï◊û◊®. ◊î◊ß◊®◊ê ◊ë◊ß◊ï◊ú.',
    requiresConfirmation: true,
  },
  {
    id: 't3_2',
    stage: 3,
    difficulty: 2,
    text: '◊î◊©◊ú◊ù ◊ê◊™ ◊î◊û◊©◊§◊ò ◊ë◊ß◊ï◊ú: "◊ê◊†◊ô ◊û◊¶◊ò◊¢◊®/◊™ ◊¢◊ú..." - ◊¢◊ú ◊û◊©◊î◊ï ◊©◊û◊¢◊ï◊ú◊ù ◊ú◊ê ◊î◊™◊†◊¶◊ú◊™ ◊¢◊ú◊ô◊ï.',
    requiresConfirmation: true,
  },
  {
    id: 't3_3',
    stage: 3,
    difficulty: 3,
    text: '◊°◊§◊® ◊ú{partner} ◊¢◊ú ◊®◊í◊¢ ◊©◊î◊ô◊ô◊™ ◊¶◊®◊ô◊ö ◊ê◊ï◊™◊ï/◊î ◊ï◊ú◊ê ◊ê◊û◊®◊™. ◊™◊ê◊® ◊ê◊™ ◊î◊®◊í◊¢, ◊ú◊ê ◊®◊ß ◊ê◊™ ◊î◊¢◊ï◊ë◊ì◊î.',
    requiresConfirmation: true,
  },
  {
    id: 't3_4',
    stage: 3,
    difficulty: 3,
    text: '◊ô◊© ◊ú◊ö 30 ◊©◊†◊ô◊ï◊™ ◊ú◊ï◊û◊® ◊ú{partner} ◊û◊©◊î◊ï ◊©◊ê◊™◊î ◊™◊û◊ô◊ì ◊®◊ï◊¶◊î ◊ú◊î◊í◊ô◊ì ◊ê◊ë◊ú ◊™◊û◊ô◊ì ◊¢◊ï◊¶◊® ◊ê◊™ ◊¢◊¶◊û◊ö. ◊î◊ò◊ô◊ô◊û◊® ◊®◊• - ◊¢◊õ◊©◊ô◊ï.',
    requiresConfirmation: true,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 4 - "◊û◊ú◊ó◊û◊™ ◊î◊í◊ô◊®◊°◊ê◊ï◊™"
  // 2 ◊û◊©◊ô◊û◊ï◊™
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  {
    id: 't4_1',
    stage: 4,
    difficulty: 2,
    text: '◊ë◊ó◊®◊ï ◊ê◊ô◊®◊ï◊¢ ◊û◊î◊¢◊ë◊® ◊©◊ñ◊ï◊õ◊®◊ô◊ù ◊ê◊ó◊®◊™. ◊õ◊ú ◊ê◊ó◊ì ◊û◊°◊§◊® ◊ê◊™ ◊î◊í◊®◊°◊î ◊©◊ú◊ï - ◊ì◊ß◊î ◊ê◊ó◊™, ◊ë◊ú◊ô ◊î◊§◊®◊¢◊ï◊™. ◊ê◊ó◊® ◊õ◊ö: ◊û◊ô ◊¶◊ï◊ì◊ß?',
    requiresConfirmation: true,
  },
  {
    id: 't4_2',
    stage: 4,
    difficulty: 3,
    text: '◊ó◊ß◊î ◊ê◊™ {partner} ◊õ◊©◊î◊ï◊ê/◊î◊ô◊ê ◊õ◊ï◊¢◊°/◊™ ◊¢◊ú◊ô◊ö. ◊ê◊ó◊®◊ô ◊ñ◊î, {partner} ◊ô◊™◊ß◊ü ◊ê◊ï◊™◊ö.',
    requiresConfirmation: true,
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ◊©◊ú◊ë 5 - "◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î"
  // 5-6 ◊û◊©◊ô◊û◊ï◊™ ◊ú◊õ◊ú ◊®◊û◊™ ◊¢◊ï◊¶◊û◊î
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // SOFT
  {
    id: 't5_soft_1',
    stage: 5,
    difficulty: 1,
    text: '◊©◊ë/◊ô ◊û◊ï◊ú {partner}. ◊°◊í◊ï◊® ◊¢◊ô◊†◊ô◊ô◊ù. ◊î◊ï◊ê/◊î◊ô◊ê ◊ô◊í◊¢/◊™◊ô◊í◊¢ ◊ë◊ö ◊ë◊ì◊ô◊ï◊ß ◊ë◊û◊ß◊ï◊ù ◊ê◊ó◊ì. ◊†◊ó◊© ◊ê◊ô◊§◊î - ◊ú◊§◊†◊ô ◊©◊™◊§◊ß◊ó ◊¢◊ô◊†◊ô◊ô◊ù.',
    requiresConfirmation: true,
    intensity: 'soft',
  },
  {
    id: 't5_soft_2',
    stage: 5,
    difficulty: 1,
    text: '◊ú◊ó◊© ◊ú◊ê◊ï◊ñ◊ü ◊©◊ú {partner} ◊ì◊ë◊® ◊ê◊ó◊ì ◊©◊ê◊™◊î ◊®◊ï◊¶◊î ◊©◊ô◊ß◊®◊î ◊î◊ú◊ô◊ú◊î. ◊ë◊ú◊ô ◊ú◊î◊°◊™◊õ◊ú ◊ë◊¢◊ô◊†◊ô◊ô◊ù.',
    requiresConfirmation: true,
    intensity: 'soft',
  },
  {
    id: 't5_soft_3',
    stage: 5,
    difficulty: 2,
    text: '◊†◊©◊ß ◊ê◊™ {partner} ◊ë◊ì◊ô◊ï◊ß ◊ë◊û◊ß◊ï◊ù ◊©◊ê◊™◊î ◊ô◊ï◊ì◊¢ ◊©◊û◊©◊í◊¢ ◊ê◊ï◊™◊ï/◊î - ◊ê◊ë◊ú ◊ú◊ê ◊¢◊ú ◊î◊§◊î.',
    requiresConfirmation: true,
    intensity: 'soft',
  },
  {
    id: 't5_soft_4',
    stage: 5,
    difficulty: 2,
    text: '◊î◊ï◊®◊ì ◊§◊®◊ô◊ò ◊ú◊ë◊ï◊© ◊ê◊ó◊ì ◊û{partner}. ◊ú◊ê◊ò ◊û◊ê◊ï◊ì. ◊ë◊ú◊ô ◊ú◊ì◊ë◊®.',
    requiresConfirmation: true,
    intensity: 'soft',
  },

  // MEDIUM
  {
    id: 't5_med_1',
    stage: 5,
    difficulty: 2,
    text: '◊™◊ê◊® ◊ú{partner} ◊ë◊ì◊ô◊ï◊ß ◊û◊î ◊î◊ô◊ô◊™ ◊¢◊ï◊©◊î ◊ú◊ï/◊ú◊î ◊¢◊õ◊©◊ô◊ï ◊ê◊ù ◊ú◊ê ◊î◊ô◊î ◊§◊î ◊û◊©◊ó◊ß. ◊§◊®◊ò◊ô◊ù.',
    requiresConfirmation: true,
    intensity: 'medium',
  },
  {
    id: 't5_med_2',
    stage: 5,
    difficulty: 2,
    text: '◊†◊©◊ß ◊ê◊™ {partner} ◊õ◊ê◊ô◊ú◊ï ◊ñ◊ï ◊î◊§◊¢◊ù ◊î◊®◊ê◊©◊ï◊†◊î. ◊ú◊ê ◊õ◊û◊ï ◊©◊ê◊™◊î ◊û◊†◊©◊ß ◊¢◊õ◊©◊ô◊ï - ◊õ◊û◊ï ◊©◊†◊ô◊©◊ß◊™ ◊ë◊î◊™◊ó◊ú◊î.',
    requiresConfirmation: true,
    intensity: 'medium',
  },
  {
    id: 't5_med_3',
    stage: 5,
    difficulty: 3,
    text: '◊ß◊ó ◊ê◊™ ◊î◊ô◊ì ◊©◊ú {partner} ◊ï◊©◊ô◊ù ◊ê◊ï◊™◊î ◊ë◊ì◊ô◊ï◊ß ◊ë◊û◊ß◊ï◊ù ◊©◊ê◊™◊î ◊®◊ï◊¶◊î ◊©◊î◊ô◊ê ◊™◊î◊ô◊î ◊¢◊õ◊©◊ô◊ï.',
    requiresConfirmation: true,
    intensity: 'medium',
  },
  {
    id: 't5_med_4',
    stage: 5,
    difficulty: 3,
    text: '◊ô◊© ◊ú◊ö 60 ◊©◊†◊ô◊ï◊™ ◊ú◊î◊ì◊ú◊ô◊ß ◊ê◊™ {partner} ◊ë◊ú◊ô ◊ú◊í◊¢◊™. ◊®◊ß ◊û◊ô◊ú◊ô◊ù.',
    requiresConfirmation: true,
    intensity: 'medium',
  },

  // SPICY
  {
    id: 't5_spicy_1',
    stage: 5,
    difficulty: 2,
    text: '◊î◊ï◊®◊ì ◊û{partner} ◊©◊†◊ô ◊§◊®◊ô◊ò◊ô ◊ú◊ë◊ï◊©. ◊ê◊™/◊î ◊ë◊ï◊ó◊®/◊™ ◊ê◊™ ◊î◊°◊ì◊®.',
    requiresConfirmation: true,
    intensity: 'spicy',
  },
  {
    id: 't5_spicy_2',
    stage: 5,
    difficulty: 3,
    text: '◊î◊®◊ê◊î ◊ú{partner} ◊ë◊ì◊ô◊ï◊ß ◊û◊î ◊ê◊™◊î ◊®◊ï◊¶◊î ◊¢◊õ◊©◊ô◊ï. ◊ë◊ú◊ô ◊û◊ô◊ú◊ô◊ù ◊õ◊ú◊ú.',
    requiresConfirmation: true,
    intensity: 'spicy',
  },
  {
    id: 't5_spicy_3',
    stage: 5,
    difficulty: 3,
    text: '◊¢◊©◊î ◊ú{partner} ◊ê◊™ ◊û◊î ◊©◊ê◊™◊î ◊ô◊ï◊ì◊¢ ◊©◊î◊ï◊ê/◊î◊ô◊ê ◊î◊õ◊ô ◊ê◊ï◊î◊ë/◊™. ◊ô◊© ◊ú◊ö ◊ì◊ß◊î ◊ú◊î◊ï◊õ◊ô◊ó ◊©◊ê◊™◊î ◊ô◊ï◊ì◊¢.',
    requiresConfirmation: true,
    intensity: 'spicy',
  },
  {
    id: 't5_spicy_4',
    stage: 5,
    difficulty: 3,
    text: '◊î◊û◊©◊ó◊ß ◊ô◊õ◊ï◊ú ◊ú◊ó◊õ◊ï◊™. 5 ◊ì◊ß◊ï◊™, ◊®◊ß ◊ê◊™◊ù. ◊™◊ó◊ñ◊®◊ï ◊õ◊©◊™◊î◊ô◊ï ◊û◊ï◊õ◊†◊ô◊ù.',
    requiresConfirmation: true,
    intensity: 'spicy',
  },
];

// ◊§◊ï◊†◊ß◊¶◊ô◊ï◊™ ◊¢◊ñ◊®
export const formatTask = (task: Task, partnerName: string): string => {
  return task.text.replace(/{partner}/g, partnerName);
};

export const getTasksForStage = (
  stage: number,
  intensity?: 'soft' | 'medium' | 'spicy'
): Task[] => {
  return tasks.filter((t) => {
    if (t.stage !== stage) return false;
    if (stage === 5 && intensity && t.intensity !== intensity) return false;
    return true;
  });
};

export const getRandomTask = (
  stage: number,
  difficulty: 1 | 2 | 3,
  excludeIds: string[] = [],
  intensity?: 'soft' | 'medium' | 'spicy'
): Task | null => {
  const available = tasks.filter((t) => {
    if (t.stage !== stage) return false;
    if (t.difficulty !== difficulty) return false;
    if (excludeIds.includes(t.id)) return false;
    if (stage === 5 && intensity && t.intensity !== intensity) return false;
    return true;
  });
  if (available.length === 0) return null;
  return available[Math.floor(Math.random() * available.length)];
};

--------------------------------------------------------------------------------
FILE: src/navigation/RootNavigator.tsx
--------------------------------------------------------------------------------

/**
 * Root Navigator
 *
 * ◊†◊ô◊ï◊ï◊ò ◊®◊ê◊©◊ô ◊©◊ú ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î
 */

import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { RootStackParamList } from './types';

// Screens
import SplashScreen from '@/screens/Splash/SplashScreen';
import OnboardingScreen from '@/screens/Onboarding/OnboardingScreen';
import GameIntroScreen from '@/screens/Game/GameIntroScreen';
import StageIntroScreen from '@/screens/Game/StageIntroScreen';
import GamePlayScreen from '@/screens/Game/GamePlayScreen';
import StageCompleteScreen from '@/screens/Game/StageCompleteScreen';
import IntensitySelectScreen from '@/screens/Game/IntensitySelectScreen';
import PaywallScreen from '@/screens/Paywall/PaywallScreen';
import QuizSetupScreen from '@/screens/Quiz/QuizSetupScreen';
import QuizWaitingScreen from '@/screens/Quiz/QuizWaitingScreen';
import QuizPlayScreen from '@/screens/Quiz/QuizPlayScreen';
import QuizResultsScreen from '@/screens/Quiz/QuizResultsScreen';
import WheelScreen from '@/screens/Results/WheelScreen';
import ResultsScreen from '@/screens/Results/ResultsScreen';

const Stack = createNativeStackNavigator<RootStackParamList>();

const screenOptions = {
  headerShown: false,
  animation: 'fade' as const,
  animationDuration: 500,
};

export const RootNavigator: React.FC = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator
        initialRouteName="Splash"
        screenOptions={screenOptions}
      >
        {/* Splash & Onboarding */}
        <Stack.Screen name="Splash" component={SplashScreen} />
        <Stack.Screen name="Onboarding" component={OnboardingScreen} />

        {/* Main Game */}
        <Stack.Screen name="GameIntro" component={GameIntroScreen} />
        <Stack.Screen name="StageIntro" component={StageIntroScreen} />
        <Stack.Screen name="GamePlay" component={GamePlayScreen} />
        <Stack.Screen name="StageComplete" component={StageCompleteScreen} />

        {/* Stage 5 */}
        <Stack.Screen name="IntensitySelect" component={IntensitySelectScreen} />

        {/* Paywall */}
        <Stack.Screen name="Paywall" component={PaywallScreen} />

        {/* Quiz */}
        <Stack.Screen name="QuizSetup" component={QuizSetupScreen} />
        <Stack.Screen name="QuizWaiting" component={QuizWaitingScreen} />
        <Stack.Screen name="QuizPlay" component={QuizPlayScreen} />
        <Stack.Screen name="QuizResults" component={QuizResultsScreen} />

        {/* End */}
        <Stack.Screen name="Wheel" component={WheelScreen} />
        <Stack.Screen name="Results" component={ResultsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default RootNavigator;

--------------------------------------------------------------------------------
FILE: src/navigation/index.ts
--------------------------------------------------------------------------------

export { RootNavigator } from './RootNavigator';
export type { RootStackParamList } from './types';

--------------------------------------------------------------------------------
FILE: src/navigation/types.ts
--------------------------------------------------------------------------------

/**
 * Navigation Types
 */

export type RootStackParamList = {
  // Splash & Onboarding
  Splash: undefined;
  Onboarding: undefined;

  // Main Game
  GameIntro: undefined;
  StageIntro: { stageId: number };
  GamePlay: { stageId: number };
  StageComplete: { stageId: number };

  // Stage 5 specific
  IntensitySelect: undefined;

  // Paywall
  Paywall: undefined;

  // Quiz
  QuizSetup: undefined;
  QuizWaiting: { roomCode: string; isHost: boolean };
  QuizPlay: undefined;
  QuizResults: undefined;

  // End
  Wheel: undefined;
  Results: undefined;
};

declare global {
  namespace ReactNavigation {
    interface RootParamList extends RootStackParamList {}
  }
}

--------------------------------------------------------------------------------
FILE: src/screens/Game/GameIntroScreen.tsx
--------------------------------------------------------------------------------

/**
 * Game Intro Screen
 *
 * ◊û◊°◊ö ◊§◊™◊ô◊ó◊î ◊©◊ú ◊î◊û◊©◊ó◊ß ◊¢◊ù ◊î◊ß◊ì◊û◊î ◊©◊ú ◊ì"◊® ◊ó◊®◊ô◊£
 */

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useGameStore } from '@/store/gameStore';
import { gameIntroText } from '@/data/drCharifTexts';
import { spacing } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'GameIntro'>;

export const GameIntroScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { startGame } = useGameStore();
  const [showButton, setShowButton] = useState(false);

  const handleTypingComplete = () => {
    setShowButton(true);
  };

  const handleStart = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    startGame();
    navigation.navigate('StageIntro', { stageId: 1 });
  };

  return (
    <ScreenContainer>
      <View style={styles.container}>
        <View style={styles.content}>
          <DrCharifMessage
            lines={gameIntroText.lines}
            onComplete={handleTypingComplete}
          />
        </View>

        {showButton && (
          <View style={styles.buttonContainer}>
            <Button
              title="◊ô◊ê◊ú◊ú◊î"
              onPress={handleStart}
              variant="primary"
              size="large"
              fullWidth
            />
          </View>
        )}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
  },
  content: {
    flex: 1,
    justifyContent: 'center',
  },
  buttonContainer: {
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing['3xl'],
  },
});

export default GameIntroScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Game/GamePlayScreen.tsx
--------------------------------------------------------------------------------

/**
 * Game Play Screen
 *
 * ◊û◊°◊ö ◊î◊û◊©◊ó◊ß ◊î◊®◊ê◊©◊ô - ◊©◊ê◊ú◊ï◊™ ◊ï◊û◊©◊ô◊û◊ï◊™
 */

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
} from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card, Input } from '@/components/common';
import { useGameStore, STAGES, POINTS } from '@/store/gameStore';
import { getRandomQuestion, formatQuestion } from '@/data/questions';
import { getRandomTask, formatTask } from '@/data/tasks';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'GamePlay'>;
type RouteType = RouteProp<RootStackParamList, 'GamePlay'>;

type GameStep = 'difficulty' | 'content' | 'answer' | 'confirm';

export const GamePlayScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RouteType>();
  const { stageId } = route.params;

  const {
    player1,
    player2,
    currentTurn,
    stageProgress,
    intensityLevel,
    selectDifficulty,
    completeQuestion,
    completeTask,
    useVeto,
    nextTurn,
    nextStage,
    getCurrentPlayer,
    getPartner,
  } = useGameStore();

  const [step, setStep] = useState<GameStep>('difficulty');
  const [selectedDifficulty, setSelectedDifficulty] = useState<1 | 2 | 3 | null>(null);
  const [currentContent, setCurrentContent] = useState<{
    type: 'question' | 'task';
    text: string;
    id: string;
  } | null>(null);
  const [answer, setAnswer] = useState('');
  const [usedIds, setUsedIds] = useState<string[]>([]);

  const currentPlayer = getCurrentPlayer();
  const partner = getPartner();
  const stageInfo = STAGES.find((s) => s.id === stageId);
  const currentProgress = stageProgress.find((p) => p.stageId === stageId);

  const isStageComplete =
    currentProgress && currentProgress.currentItemIndex >= (stageInfo?.items || 0);

  // Check if stage is complete
  useEffect(() => {
    if (isStageComplete) {
      navigation.navigate('StageComplete', { stageId });
    }
  }, [isStageComplete, stageId, navigation]);

  const handleSelectDifficulty = async (difficulty: 1 | 2 | 3) => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setSelectedDifficulty(difficulty);
    selectDifficulty(difficulty);

    // Determine if question or task based on stage ratio
    const isQuestion = Math.random() < (stageInfo?.questionRatio || 0.5);

    if (isQuestion) {
      const question = getRandomQuestion(stageId, difficulty, usedIds);
      if (question) {
        const formattedText = formatQuestion(
          question,
          partner.name,
          currentPlayer.gender || 'other'
        );
        setCurrentContent({ type: 'question', text: formattedText, id: question.id });
        setUsedIds([...usedIds, question.id]);
      }
    } else {
      const task = getRandomTask(
        stageId,
        difficulty,
        usedIds,
        stageId === 5 ? intensityLevel || undefined : undefined
      );
      if (task) {
        const formattedText = formatTask(task, partner.name);
        setCurrentContent({ type: 'task', text: formattedText, id: task.id });
        setUsedIds([...usedIds, task.id]);
      }
    }

    setStep('content');
  };

  const handleVeto = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
    useVeto();
    nextTurn();
    resetTurn();
  };

  const handleAnswerSubmit = async () => {
    if (!answer.trim()) return;
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    completeQuestion(answer);
    nextTurn();
    resetTurn();
  };

  const handleTaskComplete = async (confirmed: boolean) => {
    await Haptics.impactAsync(confirmed ? Haptics.ImpactFeedbackStyle.Medium : Haptics.ImpactFeedbackStyle.Heavy);
    completeTask(confirmed);
    nextTurn();
    resetTurn();
  };

  const resetTurn = () => {
    setStep('difficulty');
    setSelectedDifficulty(null);
    setCurrentContent(null);
    setAnswer('');
  };

  const renderDifficultySelection = () => (
    <View style={styles.difficultyContainer}>
      <Text style={styles.turnIndicator}>◊î◊™◊ï◊® ◊©◊ú {currentPlayer.name}</Text>
      <Text style={styles.subtitle}>◊ë◊ó◊®/◊ô ◊®◊û◊™ ◊™◊¢◊ï◊ñ◊î</Text>

      <View style={styles.difficultyButtons}>
        {[1, 2, 3].map((level) => (
          <TouchableOpacity
            key={level}
            style={[
              styles.difficultyButton,
              {
                borderColor:
                  level === 1
                    ? colors.difficulty.easy
                    : level === 2
                    ? colors.difficulty.medium
                    : colors.difficulty.hard,
              },
            ]}
            onPress={() => handleSelectDifficulty(level as 1 | 2 | 3)}
            activeOpacity={0.7}
          >
            <Text style={styles.difficultyEmoji}>
              {level === 1 ? 'üòä' : level === 2 ? 'üòè' : 'üî•'}
            </Text>
            <Text style={styles.difficultyLabel}>
              {level === 1 ? '◊ß◊ú' : level === 2 ? '◊ë◊ô◊†◊ï◊†◊ô' : '◊ê◊û◊ô◊•'}
            </Text>
            <Text style={styles.difficultyPoints}>{POINTS.difficulty[level as 1 | 2 | 3]} ◊†◊ß◊ï◊ì◊ï◊™</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );

  const renderContent = () => {
    if (!currentContent) return null;

    return (
      <View style={styles.contentContainer}>
        <Card variant="bordered" style={styles.contentCard}>
          <View style={styles.typeIndicator}>
            <Text style={styles.typeText}>
              {currentContent.type === 'question' ? '‚ùì ◊©◊ê◊ú◊î' : 'üéØ ◊û◊©◊ô◊û◊î'}
            </Text>
          </View>
          <Text style={styles.contentText}>{currentContent.text}</Text>
        </Card>

        {currentContent.type === 'question' ? (
          <View style={styles.answerSection}>
            <Input
              placeholder="◊î◊ß◊ú◊ì/◊ô ◊ê◊™ ◊î◊™◊©◊ï◊ë◊î..."
              value={answer}
              onChangeText={setAnswer}
              multiline
              numberOfLines={3}
              style={styles.answerInput}
            />
            <View style={styles.actionButtons}>
              <Button
                title="◊¢◊†◊î"
                onPress={handleAnswerSubmit}
                disabled={!answer.trim()}
                variant="primary"
                style={styles.actionButton}
              />
              {currentPlayer.vetosRemaining > 0 && (
                <Button
                  title={`◊ï◊ò◊ï (${currentPlayer.vetosRemaining})`}
                  onPress={handleVeto}
                  variant="ghost"
                  style={styles.vetoButton}
                />
              )}
            </View>
          </View>
        ) : (
          <View style={styles.taskSection}>
            <Text style={styles.taskInstructions}>
              {partner.name}, ◊î◊ê◊ù ◊î◊û◊©◊ô◊û◊î ◊ë◊ï◊¶◊¢◊î?
            </Text>
            <View style={styles.actionButtons}>
              <Button
                title="◊ë◊ï◊¶◊¢"
                onPress={() => handleTaskComplete(true)}
                variant="primary"
                style={styles.actionButton}
              />
              <Button
                title="◊ú◊ê ◊ë◊ï◊¶◊¢"
                onPress={() => handleTaskComplete(false)}
                variant="wine"
                style={styles.actionButton}
              />
            </View>
          </View>
        )}
      </View>
    );
  };

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Header with scores */}
        <View style={styles.header}>
          <View style={styles.scoreContainer}>
            <Text
              style={[
                styles.playerName,
                currentTurn === 'player1' && styles.activePlayer,
              ]}
            >
              {player1.name}
            </Text>
            <Text style={styles.score}>{player1.score}</Text>
          </View>

          <View style={styles.progressContainer}>
            <Text style={styles.stageLabel}>{stageInfo?.name}</Text>
            <Text style={styles.progressText}>
              {currentProgress?.currentItemIndex || 0} / {stageInfo?.items}
            </Text>
          </View>

          <View style={styles.scoreContainer}>
            <Text
              style={[
                styles.playerName,
                currentTurn === 'player2' && styles.activePlayer,
              ]}
            >
              {player2.name}
            </Text>
            <Text style={styles.score}>{player2.score}</Text>
          </View>
        </View>

        {/* Main content */}
        <ScrollView
          style={styles.mainContent}
          contentContainerStyle={styles.scrollContent}
        >
          {step === 'difficulty' && renderDifficultySelection()}
          {step === 'content' && renderContent()}
        </ScrollView>
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row-reverse',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: colors.alpha[10],
  },
  scoreContainer: {
    alignItems: 'center',
    minWidth: 80,
  },
  playerName: {
    ...typography.bodySmall,
    color: colors.text.secondary,
  },
  activePlayer: {
    color: colors.accent.gold,
    fontWeight: 'bold',
  },
  score: {
    ...typography.h3,
    color: colors.text.primary,
  },
  progressContainer: {
    alignItems: 'center',
  },
  stageLabel: {
    ...typography.caption,
    color: colors.text.muted,
  },
  progressText: {
    ...typography.bodySmall,
    color: colors.text.secondary,
  },
  mainContent: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: spacing.lg,
  },
  difficultyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  turnIndicator: {
    ...typography.h2,
    color: colors.text.primary,
    marginBottom: spacing.sm,
    textAlign: 'center',
  },
  subtitle: {
    ...typography.body,
    color: colors.text.secondary,
    marginBottom: spacing['2xl'],
    textAlign: 'center',
  },
  difficultyButtons: {
    flexDirection: 'row-reverse',
    justifyContent: 'center',
    width: '100%',
  },
  difficultyButton: {
    alignItems: 'center',
    justifyContent: 'center',
    width: 100,
    height: 120,
    marginHorizontal: spacing.sm,
    backgroundColor: colors.background.secondary,
    borderWidth: 2,
    borderRadius: borderRadius.lg,
  },
  difficultyEmoji: {
    fontSize: 32,
    marginBottom: spacing.sm,
  },
  difficultyLabel: {
    ...typography.button,
    color: colors.text.primary,
  },
  difficultyPoints: {
    ...typography.caption,
    color: colors.text.secondary,
    marginTop: spacing.xs,
  },
  contentContainer: {
    flex: 1,
  },
  contentCard: {
    padding: spacing.xl,
    marginBottom: spacing.xl,
  },
  typeIndicator: {
    alignSelf: 'flex-end',
    marginBottom: spacing.md,
  },
  typeText: {
    ...typography.label,
    color: colors.accent.gold,
  },
  contentText: {
    ...typography.bodyLarge,
    color: colors.text.primary,
    textAlign: 'right',
    lineHeight: 28,
  },
  answerSection: {
    marginTop: spacing.lg,
  },
  answerInput: {
    marginBottom: spacing.lg,
  },
  actionButtons: {
    flexDirection: 'row-reverse',
    justifyContent: 'center',
    gap: spacing.md,
  },
  actionButton: {
    flex: 1,
    maxWidth: 150,
  },
  vetoButton: {
    maxWidth: 100,
  },
  taskSection: {
    marginTop: spacing.lg,
    alignItems: 'center',
  },
  taskInstructions: {
    ...typography.body,
    color: colors.text.secondary,
    marginBottom: spacing.xl,
    textAlign: 'center',
  },
});

export default GamePlayScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Game/IntensitySelectScreen.tsx
--------------------------------------------------------------------------------

/**
 * Intensity Select Screen
 *
 * ◊ë◊ó◊ô◊®◊™ ◊®◊û◊™ ◊¢◊ï◊¶◊û◊î ◊ú◊©◊ú◊ë 5 - "◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î"
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useGameStore, IntensityLevel } from '@/store/gameStore';
import { intensitySelectionText, intensityChoiceTexts } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'IntensitySelect'>;

interface IntensityOption {
  level: IntensityLevel;
  name: string;
  description: string;
  emoji: string;
}

const INTENSITY_OPTIONS: IntensityOption[] = [
  {
    level: 'soft',
    name: '◊®◊õ◊î',
    description: '◊†◊í◊ô◊¢◊ï◊™, ◊ú◊ó◊ô◊©◊ï◊™, ◊†◊©◊ô◊ß◊ï◊™, ◊î◊™◊§◊©◊ò◊ï◊™ ◊ó◊ú◊ß◊ô◊™',
    emoji: 'üå∏',
  },
  {
    level: 'medium',
    name: '◊ë◊ô◊†◊ï◊†◊ô◊™',
    description: '◊û◊©◊ô◊û◊ï◊™ ◊ê◊ô◊†◊ò◊ô◊û◊ô◊ï◊™ ◊û◊§◊ï◊®◊©◊ï◊™',
    emoji: 'üî•',
  },
  {
    level: 'spicy',
    name: '◊ó◊®◊ô◊§◊î',
    description: '◊î◊õ◊ú ◊¢◊ú ◊î◊©◊ï◊ú◊ó◊ü',
    emoji: 'üå∂Ô∏è',
  },
];

export const IntensitySelectScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { setIntensityLevel } = useGameStore();

  const [step, setStep] = useState<'intro' | 'select' | 'confirm'>('intro');
  const [selectedLevel, setSelectedLevel] = useState<IntensityLevel | null>(null);
  const [showOptions, setShowOptions] = useState(false);
  const [showContinue, setShowContinue] = useState(false);

  const handleIntroComplete = () => {
    setShowOptions(true);
  };

  const handleSelect = async (level: IntensityLevel) => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    setSelectedLevel(level);
    setIntensityLevel(level);
    setStep('confirm');
  };

  const handleConfirmComplete = () => {
    setShowContinue(true);
  };

  const handleContinue = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    navigation.navigate('GamePlay', { stageId: 5 });
  };

  const renderIntro = () => (
    <View style={styles.content}>
      <DrCharifMessage
        lines={intensitySelectionText.lines}
        onComplete={handleIntroComplete}
      />

      {showOptions && (
        <View style={styles.optionsContainer}>
          {INTENSITY_OPTIONS.map((option) => (
            <TouchableOpacity
              key={option.level}
              style={styles.optionCard}
              onPress={() => handleSelect(option.level)}
              activeOpacity={0.8}
            >
              <Text style={styles.optionEmoji}>{option.emoji}</Text>
              <Text style={styles.optionName}>{option.name}</Text>
              <Text style={styles.optionDescription}>{option.description}</Text>
            </TouchableOpacity>
          ))}
        </View>
      )}
    </View>
  );

  const renderConfirm = () => {
    if (!selectedLevel) return null;
    const confirmText = intensityChoiceTexts[selectedLevel];

    return (
      <View style={styles.content}>
        <DrCharifMessage
          lines={confirmText.lines}
          onComplete={handleConfirmComplete}
        />

        {showContinue && (
          <View style={styles.buttonContainer}>
            <Button
              title="◊ô◊ê◊ú◊ú◊î"
              onPress={handleContinue}
              variant="primary"
              size="large"
              fullWidth
            />
          </View>
        )}
      </View>
    );
  };

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.stageIndicator}>
            <Text style={styles.stageNumber}>5</Text>
          </View>
          <Text style={styles.stageTitle}>◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î</Text>
        </View>

        {/* Content */}
        {step === 'intro' && renderIntro()}
        {step === 'confirm' && renderConfirm()}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    paddingTop: spacing['2xl'],
    paddingBottom: spacing.lg,
  },
  stageIndicator: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: colors.accent.wine,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: spacing.sm,
  },
  stageNumber: {
    ...typography.h3,
    color: colors.text.primary,
  },
  stageTitle: {
    ...typography.h3,
    color: colors.text.primary,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
  },
  optionsContainer: {
    paddingHorizontal: spacing.lg,
    paddingTop: spacing['2xl'],
  },
  optionCard: {
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.alpha[20],
    borderRadius: borderRadius.lg,
    padding: spacing.lg,
    marginBottom: spacing.md,
    alignItems: 'center',
  },
  optionEmoji: {
    fontSize: 32,
    marginBottom: spacing.sm,
  },
  optionName: {
    ...typography.h4,
    color: colors.text.primary,
    marginBottom: spacing.xs,
  },
  optionDescription: {
    ...typography.bodySmall,
    color: colors.text.secondary,
    textAlign: 'center',
  },
  buttonContainer: {
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing['3xl'],
    marginTop: spacing['2xl'],
  },
});

export default IntensitySelectScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Game/StageCompleteScreen.tsx
--------------------------------------------------------------------------------

/**
 * Stage Complete Screen
 *
 * ◊û◊°◊ö ◊°◊ô◊ï◊ù ◊©◊ú◊ë ◊¢◊ù ◊°◊ô◊õ◊ï◊ù ◊ï◊ò◊ß◊°◊ò ◊ì"◊® ◊ó◊®◊ô◊£
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
} from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useGameStore, STAGES } from '@/store/gameStore';
import { transitionTexts } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'StageComplete'>;
type RouteType = RouteProp<RootStackParamList, 'StageComplete'>;

export const StageCompleteScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RouteType>();
  const { stageId } = route.params;
  const [showButton, setShowButton] = useState(false);

  const { player1, player2, isPremium, nextStage } = useGameStore();

  const stageInfo = STAGES.find((s) => s.id === stageId);
  const nextStageInfo = STAGES.find((s) => s.id === stageId + 1);

  const transitionText = transitionTexts[0]; // Use first transition text

  const handleTypingComplete = () => {
    setShowButton(true);
  };

  const handleContinue = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    nextStage();

    // Check where to navigate
    const nextStageNum = stageId + 1;

    if (nextStageNum === 3 && !isPremium) {
      navigation.navigate('Paywall');
    } else if (nextStageNum === 6) {
      navigation.navigate('QuizSetup');
    } else if (nextStageNum <= 5) {
      navigation.navigate('StageIntro', { stageId: nextStageNum });
    } else {
      navigation.navigate('Wheel');
    }
  };

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Stage complete header */}
        <View style={styles.header}>
          <Text style={styles.completedText}>◊°◊ô◊ï◊ù ◊©◊ú◊ë {stageId}</Text>
          <Text style={styles.stageTitle}>{stageInfo?.name}</Text>
        </View>

        {/* Score summary */}
        <Card variant="glass" style={styles.scoreCard}>
          <View style={styles.scoresRow}>
            <View style={styles.playerScore}>
              <Text style={styles.playerScoreName}>{player1.name}</Text>
              <Text style={styles.playerScoreValue}>{player1.score}</Text>
            </View>
            <View style={styles.divider} />
            <View style={styles.playerScore}>
              <Text style={styles.playerScoreName}>{player2.name}</Text>
              <Text style={styles.playerScoreValue}>{player2.score}</Text>
            </View>
          </View>
        </Card>

        {/* Dr. Charif transition text */}
        <View style={styles.messageContainer}>
          <DrCharifMessage
            lines={transitionText.lines}
            onComplete={handleTypingComplete}
            variant="minimal"
          />
        </View>

        {/* Continue button */}
        {showButton && (
          <View style={styles.buttonContainer}>
            <Text style={styles.nextStageText}>
              ◊î◊ë◊ê: {nextStageInfo?.name || '◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô'}
            </Text>
            <Button
              title="◊ú◊î◊û◊©◊ô◊ö"
              onPress={handleContinue}
              variant="primary"
              size="large"
              fullWidth
            />
          </View>
        )}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: spacing['2xl'],
  },
  header: {
    alignItems: 'center',
    marginBottom: spacing['2xl'],
  },
  completedText: {
    ...typography.caption,
    color: colors.accent.gold,
    marginBottom: spacing.xs,
  },
  stageTitle: {
    ...typography.h2,
    color: colors.text.primary,
  },
  scoreCard: {
    marginHorizontal: spacing.xl,
    marginBottom: spacing['2xl'],
  },
  scoresRow: {
    flexDirection: 'row-reverse',
    justifyContent: 'space-around',
    alignItems: 'center',
    paddingVertical: spacing.lg,
  },
  playerScore: {
    alignItems: 'center',
    flex: 1,
  },
  playerScoreName: {
    ...typography.body,
    color: colors.text.secondary,
    marginBottom: spacing.xs,
  },
  playerScoreValue: {
    ...typography.h1,
    color: colors.text.primary,
  },
  divider: {
    width: 1,
    height: 60,
    backgroundColor: colors.alpha[20],
  },
  messageContainer: {
    flex: 1,
    justifyContent: 'center',
  },
  buttonContainer: {
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing['3xl'],
    alignItems: 'center',
  },
  nextStageText: {
    ...typography.bodySmall,
    color: colors.text.muted,
    marginBottom: spacing.md,
  },
});

export default StageCompleteScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Game/StageIntroScreen.tsx
--------------------------------------------------------------------------------

/**
 * Stage Intro Screen
 *
 * ◊û◊°◊ö ◊§◊™◊ô◊ó◊™ ◊©◊ú◊ë ◊¢◊ù ◊î◊°◊ë◊® ◊©◊ú ◊ì"◊® ◊ó◊®◊ô◊£
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
} from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { stageIntros } from '@/data/drCharifTexts';
import { STAGES } from '@/store/gameStore';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'StageIntro'>;
type RouteType = RouteProp<RootStackParamList, 'StageIntro'>;

export const StageIntroScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RouteType>();
  const { stageId } = route.params;
  const [showButton, setShowButton] = useState(false);

  const stageIntro = stageIntros[stageId];
  const stageInfo = STAGES.find((s) => s.id === stageId);

  const handleTypingComplete = () => {
    setShowButton(true);
  };

  const handleContinue = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

    // Stage 5 needs intensity selection first
    if (stageId === 5) {
      navigation.navigate('IntensitySelect');
    } else {
      navigation.navigate('GamePlay', { stageId });
    }
  };

  if (!stageIntro) {
    return null;
  }

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Stage number indicator */}
        <View style={styles.header}>
          <View style={styles.stageIndicator}>
            <Text style={styles.stageNumber}>{stageId}</Text>
          </View>
        </View>

        <View style={styles.content}>
          <DrCharifMessage
            lines={stageIntro.lines}
            onComplete={handleTypingComplete}
          />
        </View>

        {showButton && (
          <View style={styles.buttonContainer}>
            <Button
              title="◊û◊ï◊õ◊†◊ô◊ù"
              onPress={handleContinue}
              variant="primary"
              size="large"
              fullWidth
            />
          </View>
        )}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    paddingTop: spacing['2xl'],
    paddingBottom: spacing.lg,
  },
  stageIndicator: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: colors.accent.wine,
    alignItems: 'center',
    justifyContent: 'center',
  },
  stageNumber: {
    ...typography.h3,
    color: colors.text.primary,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
  },
  buttonContainer: {
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing['3xl'],
  },
});

export default StageIntroScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Game/index.ts
--------------------------------------------------------------------------------

export { default as GameIntroScreen } from './GameIntroScreen';
export { default as StageIntroScreen } from './StageIntroScreen';
export { default as GamePlayScreen } from './GamePlayScreen';
export { default as StageCompleteScreen } from './StageCompleteScreen';
export { default as IntensitySelectScreen } from './IntensitySelectScreen';

--------------------------------------------------------------------------------
FILE: src/screens/Onboarding/OnboardingScreen.tsx
--------------------------------------------------------------------------------

/**
 * Onboarding Screen
 *
 * ◊î◊ñ◊†◊™ ◊©◊û◊ï◊™ ◊ï◊û◊í◊ì◊®◊ô◊ù ◊©◊ú ◊î◊©◊ó◊ß◊†◊ô◊ù
 */

import React, { useState, useRef } from 'react';
import {
  View,
  StyleSheet,
  Animated,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Input, GenderSelector, Gender } from '@/components/common';
import { TypewriterText } from '@/components/drCharif';
import { useGameStore } from '@/store/gameStore';
import { nameEntryTexts } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { spacing } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'Onboarding'>;

type Step = 'name1' | 'gender1' | 'name2' | 'gender2' | 'confirm';

export const OnboardingScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { setPlayerName, setPlayerGender, player1, player2 } = useGameStore();

  const [step, setStep] = useState<Step>('name1');
  const [name1Input, setName1Input] = useState('');
  const [name2Input, setName2Input] = useState('');
  const [gender1, setGender1] = useState<Gender | null>(null);
  const [gender2, setGender2] = useState<Gender | null>(null);
  const [showNextStep, setShowNextStep] = useState(false);

  const fadeAnim = useRef(new Animated.Value(1)).current;

  const handleTypingComplete = () => {
    setShowNextStep(true);
  };

  const transitionToStep = (nextStep: Step) => {
    setShowNextStep(false);
    Animated.sequence([
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start();

    setTimeout(() => {
      setStep(nextStep);
    }, 300);
  };

  const handleContinueName1 = async () => {
    if (!name1Input.trim()) return;
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setPlayerName('player1', name1Input.trim());
    transitionToStep('gender1');
  };

  const handleContinueGender1 = async () => {
    if (!gender1) return;
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setPlayerGender('player1', gender1);
    transitionToStep('name2');
  };

  const handleContinueName2 = async () => {
    if (!name2Input.trim()) return;
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setPlayerName('player2', name2Input.trim());
    transitionToStep('gender2');
  };

  const handleContinueGender2 = async () => {
    if (!gender2) return;
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setPlayerGender('player2', gender2);
    transitionToStep('confirm');
  };

  const handleStartGame = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    navigation.navigate('GameIntro');
  };

  const renderStep = () => {
    switch (step) {
      case 'name1':
        return (
          <View style={styles.stepContent}>
            <TypewriterText
              lines={nameEntryTexts.askFirstName.lines}
              onComplete={handleTypingComplete}
              speed="fast"
            />
            {showNextStep && (
              <View style={styles.inputContainer}>
                <Input
                  placeholder="◊î◊©◊ù ◊©◊ú◊ö"
                  value={name1Input}
                  onChangeText={setName1Input}
                  autoFocus
                  returnKeyType="done"
                  onSubmitEditing={handleContinueName1}
                />
                <Button
                  title="◊î◊û◊©◊ö"
                  onPress={handleContinueName1}
                  disabled={!name1Input.trim()}
                  variant="secondary"
                />
              </View>
            )}
          </View>
        );

      case 'gender1':
        return (
          <View style={styles.stepContent}>
            <TypewriterText
              lines={[{ text: '◊ï◊ê◊ô◊ö ◊ú◊î◊™◊ô◊ô◊ó◊° ◊ê◊ú◊ô◊ö?', delay: 0 }]}
              onComplete={handleTypingComplete}
              speed="fast"
            />
            {showNextStep && (
              <View style={styles.inputContainer}>
                <GenderSelector
                  value={gender1}
                  onChange={setGender1}
                  style={styles.genderSelector}
                />
                <Button
                  title="◊î◊û◊©◊ö"
                  onPress={handleContinueGender1}
                  disabled={!gender1}
                  variant="secondary"
                />
              </View>
            )}
          </View>
        );

      case 'name2':
        return (
          <View style={styles.stepContent}>
            <TypewriterText
              lines={nameEntryTexts.askSecondName.lines}
              onComplete={handleTypingComplete}
              speed="fast"
            />
            {showNextStep && (
              <View style={styles.inputContainer}>
                <Input
                  placeholder="◊î◊©◊ù ◊©◊ú ◊ë◊ü/◊ë◊™ ◊î◊ñ◊ï◊í"
                  value={name2Input}
                  onChangeText={setName2Input}
                  autoFocus
                  returnKeyType="done"
                  onSubmitEditing={handleContinueName2}
                />
                <Button
                  title="◊î◊û◊©◊ö"
                  onPress={handleContinueName2}
                  disabled={!name2Input.trim()}
                  variant="secondary"
                />
              </View>
            )}
          </View>
        );

      case 'gender2':
        return (
          <View style={styles.stepContent}>
            <TypewriterText
              lines={[{ text: `◊ï◊ê◊ô◊ö ◊ú◊î◊™◊ô◊ô◊ó◊° ◊ú${name2Input}?`, delay: 0 }]}
              onComplete={handleTypingComplete}
              speed="fast"
            />
            {showNextStep && (
              <View style={styles.inputContainer}>
                <GenderSelector
                  value={gender2}
                  onChange={setGender2}
                  style={styles.genderSelector}
                />
                <Button
                  title="◊î◊û◊©◊ö"
                  onPress={handleContinueGender2}
                  disabled={!gender2}
                  variant="secondary"
                />
              </View>
            )}
          </View>
        );

      case 'confirm':
        const confirmLines = nameEntryTexts.namesConfirm(
          player1.name || name1Input,
          player2.name || name2Input
        );
        return (
          <View style={styles.stepContent}>
            <TypewriterText
              lines={confirmLines.lines}
              onComplete={handleTypingComplete}
              speed="normal"
            />
            {showNextStep && (
              <View style={styles.buttonContainer}>
                <Button
                  title="◊ë◊ï◊ê◊ï ◊†◊™◊ó◊ô◊ú"
                  onPress={handleStartGame}
                  variant="primary"
                  size="large"
                />
              </View>
            )}
          </View>
        );

      default:
        return null;
    }
  };

  return (
    <ScreenContainer keyboardAvoiding>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <Animated.View style={[styles.content, { opacity: fadeAnim }]}>
          {renderStep()}
        </Animated.View>
      </KeyboardAvoidingView>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
  },
  stepContent: {
    paddingHorizontal: spacing.lg,
  },
  inputContainer: {
    marginTop: spacing['2xl'],
  },
  genderSelector: {
    marginBottom: spacing.lg,
  },
  buttonContainer: {
    marginTop: spacing['3xl'],
    alignItems: 'center',
  },
});

export default OnboardingScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Onboarding/index.ts
--------------------------------------------------------------------------------

export { default as OnboardingScreen } from './OnboardingScreen';

--------------------------------------------------------------------------------
FILE: src/screens/Paywall/PaywallScreen.tsx
--------------------------------------------------------------------------------

/**
 * Paywall Screen
 *
 * ◊û◊°◊ö ◊™◊©◊ú◊ï◊ù ◊ê◊ó◊®◊ô ◊©◊ú◊ë 2
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { LinearGradient } from 'expo-linear-gradient';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useGameStore } from '@/store/gameStore';
import { paywallText } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius, shadows } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'Paywall'>;

const FEATURES = [
  '◊©◊ú◊ë◊ô◊ù 3-5 ◊¢◊ù ◊™◊ï◊õ◊ü ◊û◊™◊ß◊ì◊ù',
  '◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô ◊î◊û◊ú◊ê',
  '◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú ◊¢◊ù 15 ◊§◊®◊°◊ô◊ù',
  '◊í◊ô◊©◊î ◊ú◊õ◊ú ◊î◊ß◊ò◊í◊ï◊®◊ô◊ï◊™',
];

export const PaywallScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { setPremium } = useGameStore();
  const [showContent, setShowContent] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleTypingComplete = () => {
    setShowContent(true);
  };

  const handlePurchase = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
    setIsLoading(true);

    // Simulate purchase (in production, use RevenueCat)
    setTimeout(() => {
      setPremium(true);
      setIsLoading(false);
      navigation.navigate('StageIntro', { stageId: 3 });
    }, 1500);
  };

  const handleRestore = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    // Simulate restore
    setIsLoading(true);
    setTimeout(() => {
      setIsLoading(false);
    }, 1000);
  };

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Dr. Charif message */}
        <View style={styles.messageContainer}>
          <DrCharifMessage
            lines={paywallText.lines}
            onComplete={handleTypingComplete}
            variant="minimal"
          />
        </View>

        {showContent && (
          <>
            {/* Price card */}
            <LinearGradient
              colors={colors.gradients.wine as unknown as string[]}
              style={styles.priceCard}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 1 }}
            >
              <Text style={styles.priceLabel}>◊î◊¢◊®◊ë ◊î◊û◊ú◊ê</Text>
              <View style={styles.priceRow}>
                <Text style={styles.currency}>‚Ç™</Text>
                <Text style={styles.price}>79</Text>
              </View>
              <Text style={styles.priceSubtext}>◊ß◊†◊ô◊î ◊ó◊ì ◊§◊¢◊û◊ô◊™</Text>
            </LinearGradient>

            {/* Features list */}
            <Card variant="glass" style={styles.featuresCard}>
              <Text style={styles.featuresTitle}>◊û◊î ◊û◊ó◊õ◊î ◊ú◊õ◊ù ◊ë◊§◊†◊ô◊ù:</Text>
              {FEATURES.map((feature, index) => (
                <View key={index} style={styles.featureRow}>
                  <Text style={styles.featureCheck}>‚úì</Text>
                  <Text style={styles.featureText}>{feature}</Text>
                </View>
              ))}
            </Card>

            {/* Purchase buttons */}
            <View style={styles.buttonsContainer}>
              <Button
                title="◊ú◊§◊™◊ï◊ó ◊ê◊™ ◊î◊¢◊®◊ë"
                onPress={handlePurchase}
                variant="primary"
                size="large"
                fullWidth
                loading={isLoading}
              />
              <TouchableOpacity
                style={styles.restoreButton}
                onPress={handleRestore}
                activeOpacity={0.7}
              >
                <Text style={styles.restoreText}>◊©◊ó◊ñ◊ï◊® ◊®◊õ◊ô◊©◊î</Text>
              </TouchableOpacity>
            </View>
          </>
        )}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: spacing['2xl'],
  },
  messageContainer: {
    paddingVertical: spacing.xl,
  },
  priceCard: {
    marginHorizontal: spacing.xl,
    padding: spacing.xl,
    borderRadius: borderRadius.xl,
    alignItems: 'center',
    ...shadows.lg,
  },
  priceLabel: {
    ...typography.label,
    color: colors.text.primary,
    opacity: 0.8,
  },
  priceRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginVertical: spacing.sm,
  },
  currency: {
    ...typography.h3,
    color: colors.text.primary,
    marginTop: spacing.xs,
  },
  price: {
    fontSize: 64,
    fontWeight: 'bold',
    color: colors.text.primary,
    lineHeight: 72,
  },
  priceSubtext: {
    ...typography.bodySmall,
    color: colors.text.primary,
    opacity: 0.7,
  },
  featuresCard: {
    marginHorizontal: spacing.xl,
    marginTop: spacing.xl,
    padding: spacing.lg,
  },
  featuresTitle: {
    ...typography.h4,
    color: colors.text.primary,
    marginBottom: spacing.md,
    textAlign: 'right',
  },
  featureRow: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    marginBottom: spacing.sm,
  },
  featureCheck: {
    color: colors.accent.gold,
    fontSize: 16,
    marginLeft: spacing.sm,
  },
  featureText: {
    ...typography.body,
    color: colors.text.secondary,
  },
  buttonsContainer: {
    paddingHorizontal: spacing.xl,
    paddingTop: spacing['2xl'],
    paddingBottom: spacing['3xl'],
    marginTop: 'auto',
  },
  restoreButton: {
    alignSelf: 'center',
    marginTop: spacing.lg,
    paddingVertical: spacing.sm,
  },
  restoreText: {
    ...typography.bodySmall,
    color: colors.text.muted,
    textDecorationLine: 'underline',
  },
});

export default PaywallScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Paywall/index.ts
--------------------------------------------------------------------------------

export { default as PaywallScreen } from './PaywallScreen';

--------------------------------------------------------------------------------
FILE: src/screens/Quiz/QuizPlayScreen.tsx
--------------------------------------------------------------------------------

/**
 * Quiz Play Screen
 *
 * ◊û◊°◊ö ◊û◊©◊ó◊ß ◊î◊ó◊ô◊ì◊ï◊ü
 */

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { useQuizStore } from '@/store/quizStore';
import { useGameStore } from '@/store/gameStore';
import { QUIZ_CATEGORIES } from '@/data/quizQuestions';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'QuizPlay'>;

type AnswerPhase = 'self' | 'partner' | 'waiting';

export const QuizPlayScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const {
    questions,
    currentQuestionIndex,
    totalQuestions,
    currentSelfAnswer,
    currentPartnerAnswer,
    setCurrentSelfAnswer,
    setCurrentPartnerAnswer,
    submitAnswer,
    nextQuestion,
    calculateResults,
  } = useQuizStore();

  const { player1, player2 } = useGameStore();

  const [phase, setPhase] = useState<AnswerPhase>('self');

  const currentQuestion = questions[currentQuestionIndex];
  const categoryInfo = currentQuestion
    ? QUIZ_CATEGORIES[currentQuestion.category]
    : null;

  const isLastQuestion = currentQuestionIndex === totalQuestions - 1;

  const handleSelectSelf = async (index: number) => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setCurrentSelfAnswer(index);
  };

  const handleSelectPartner = async (index: number) => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setCurrentPartnerAnswer(index);
  };

  const handleContinueToPartner = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    setPhase('partner');
  };

  const handleSubmit = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    submitAnswer();

    if (isLastQuestion) {
      // Calculate results and navigate
      calculateResults();
      navigation.navigate('QuizResults');
    } else {
      // Move to next question
      nextQuestion();
      setPhase('self');
    }
  };

  if (!currentQuestion) {
    return null;
  }

  const renderOptions = (
    selectedIndex: number | null,
    onSelect: (index: number) => void
  ) => (
    <View style={styles.optionsContainer}>
      {currentQuestion.options.map((option, index) => {
        const isSelected = selectedIndex === index;
        return (
          <TouchableOpacity
            key={index}
            style={[styles.optionButton, isSelected && styles.optionSelected]}
            onPress={() => onSelect(index)}
            activeOpacity={0.7}
          >
            <Text
              style={[styles.optionText, isSelected && styles.optionTextSelected]}
            >
              {option}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );

  const renderSelfPhase = () => (
    <>
      <Text style={styles.phaseLabel}>◊û◊î ◊î◊™◊©◊ï◊ë◊î ◊¢◊ë◊ï◊®◊ö?</Text>
      {renderOptions(currentSelfAnswer, handleSelectSelf)}

      <View style={styles.buttonContainer}>
        <Button
          title="◊î◊û◊©◊ö"
          onPress={handleContinueToPartner}
          variant="primary"
          disabled={currentSelfAnswer === null}
          fullWidth
        />
      </View>
    </>
  );

  const renderPartnerPhase = () => (
    <>
      <Text style={styles.phaseLabel}>◊û◊î ◊ú◊ì◊¢◊™◊ö ◊î◊™◊©◊ï◊ë◊î ◊©◊ú {player2.name}?</Text>
      {renderOptions(currentPartnerAnswer, handleSelectPartner)}

      <View style={styles.buttonContainer}>
        <Button
          title={isLastQuestion ? '◊°◊ô◊ï◊ù' : '◊©◊ê◊ú◊î ◊î◊ë◊ê◊î'}
          onPress={handleSubmit}
          variant="primary"
          disabled={currentPartnerAnswer === null}
          fullWidth
        />
      </View>
    </>
  );

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.progressBar}>
            <View
              style={[
                styles.progressFill,
                {
                  width: `${((currentQuestionIndex + 1) / totalQuestions) * 100}%`,
                },
              ]}
            />
          </View>
          <Text style={styles.progressText}>
            {currentQuestionIndex + 1} / {totalQuestions}
          </Text>
        </View>

        {/* Question card */}
        <ScrollView style={styles.scrollContent}>
          <Card variant="bordered" style={styles.questionCard}>
            <View style={styles.categoryBadge}>
              <Text style={styles.categoryText}>{categoryInfo?.name}</Text>
            </View>
            <Text style={styles.questionText}>{currentQuestion.text}</Text>
          </Card>

          {/* Answer phase */}
          {phase === 'self' && renderSelfPhase()}
          {phase === 'partner' && renderPartnerPhase()}
        </ScrollView>
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingHorizontal: spacing.xl,
    paddingTop: spacing.lg,
    paddingBottom: spacing.md,
  },
  progressBar: {
    height: 4,
    backgroundColor: colors.alpha[20],
    borderRadius: 2,
    overflow: 'hidden',
    marginBottom: spacing.sm,
  },
  progressFill: {
    height: '100%',
    backgroundColor: colors.accent.gold,
    borderRadius: 2,
  },
  progressText: {
    ...typography.caption,
    color: colors.text.muted,
    textAlign: 'center',
  },
  scrollContent: {
    flex: 1,
    paddingHorizontal: spacing.lg,
  },
  questionCard: {
    padding: spacing.xl,
    marginBottom: spacing.xl,
  },
  categoryBadge: {
    alignSelf: 'flex-end',
    backgroundColor: colors.accent.wine,
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.xs,
    borderRadius: borderRadius.full,
    marginBottom: spacing.md,
  },
  categoryText: {
    ...typography.caption,
    color: colors.text.primary,
  },
  questionText: {
    ...typography.h4,
    color: colors.text.primary,
    textAlign: 'right',
    lineHeight: 28,
  },
  phaseLabel: {
    ...typography.body,
    color: colors.text.secondary,
    textAlign: 'center',
    marginBottom: spacing.lg,
  },
  optionsContainer: {
    marginBottom: spacing.xl,
  },
  optionButton: {
    backgroundColor: colors.background.secondary,
    borderWidth: 1,
    borderColor: colors.alpha[20],
    borderRadius: borderRadius.lg,
    padding: spacing.md,
    marginBottom: spacing.sm,
  },
  optionSelected: {
    borderColor: colors.accent.gold,
    backgroundColor: colors.background.tertiary,
  },
  optionText: {
    ...typography.body,
    color: colors.text.primary,
    textAlign: 'right',
  },
  optionTextSelected: {
    color: colors.accent.gold,
  },
  buttonContainer: {
    paddingBottom: spacing['2xl'],
  },
});

export default QuizPlayScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Quiz/QuizResultsScreen.tsx
--------------------------------------------------------------------------------

/**
 * Quiz Results Screen
 *
 * ◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊ì◊ï◊ü
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { useQuizStore } from '@/store/quizStore';
import { useGameStore } from '@/store/gameStore';
import { getQuizQuestionById } from '@/data/quizQuestions';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'QuizResults'>;

export const QuizResultsScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { results, player1Score, player2Score, questions } = useQuizStore();
  const { player1, player2 } = useGameStore();

  const [showDetails, setShowDetails] = useState(false);

  const player1CorrectCount = results.filter((r) => r.player1Correct).length;
  const player2CorrectCount = results.filter((r) => r.player2Correct).length;

  const handleContinue = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    navigation.navigate('Wheel');
  };

  const handleToggleDetails = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setShowDetails(!showDetails);
  };

  return (
    <ScreenContainer scrollable>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.title}>◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊ì◊ï◊ü</Text>
        </View>

        {/* Score cards */}
        <View style={styles.scoresContainer}>
          <Card
            variant={player1CorrectCount >= player2CorrectCount ? 'bordered' : 'glass'}
            style={styles.scoreCard}
          >
            <Text style={styles.playerName}>{player1.name}</Text>
            <Text style={styles.scoreValue}>
              {player1CorrectCount}/{results.length}
            </Text>
            <Text style={styles.scoreLabel}>◊™◊©◊ï◊ë◊ï◊™ ◊†◊õ◊ï◊†◊ï◊™</Text>
          </Card>

          <Card
            variant={player2CorrectCount >= player1CorrectCount ? 'bordered' : 'glass'}
            style={styles.scoreCard}
          >
            <Text style={styles.playerName}>{player2.name}</Text>
            <Text style={styles.scoreValue}>
              {player2CorrectCount}/{results.length}
            </Text>
            <Text style={styles.scoreLabel}>◊™◊©◊ï◊ë◊ï◊™ ◊†◊õ◊ï◊†◊ï◊™</Text>
          </Card>
        </View>

        {/* Summary message */}
        <Card variant="glass" style={styles.summaryCard}>
          <Text style={styles.summaryText}>
            {player1CorrectCount === player2CorrectCount
              ? '◊™◊ô◊ß◊ï ◊û◊ï◊©◊ú◊ù! ◊ê◊™◊ù ◊û◊õ◊ô◊®◊ô◊ù ◊ê◊ó◊ì ◊ê◊™ ◊î◊©◊†◊ô◊ô◊î ◊ë◊ê◊ï◊™◊î ◊®◊û◊î.'
              : player1CorrectCount > player2CorrectCount
              ? `${player1.name} ◊û◊õ◊ô◊®/◊î ◊ê◊™ ${player2.name} ◊ß◊¶◊™ ◊ô◊ï◊™◊® ◊ò◊ï◊ë ◊î◊¢◊®◊ë!`
              : `${player2.name} ◊û◊õ◊ô◊®/◊î ◊ê◊™ ${player1.name} ◊ß◊¶◊™ ◊ô◊ï◊™◊® ◊ò◊ï◊ë ◊î◊¢◊®◊ë!`}
          </Text>
        </Card>

        {/* Show details button */}
        <Button
          title={showDetails ? '◊î◊°◊™◊® ◊§◊®◊ò◊ô◊ù' : '◊î◊¶◊í ◊§◊®◊ò◊ô◊ù'}
          onPress={handleToggleDetails}
          variant="ghost"
          style={styles.detailsButton}
        />

        {/* Detailed results */}
        {showDetails && (
          <View style={styles.detailsContainer}>
            {results.map((result, index) => {
              const question = questions.find((q) => q.id === result.questionId);
              if (!question) return null;

              return (
                <Card key={result.questionId} variant="glass" style={styles.detailCard}>
                  <Text style={styles.detailQuestion}>
                    {index + 1}. {question.text}
                  </Text>

                  <View style={styles.detailRow}>
                    <Text style={styles.detailLabel}>{player1.name} ◊¢◊†◊î/◊™◊î:</Text>
                    <Text style={styles.detailValue}>
                      {question.options[result.player1SelfAnswer]}
                    </Text>
                  </View>

                  <View style={styles.detailRow}>
                    <Text style={styles.detailLabel}>{player2.name} ◊¢◊†◊î/◊™◊î:</Text>
                    <Text style={styles.detailValue}>
                      {question.options[result.player2SelfAnswer]}
                    </Text>
                  </View>

                  <View style={styles.resultIcons}>
                    <View style={styles.resultIconRow}>
                      <Text style={styles.resultIcon}>
                        {result.player1Correct ? '‚úì' : '‚úó'}
                      </Text>
                      <Text style={styles.resultName}>{player1.name}</Text>
                    </View>
                    <View style={styles.resultIconRow}>
                      <Text style={styles.resultIcon}>
                        {result.player2Correct ? '‚úì' : '‚úó'}
                      </Text>
                      <Text style={styles.resultName}>{player2.name}</Text>
                    </View>
                  </View>
                </Card>
              );
            })}
          </View>
        )}

        {/* Continue button */}
        <View style={styles.buttonContainer}>
          <Button
            title="◊ú◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú"
            onPress={handleContinue}
            variant="primary"
            size="large"
            fullWidth
          />
        </View>
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: spacing['2xl'],
    paddingBottom: spacing['3xl'],
  },
  header: {
    alignItems: 'center',
    marginBottom: spacing['2xl'],
  },
  title: {
    ...typography.h2,
    color: colors.text.primary,
  },
  scoresContainer: {
    flexDirection: 'row-reverse',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.lg,
    marginBottom: spacing.xl,
  },
  scoreCard: {
    flex: 1,
    marginHorizontal: spacing.sm,
    padding: spacing.lg,
    alignItems: 'center',
  },
  playerName: {
    ...typography.body,
    color: colors.text.secondary,
    marginBottom: spacing.xs,
  },
  scoreValue: {
    ...typography.h1,
    color: colors.text.primary,
  },
  scoreLabel: {
    ...typography.caption,
    color: colors.text.muted,
  },
  summaryCard: {
    marginHorizontal: spacing.lg,
    padding: spacing.lg,
    marginBottom: spacing.xl,
  },
  summaryText: {
    ...typography.body,
    color: colors.text.primary,
    textAlign: 'center',
    lineHeight: 24,
  },
  detailsButton: {
    alignSelf: 'center',
    marginBottom: spacing.lg,
  },
  detailsContainer: {
    paddingHorizontal: spacing.lg,
  },
  detailCard: {
    padding: spacing.lg,
    marginBottom: spacing.md,
  },
  detailQuestion: {
    ...typography.bodySmall,
    color: colors.text.primary,
    textAlign: 'right',
    marginBottom: spacing.md,
  },
  detailRow: {
    flexDirection: 'row-reverse',
    justifyContent: 'space-between',
    marginBottom: spacing.xs,
  },
  detailLabel: {
    ...typography.caption,
    color: colors.text.muted,
  },
  detailValue: {
    ...typography.caption,
    color: colors.text.secondary,
    flex: 1,
    textAlign: 'left',
  },
  resultIcons: {
    flexDirection: 'row-reverse',
    justifyContent: 'space-around',
    marginTop: spacing.md,
    paddingTop: spacing.md,
    borderTopWidth: 1,
    borderTopColor: colors.alpha[10],
  },
  resultIconRow: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
  },
  resultIcon: {
    fontSize: 16,
    marginLeft: spacing.xs,
    color: colors.accent.gold,
  },
  resultName: {
    ...typography.caption,
    color: colors.text.secondary,
  },
  buttonContainer: {
    paddingHorizontal: spacing.xl,
    paddingTop: spacing['2xl'],
  },
});

export default QuizResultsScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Quiz/QuizSetupScreen.tsx
--------------------------------------------------------------------------------

/**
 * Quiz Setup Screen
 *
 * ◊î◊í◊ì◊®◊™ ◊î◊ó◊ô◊ì◊ï◊ü - ◊ô◊¶◊ô◊®◊™/◊î◊¶◊ò◊®◊§◊ï◊™ ◊ú◊ó◊ì◊®
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card, Input } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useQuizStore } from '@/store/quizStore';
import { quizIntroText, deviceConnectionText } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'QuizSetup'>;

type SetupStep = 'intro' | 'connection' | 'choice';

export const QuizSetupScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { createRoom, joinRoom } = useQuizStore();

  const [step, setStep] = useState<SetupStep>('intro');
  const [showNext, setShowNext] = useState(false);
  const [joinCode, setJoinCode] = useState('');
  const [joinError, setJoinError] = useState('');

  const handleIntroComplete = () => {
    setShowNext(true);
  };

  const handleConnectionComplete = () => {
    setShowNext(true);
  };

  const handleContinueToConnection = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setShowNext(false);
    setStep('connection');
  };

  const handleContinueToChoice = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setShowNext(false);
    setStep('choice');
  };

  const handleCreateRoom = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    const code = createRoom();
    navigation.navigate('QuizWaiting', { roomCode: code, isHost: true });
  };

  const handleJoinRoom = async () => {
    if (joinCode.length !== 4) {
      setJoinError('◊î◊ß◊ï◊ì ◊¶◊®◊ô◊ö ◊ú◊î◊ô◊ï◊™ 4 ◊°◊§◊®◊ï◊™');
      return;
    }
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    joinRoom(joinCode);
    navigation.navigate('QuizWaiting', { roomCode: joinCode, isHost: false });
  };

  const renderIntro = () => (
    <View style={styles.content}>
      <DrCharifMessage
        lines={quizIntroText.lines}
        onComplete={handleIntroComplete}
      />
      {showNext && (
        <View style={styles.buttonContainer}>
          <Button
            title="◊î◊ë◊†◊™◊ô"
            onPress={handleContinueToConnection}
            variant="primary"
            size="large"
          />
        </View>
      )}
    </View>
  );

  const renderConnection = () => (
    <View style={styles.content}>
      <DrCharifMessage
        lines={deviceConnectionText.lines}
        onComplete={handleConnectionComplete}
      />
      {showNext && (
        <View style={styles.buttonContainer}>
          <Button
            title="◊û◊ï◊õ◊†◊ô◊ù"
            onPress={handleContinueToChoice}
            variant="primary"
            size="large"
          />
        </View>
      )}
    </View>
  );

  const renderChoice = () => (
    <View style={styles.content}>
      <Text style={styles.choiceTitle}>◊ë◊ó◊®◊ï ◊ê◊ó◊ì</Text>

      {/* Create room option */}
      <Card variant="bordered" style={styles.optionCard} onPress={handleCreateRoom}>
        <Text style={styles.optionEmoji}>üì±</Text>
        <Text style={styles.optionTitle}>◊ô◊¶◊ô◊®◊™ ◊ó◊ì◊®</Text>
        <Text style={styles.optionDescription}>
          ◊ß◊ë◊ú ◊ß◊ï◊ì ◊ú◊©◊ô◊™◊ï◊£ ◊¢◊ù ◊ë◊ü/◊ë◊™ ◊î◊ñ◊ï◊í
        </Text>
      </Card>

      {/* Join room option */}
      <Card variant="glass" style={styles.optionCard}>
        <Text style={styles.optionEmoji}>üîó</Text>
        <Text style={styles.optionTitle}>◊î◊¶◊ò◊®◊§◊ï◊™ ◊ú◊ó◊ì◊®</Text>
        <Input
          placeholder="◊î◊ß◊ú◊ì ◊ß◊ï◊ì 4 ◊°◊§◊®◊ï◊™"
          value={joinCode}
          onChangeText={(text) => {
            setJoinCode(text.replace(/[^0-9]/g, '').slice(0, 4));
            setJoinError('');
          }}
          keyboardType="numeric"
          maxLength={4}
          error={joinError}
          containerStyle={styles.codeInput}
        />
        <Button
          title="◊î◊¶◊ò◊®◊£"
          onPress={handleJoinRoom}
          variant="secondary"
          disabled={joinCode.length !== 4}
        />
      </Card>
    </View>
  );

  return (
    <ScreenContainer scrollable>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.stageIndicator}>
            <Text style={styles.stageNumber}>6</Text>
          </View>
          <Text style={styles.stageTitle}>◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô</Text>
        </View>

        {/* Content */}
        {step === 'intro' && renderIntro()}
        {step === 'connection' && renderConnection()}
        {step === 'choice' && renderChoice()}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingBottom: spacing['3xl'],
  },
  header: {
    alignItems: 'center',
    paddingTop: spacing['2xl'],
    paddingBottom: spacing.lg,
  },
  stageIndicator: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: colors.accent.wine,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: spacing.sm,
  },
  stageNumber: {
    ...typography.h3,
    color: colors.text.primary,
  },
  stageTitle: {
    ...typography.h3,
    color: colors.text.primary,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  buttonContainer: {
    marginTop: spacing['2xl'],
    alignItems: 'center',
  },
  choiceTitle: {
    ...typography.h3,
    color: colors.text.primary,
    textAlign: 'center',
    marginBottom: spacing.xl,
  },
  optionCard: {
    marginBottom: spacing.lg,
    padding: spacing.xl,
    alignItems: 'center',
  },
  optionEmoji: {
    fontSize: 40,
    marginBottom: spacing.md,
  },
  optionTitle: {
    ...typography.h4,
    color: colors.text.primary,
    marginBottom: spacing.xs,
  },
  optionDescription: {
    ...typography.bodySmall,
    color: colors.text.secondary,
    textAlign: 'center',
  },
  codeInput: {
    marginVertical: spacing.md,
    width: '100%',
  },
});

export default QuizSetupScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Quiz/QuizWaitingScreen.tsx
--------------------------------------------------------------------------------

/**
 * Quiz Waiting Screen
 *
 * ◊î◊û◊™◊†◊î ◊ú◊î◊™◊ó◊ë◊®◊ï◊™ ◊ë◊ü/◊ë◊™ ◊î◊ñ◊ï◊í
 */

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, useRoute, RouteProp } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { useQuizStore } from '@/store/quizStore';
import { useGameStore } from '@/store/gameStore';
import { getQuizQuestionsForGame } from '@/data/quizQuestions';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'QuizWaiting'>;
type RouteType = RouteProp<RootStackParamList, 'QuizWaiting'>;

export const QuizWaitingScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const route = useRoute<RouteType>();
  const { roomCode, isHost } = route.params;

  const { partnerConnected, setPartnerConnected, setQuestions } = useQuizStore();
  const { player1, player2 } = useGameStore();

  // Simulate partner connection (in production, use Firebase)
  useEffect(() => {
    if (!isHost) {
      // If joining, notify host that partner connected
      // Simulate immediate connection for MVP
      setTimeout(() => {
        setPartnerConnected(true);
      }, 1000);
    }
  }, [isHost, setPartnerConnected]);

  // Simulate receiving partner connection notification for host
  useEffect(() => {
    if (isHost && !partnerConnected) {
      // In production, listen for Firebase event
      // For MVP, simulate connection after some time
      const timeout = setTimeout(() => {
        setPartnerConnected(true);
      }, 5000); // Simulate 5 second wait

      return () => clearTimeout(timeout);
    }
  }, [isHost, partnerConnected, setPartnerConnected]);

  const handleStartQuiz = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

    // Generate quiz questions
    const questions = getQuizQuestionsForGame();
    setQuestions(questions);

    navigation.navigate('QuizPlay');
  };

  const partnerName = isHost ? player2.name : player1.name;

  return (
    <ScreenContainer>
      <View style={styles.container}>
        <View style={styles.content}>
          {isHost ? (
            // Host view - show code
            <>
              <Text style={styles.title}>◊î◊ß◊ï◊ì ◊©◊ú◊õ◊ù:</Text>
              <View style={styles.codeContainer}>
                {roomCode.split('').map((digit, index) => (
                  <View key={index} style={styles.codeDigit}>
                    <Text style={styles.codeText}>{digit}</Text>
                  </View>
                ))}
              </View>
              <Text style={styles.instruction}>
                ◊™◊†◊ï ◊ú{player2.name} ◊ú◊î◊ß◊ú◊ô◊ì ◊ê◊™ ◊î◊ß◊ï◊ì ◊ë◊ò◊ú◊§◊ï◊ü ◊©◊ú◊ï/◊î
              </Text>
            </>
          ) : (
            // Guest view - show connecting
            <Text style={styles.title}>◊û◊™◊ó◊ë◊®◊ô◊ù...</Text>
          )}

          {/* Connection status */}
          <Card variant="glass" style={styles.statusCard}>
            <View style={styles.statusRow}>
              <View style={[styles.statusDot, styles.connected]} />
              <Text style={styles.statusName}>{player1.name}</Text>
            </View>
            <View style={styles.statusDivider} />
            <View style={styles.statusRow}>
              <View
                style={[
                  styles.statusDot,
                  partnerConnected ? styles.connected : styles.waiting,
                ]}
              />
              <Text style={styles.statusName}>{player2.name}</Text>
              {!partnerConnected && (
                <ActivityIndicator
                  size="small"
                  color={colors.accent.gold}
                  style={styles.loader}
                />
              )}
            </View>
          </Card>

          {/* Start button when both connected */}
          {partnerConnected && (
            <View style={styles.buttonContainer}>
              <Text style={styles.connectedText}>
                {partnerName} ◊û◊ó◊ï◊ë◊®/◊™!
              </Text>
              <Button
                title="◊î◊™◊ó◊ô◊ú◊ï ◊ó◊ô◊ì◊ï◊ü"
                onPress={handleStartQuiz}
                variant="primary"
                size="large"
                fullWidth
              />
            </View>
          )}
        </View>
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: spacing.xl,
  },
  title: {
    ...typography.h2,
    color: colors.text.primary,
    marginBottom: spacing.xl,
  },
  codeContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginBottom: spacing.xl,
  },
  codeDigit: {
    width: 60,
    height: 80,
    backgroundColor: colors.background.secondary,
    borderWidth: 2,
    borderColor: colors.accent.gold,
    borderRadius: borderRadius.lg,
    alignItems: 'center',
    justifyContent: 'center',
    marginHorizontal: spacing.xs,
  },
  codeText: {
    ...typography.h1,
    color: colors.text.primary,
    fontSize: 36,
  },
  instruction: {
    ...typography.body,
    color: colors.text.secondary,
    textAlign: 'center',
    marginBottom: spacing['2xl'],
  },
  statusCard: {
    width: '100%',
    padding: spacing.lg,
    marginTop: spacing.xl,
  },
  statusRow: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    paddingVertical: spacing.sm,
  },
  statusDot: {
    width: 12,
    height: 12,
    borderRadius: 6,
    marginLeft: spacing.md,
  },
  connected: {
    backgroundColor: colors.state.success,
  },
  waiting: {
    backgroundColor: colors.text.muted,
  },
  statusName: {
    ...typography.body,
    color: colors.text.primary,
    flex: 1,
    textAlign: 'right',
  },
  statusDivider: {
    height: 1,
    backgroundColor: colors.alpha[10],
    marginVertical: spacing.xs,
  },
  loader: {
    marginRight: spacing.md,
  },
  buttonContainer: {
    width: '100%',
    marginTop: spacing['3xl'],
    alignItems: 'center',
  },
  connectedText: {
    ...typography.body,
    color: colors.state.success,
    marginBottom: spacing.md,
  },
});

export default QuizWaitingScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Quiz/index.ts
--------------------------------------------------------------------------------

export { default as QuizSetupScreen } from './QuizSetupScreen';
export { default as QuizWaitingScreen } from './QuizWaitingScreen';
export { default as QuizPlayScreen } from './QuizPlayScreen';
export { default as QuizResultsScreen } from './QuizResultsScreen';

--------------------------------------------------------------------------------
FILE: src/screens/Results/ResultsScreen.tsx
--------------------------------------------------------------------------------

/**
 * Results Screen - ◊°◊ô◊ï◊ù
 *
 * ◊û◊°◊ö ◊°◊ô◊ï◊ù ◊¢◊ù ◊°◊ô◊õ◊ï◊ù ◊ï◊ò◊ß◊°◊ò ◊ì"◊® ◊ó◊®◊ô◊£
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Share,
} from 'react-native';
import { useNavigation, CommonActions } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useGameStore } from '@/store/gameStore';
import { endingText, tieEndingText } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'Results'>;

export const ResultsScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { player1, player2, getWinner, resetGame } = useGameStore();
  const [showButtons, setShowButtons] = useState(false);

  const winner = getWinner();
  const isTie = !winner;

  const endText = isTie ? tieEndingText : endingText(winner?.name || '');

  const handleTypingComplete = () => {
    setShowButtons(true);
  };

  const handleShare = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    try {
      await Share.share({
        message: `◊©◊ô◊ó◊ß◊†◊ï ◊ë"◊ñ◊ï◊í◊ô◊ò" üç∑\n${player1.name}: ${player1.score} ◊†◊ß◊ï◊ì◊ï◊™\n${player2.name}: ${player2.score} ◊†◊ß◊ï◊ì◊ï◊™\n\n◊î◊¢◊®◊ë ◊©◊ú◊ê ◊™◊°◊§◊®◊ï ◊¢◊ú◊ô◊ï ◊ë◊ß◊ë◊ï◊¶◊™ ◊î◊ï◊®◊ô◊ù`,
      });
    } catch (error) {
      console.log('Share error:', error);
    }
  };

  const handlePlayAgain = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    resetGame();
    navigation.dispatch(
      CommonActions.reset({
        index: 0,
        routes: [{ name: 'Splash' }],
      })
    );
  };

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Final scores */}
        <View style={styles.scoresSection}>
          <Text style={styles.title}>◊°◊ô◊ï◊ù</Text>

          <View style={styles.finalScores}>
            <View style={[
              styles.playerFinalScore,
              winner?.id === 'player1' && styles.winnerScore,
            ]}>
              {winner?.id === 'player1' && (
                <Text style={styles.crownEmoji}>üëë</Text>
              )}
              <Text style={styles.finalName}>{player1.name}</Text>
              <Text style={styles.finalScore}>{player1.score}</Text>
            </View>

            <View style={styles.vsContainer}>
              <Text style={styles.vsText}>VS</Text>
            </View>

            <View style={[
              styles.playerFinalScore,
              winner?.id === 'player2' && styles.winnerScore,
            ]}>
              {winner?.id === 'player2' && (
                <Text style={styles.crownEmoji}>üëë</Text>
              )}
              <Text style={styles.finalName}>{player2.name}</Text>
              <Text style={styles.finalScore}>{player2.score}</Text>
            </View>
          </View>

          {isTie && (
            <Text style={styles.tieText}>◊™◊ô◊ß◊ï!</Text>
          )}
        </View>

        {/* Dr. Charif ending message */}
        <View style={styles.messageContainer}>
          <DrCharifMessage
            lines={endText.lines}
            onComplete={handleTypingComplete}
            variant="minimal"
          />
        </View>

        {/* Action buttons */}
        {showButtons && (
          <View style={styles.buttonsContainer}>
            <Button
              title="◊©◊™◊§◊ï ◊ê◊™ ◊î◊¢◊®◊ë"
              onPress={handleShare}
              variant="secondary"
              fullWidth
              style={styles.shareButton}
            />
            <Button
              title="◊©◊ó◊ß◊ï ◊©◊ï◊ë"
              onPress={handlePlayAgain}
              variant="ghost"
              style={styles.playAgainButton}
            />
          </View>
        )}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: spacing['2xl'],
  },
  scoresSection: {
    alignItems: 'center',
    paddingBottom: spacing.xl,
    borderBottomWidth: 1,
    borderBottomColor: colors.alpha[10],
    marginHorizontal: spacing.lg,
  },
  title: {
    ...typography.h3,
    color: colors.text.secondary,
    marginBottom: spacing.xl,
  },
  finalScores: {
    flexDirection: 'row-reverse',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%',
  },
  playerFinalScore: {
    flex: 1,
    alignItems: 'center',
    padding: spacing.lg,
  },
  winnerScore: {
    backgroundColor: colors.background.secondary,
    borderRadius: borderRadius.lg,
    borderWidth: 1,
    borderColor: colors.accent.gold,
  },
  crownEmoji: {
    fontSize: 24,
    marginBottom: spacing.xs,
  },
  finalName: {
    ...typography.body,
    color: colors.text.secondary,
    marginBottom: spacing.xs,
  },
  finalScore: {
    ...typography.h1,
    color: colors.text.primary,
    fontSize: 48,
  },
  vsContainer: {
    paddingHorizontal: spacing.md,
  },
  vsText: {
    ...typography.bodySmall,
    color: colors.text.muted,
  },
  tieText: {
    ...typography.h3,
    color: colors.accent.gold,
    marginTop: spacing.lg,
  },
  messageContainer: {
    flex: 1,
    justifyContent: 'center',
    paddingVertical: spacing.xl,
  },
  buttonsContainer: {
    paddingHorizontal: spacing.xl,
    paddingBottom: spacing['3xl'],
  },
  shareButton: {
    marginBottom: spacing.md,
  },
  playAgainButton: {
    alignSelf: 'center',
  },
});

export default ResultsScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Results/WheelScreen.tsx
--------------------------------------------------------------------------------

/**
 * Wheel Screen - ◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú
 *
 * ◊í◊ú◊í◊ú ◊¢◊ù 15 ◊§◊®◊°◊ô◊ù ◊ú◊û◊†◊¶◊ó
 */

import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  Easing,
  TouchableOpacity,
  Dimensions,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import * as Haptics from 'expo-haptics';

import { ScreenContainer, Button, Card } from '@/components/common';
import { DrCharifMessage } from '@/components/drCharif';
import { useGameStore } from '@/store/gameStore';
import { prizes, Prize, getRandomPrize } from '@/data/prizes';
import { wheelIntroText } from '@/data/drCharifTexts';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'Wheel'>;

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const WHEEL_SIZE = SCREEN_WIDTH * 0.8;

export const WheelScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const { player1, player2, getWinner } = useGameStore();

  const [step, setStep] = useState<'intro' | 'spin' | 'result'>('intro');
  const [showSpinButton, setShowSpinButton] = useState(false);
  const [isSpinning, setIsSpinning] = useState(false);
  const [selectedPrize, setSelectedPrize] = useState<Prize | null>(null);

  const spinValue = useRef(new Animated.Value(0)).current;

  const winner = getWinner();
  const loser = winner?.id === 'player1' ? player2 : player1;

  const handleIntroComplete = () => {
    setShowSpinButton(true);
  };

  const handleContinueToSpin = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    setStep('spin');
  };

  const handleSpin = async () => {
    if (isSpinning) return;

    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
    setIsSpinning(true);

    // Select random prize
    const prize = getRandomPrize();
    setSelectedPrize(prize);

    // Calculate rotation (multiple full rotations + landing on prize)
    const prizeIndex = prizes.findIndex((p) => p.id === prize.id);
    const degreesPerSlice = 360 / prizes.length;
    const targetDegree = 360 * 5 + (degreesPerSlice * prizeIndex); // 5 full rotations + prize position

    // Animate spin
    Animated.timing(spinValue, {
      toValue: targetDegree,
      duration: 4000,
      easing: Easing.out(Easing.cubic),
      useNativeDriver: true,
    }).start(() => {
      setIsSpinning(false);
      setStep('result');
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    });

    // Haptic feedback during spin
    let count = 0;
    const hapticInterval = setInterval(() => {
      if (count < 20) {
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        count++;
      } else {
        clearInterval(hapticInterval);
      }
    }, 150);
  };

  const handleContinue = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    navigation.navigate('Results');
  };

  const spin = spinValue.interpolate({
    inputRange: [0, 360],
    outputRange: ['0deg', '360deg'],
  });

  const renderIntro = () => (
    <View style={styles.content}>
      <DrCharifMessage
        lines={wheelIntroText.lines}
        onComplete={handleIntroComplete}
      />
      {showSpinButton && (
        <View style={styles.buttonContainer}>
          <Button
            title="◊ú◊í◊ú◊í◊ú"
            onPress={handleContinueToSpin}
            variant="primary"
            size="large"
          />
        </View>
      )}
    </View>
  );

  const renderWheel = () => (
    <View style={styles.wheelContainer}>
      {winner && (
        <Text style={styles.winnerLabel}>◊î◊ñ◊ï◊õ◊î: {winner.name}</Text>
      )}

      {/* Wheel */}
      <View style={styles.wheelWrapper}>
        {/* Pointer */}
        <View style={styles.pointer}>
          <Text style={styles.pointerArrow}>‚ñº</Text>
        </View>

        {/* Wheel */}
        <Animated.View
          style={[
            styles.wheel,
            { transform: [{ rotate: spin }] },
          ]}
        >
          {prizes.map((prize, index) => {
            const rotation = (360 / prizes.length) * index;
            return (
              <View
                key={prize.id}
                style={[
                  styles.wheelSlice,
                  {
                    transform: [
                      { rotate: `${rotation}deg` },
                      { translateX: WHEEL_SIZE / 4 },
                    ],
                  },
                ]}
              >
                <Text style={styles.wheelEmoji}>{prize.emoji}</Text>
              </View>
            );
          })}
        </Animated.View>
      </View>

      {/* Spin button */}
      {!isSpinning && step === 'spin' && (
        <TouchableOpacity
          style={styles.spinButton}
          onPress={handleSpin}
          activeOpacity={0.8}
        >
          <Text style={styles.spinButtonText}>◊°◊ï◊ë◊ë</Text>
        </TouchableOpacity>
      )}

      {isSpinning && (
        <Text style={styles.spinningText}>◊û◊°◊™◊ï◊ë◊ë...</Text>
      )}
    </View>
  );

  const renderResult = () => (
    <View style={styles.resultContainer}>
      {selectedPrize && (
        <>
          <Text style={styles.prizeEmoji}>{selectedPrize.emoji}</Text>
          <Text style={styles.prizeName}>{selectedPrize.name}</Text>

          <Card variant="bordered" style={styles.prizeCard}>
            <Text style={styles.prizeDescription}>
              {selectedPrize.description}
            </Text>
            <View style={styles.intensityRow}>
              {[1, 2, 3].map((i) => (
                <Text
                  key={i}
                  style={[
                    styles.intensityIcon,
                    i <= selectedPrize.intensity && styles.intensityActive,
                  ]}
                >
                  üî•
                </Text>
              ))}
            </View>
          </Card>

          {winner && loser && (
            <Text style={styles.winnerMessage}>
              {winner.name} ◊ë◊ï◊ó◊®/◊™, {loser.name} ◊û◊ë◊¶◊¢/◊™!
            </Text>
          )}

          <View style={styles.buttonContainer}>
            <Button
              title="◊°◊ô◊ï◊ù"
              onPress={handleContinue}
              variant="primary"
              size="large"
              fullWidth
            />
          </View>
        </>
      )}
    </View>
  );

  return (
    <ScreenContainer>
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.title}>◊í◊ú◊í◊ú ◊î◊û◊ñ◊ú</Text>
        </View>

        {/* Content */}
        {step === 'intro' && renderIntro()}
        {step === 'spin' && renderWheel()}
        {step === 'result' && renderResult()}
      </View>
    </ScreenContainer>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    paddingTop: spacing['2xl'],
    paddingBottom: spacing.lg,
  },
  title: {
    ...typography.h2,
    color: colors.text.primary,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
  },
  buttonContainer: {
    paddingHorizontal: spacing.xl,
    marginTop: spacing['2xl'],
    alignItems: 'center',
  },
  wheelContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  winnerLabel: {
    ...typography.h4,
    color: colors.accent.gold,
    marginBottom: spacing.xl,
  },
  wheelWrapper: {
    position: 'relative',
    width: WHEEL_SIZE,
    height: WHEEL_SIZE,
    alignItems: 'center',
  },
  pointer: {
    position: 'absolute',
    top: -20,
    zIndex: 10,
  },
  pointerArrow: {
    fontSize: 32,
    color: colors.accent.gold,
  },
  wheel: {
    width: WHEEL_SIZE,
    height: WHEEL_SIZE,
    borderRadius: WHEEL_SIZE / 2,
    backgroundColor: colors.background.secondary,
    borderWidth: 3,
    borderColor: colors.accent.gold,
    alignItems: 'center',
    justifyContent: 'center',
  },
  wheelSlice: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
  },
  wheelEmoji: {
    fontSize: 24,
  },
  spinButton: {
    marginTop: spacing['2xl'],
    backgroundColor: colors.accent.wine,
    paddingVertical: spacing.lg,
    paddingHorizontal: spacing['4xl'],
    borderRadius: borderRadius.full,
  },
  spinButtonText: {
    ...typography.h3,
    color: colors.text.primary,
  },
  spinningText: {
    ...typography.body,
    color: colors.text.secondary,
    marginTop: spacing.xl,
  },
  resultContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: spacing.xl,
  },
  prizeEmoji: {
    fontSize: 80,
    marginBottom: spacing.md,
  },
  prizeName: {
    ...typography.h1,
    color: colors.text.primary,
    marginBottom: spacing.lg,
  },
  prizeCard: {
    width: '100%',
    padding: spacing.xl,
    alignItems: 'center',
    marginBottom: spacing.xl,
  },
  prizeDescription: {
    ...typography.body,
    color: colors.text.secondary,
    textAlign: 'center',
    lineHeight: 24,
  },
  intensityRow: {
    flexDirection: 'row',
    marginTop: spacing.md,
  },
  intensityIcon: {
    fontSize: 20,
    opacity: 0.3,
    marginHorizontal: spacing.xs,
  },
  intensityActive: {
    opacity: 1,
  },
  winnerMessage: {
    ...typography.body,
    color: colors.accent.gold,
    textAlign: 'center',
    marginBottom: spacing.xl,
  },
});

export default WheelScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Results/index.ts
--------------------------------------------------------------------------------

export { default as WheelScreen } from './WheelScreen';
export { default as ResultsScreen } from './ResultsScreen';

--------------------------------------------------------------------------------
FILE: src/screens/Splash/SplashScreen.tsx
--------------------------------------------------------------------------------

/**
 * Splash Screen - "◊î◊§◊®◊ï◊ñ◊ì◊ï◊®"
 *
 * ◊û◊°◊ö ◊©◊ó◊ï◊® ◊¢◊ù ◊ò◊ß◊°◊ò ◊û◊ï◊§◊ô◊¢ ◊û◊ô◊ú◊î ◊ê◊ó◊®◊ô ◊û◊ô◊ú◊î
 */

import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  Animated,
  TouchableOpacity,
  Text,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { LinearGradient } from 'expo-linear-gradient';
import { StatusBar } from 'expo-status-bar';
import * as Haptics from 'expo-haptics';

import { TypewriterText } from '@/components/drCharif';
import { colors } from '@/theme/colors';
import { typography } from '@/theme/fonts';
import { spacing, borderRadius } from '@/theme/spacing';
import { splashTexts } from '@/data/drCharifTexts';
import { RootStackParamList } from '@/navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList, 'Splash'>;

export const SplashScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();
  const [showButton, setShowButton] = useState(false);
  const buttonOpacity = useState(new Animated.Value(0))[0];

  const handleTypingComplete = () => {
    setShowButton(true);
    Animated.timing(buttonOpacity, {
      toValue: 1,
      duration: 800,
      useNativeDriver: true,
    }).start();
  };

  const handleEnter = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    navigation.navigate('Onboarding');
  };

  return (
    <LinearGradient
      colors={[colors.background.primary, colors.background.secondary]}
      style={styles.container}
    >
      <StatusBar style="light" />

      <View style={styles.content}>
        <TypewriterText
          lines={splashTexts.lines}
          onComplete={handleTypingComplete}
          speed="normal"
        />

        {showButton && (
          <Animated.View style={[styles.buttonContainer, { opacity: buttonOpacity }]}>
            <TouchableOpacity
              style={styles.button}
              onPress={handleEnter}
              activeOpacity={0.8}
            >
              <Text style={styles.buttonText}>◊ú◊î◊ô◊õ◊†◊°</Text>
            </TouchableOpacity>
          </Animated.View>
        )}
      </View>
    </LinearGradient>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: spacing.xl,
  },
  buttonContainer: {
    marginTop: spacing['4xl'],
    alignItems: 'center',
  },
  button: {
    paddingVertical: spacing.lg,
    paddingHorizontal: spacing['4xl'],
    borderWidth: 1,
    borderColor: colors.accent.gold,
    borderRadius: borderRadius.full,
  },
  buttonText: {
    ...typography.button,
    color: colors.accent.gold,
    fontSize: 18,
  },
});

export default SplashScreen;

--------------------------------------------------------------------------------
FILE: src/screens/Splash/index.ts
--------------------------------------------------------------------------------

export { default as SplashScreen } from './SplashScreen';

--------------------------------------------------------------------------------
FILE: src/screens/index.ts
--------------------------------------------------------------------------------

export * from './Splash';
export * from './Onboarding';
export * from './Game';
export * from './Paywall';
export * from './Quiz';
export * from './Results';

--------------------------------------------------------------------------------
FILE: src/services/firebase.ts
--------------------------------------------------------------------------------

import { initializeApp } from 'firebase/app';
import {
  getDatabase,
  ref,
  set,
  get,
  onValue,
  off,
  update,
  remove,
} from 'firebase/database';

const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_PROJECT.firebaseapp.com",
  databaseURL: "https://YOUR_PROJECT-default-rtdb.firebaseio.com",
  projectId: "YOUR_PROJECT",
  storageBucket: "YOUR_PROJECT.appspot.com",
  messagingSenderId: "YOUR_SENDER_ID",
  appId: "YOUR_APP_ID"
};

const app = initializeApp(firebaseConfig);
const database = getDatabase(app);

export interface QuizRoom {
  hostId: string;
  hostName: string;
  guestId?: string;
  guestName?: string;
  status: 'waiting' | 'playing' | 'finished';
  currentQuestion: number;
  questions: string[];
  answers: {
    [index: number]: {
      host?: { self: number; partner: number };
      guest?: { self: number; partner: number };
    };
  };
  createdAt: number;
}

export const createQuizRoom = async (
  roomCode: string,
  hostName: string,
  questionIds: string[]
): Promise<void> => {
  const roomRef = ref(database, `rooms/${roomCode}`);
  await set(roomRef, {
    hostId: `host_${Date.now()}`,
    hostName,
    status: 'waiting',
    currentQuestion: 0,
    questions: questionIds,
    answers: {},
    createdAt: Date.now(),
  });
};

export const joinQuizRoom = async (
  roomCode: string,
  guestName: string
): Promise<QuizRoom | null> => {
  const roomRef = ref(database, `rooms/${roomCode}`);
  const snapshot = await get(roomRef);

  if (!snapshot.exists()) return null;

  await update(roomRef, {
    guestId: `guest_${Date.now()}`,
    guestName,
    status: 'playing',
  });

  return snapshot.val();
};

export const submitQuizAnswer = async (
  roomCode: string,
  questionIndex: number,
  isHost: boolean,
  selfAnswer: number,
  partnerAnswer: number
): Promise<void> => {
  const path = `rooms/${roomCode}/answers/${questionIndex}/${isHost ? 'host' : 'guest'}`;
  await set(ref(database, path), { self: selfAnswer, partner: partnerAnswer });
};

export const subscribeToRoom = (
  roomCode: string,
  callback: (room: QuizRoom | null) => void
): (() => void) => {
  const roomRef = ref(database, `rooms/${roomCode}`);
  onValue(roomRef, (snapshot) => {
    callback(snapshot.exists() ? snapshot.val() : null);
  });
  return () => off(roomRef);
};

export const deleteQuizRoom = async (roomCode: string): Promise<void> => {
  const roomRef = ref(database, `rooms/${roomCode}`);
  await remove(roomRef);
};

export const updateQuizRoom = async (
  roomCode: string,
  updates: Partial<QuizRoom>
): Promise<void> => {
  const roomRef = ref(database, `rooms/${roomCode}`);
  await update(roomRef, updates);
};

export { database };

--------------------------------------------------------------------------------
FILE: src/store/gameStore.ts
--------------------------------------------------------------------------------

/**
 * Game Store - Zustand
 *
 * ◊†◊ô◊î◊ï◊ú ◊û◊¶◊ë ◊î◊û◊©◊ó◊ß ◊õ◊ï◊ú◊ú:
 * - ◊§◊®◊ò◊ô ◊©◊ó◊ß◊†◊ô◊ù
 * - ◊©◊ú◊ë◊ô◊ù ◊ï◊™◊ï◊®◊ï◊™
 * - ◊†◊ô◊ß◊ï◊ì ◊ï◊ò◊ï
 * - ◊û◊¶◊ë ◊û◊©◊ó◊ß
 */

import { create } from 'zustand';
import { Gender } from '@/components/common/GenderSelector';

// Types
export interface Player {
  id: 'player1' | 'player2';
  name: string;
  gender: Gender | null;
  score: number;
  vetosUsed: number;
  vetosRemaining: number;
}

export interface Turn {
  playerId: 'player1' | 'player2';
  itemId: string;
  type: 'question' | 'task';
  difficultyChosen: 1 | 2 | 3;
  pointsAvailable: number;
  vetoed: boolean;
  completed: boolean;
  answer?: string;
  partnerConfirmed?: boolean;
}

export interface StageProgress {
  stageId: number;
  stageName: string;
  currentItemIndex: number;
  totalItems: number;
  completed: boolean;
  turns: Turn[];
}

export type GamePhase =
  | 'splash'
  | 'onboarding'
  | 'intro'
  | 'playing'
  | 'paywall'
  | 'quiz_setup'
  | 'quiz_playing'
  | 'quiz_results'
  | 'wheel'
  | 'results';

export type IntensityLevel = 'soft' | 'medium' | 'spicy';

// Constants
export const MAX_VETOS_PER_PLAYER = 3;

export const POINTS = {
  difficulty: {
    1: 10,  // ◊ß◊ú
    2: 20,  // ◊ë◊ô◊†◊ï◊†◊ô
    3: 35,  // ◊ê◊û◊ô◊•
  },
  veto: -15,
  quizCorrect: 5,
} as const;

export const STAGES = [
  { id: 1, name: '◊®◊í◊¢ ◊ú◊§◊†◊ô ◊©◊†◊§◊í◊©◊†◊ï', items: 8, questionRatio: 0.7 },
  { id: 2, name: '◊î◊®◊û◊™ ◊õ◊ï◊°◊ô◊™', items: 8, questionRatio: 0.4 },
  { id: 3, name: '◊ì◊ë◊®◊ô◊ù ◊©◊ú◊ê ◊ê◊ï◊û◊®◊ô◊ù ◊ë◊ß◊ï◊ú', items: 8, questionRatio: 0.5 },
  { id: 4, name: '◊û◊ú◊ó◊û◊™ ◊î◊í◊ô◊®◊°◊ê◊ï◊™', items: 8, questionRatio: 0.8 },
  { id: 5, name: '◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊¢◊ï◊ú◊î', items: 8, questionRatio: 0.3 },
  { id: 6, name: '◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô', items: 24, questionRatio: 1.0 },
  { id: 7, name: '◊î◊°◊ô◊ï◊ù', items: 0, questionRatio: 0 },
] as const;

// Store State
interface GameState {
  // Players
  player1: Player;
  player2: Player;

  // Game state
  phase: GamePhase;
  currentStage: number;
  currentTurn: 'player1' | 'player2';
  stageProgress: StageProgress[];

  // Stage 5 intensity
  intensityLevel: IntensityLevel | null;

  // Premium
  isPremium: boolean;

  // Sound
  soundEnabled: boolean;

  // Quiz specific
  quizRoomCode: string | null;
  quizConnected: boolean;

  // Actions
  setPlayerName: (playerId: 'player1' | 'player2', name: string) => void;
  setPlayerGender: (playerId: 'player1' | 'player2', gender: Gender) => void;
  setPhase: (phase: GamePhase) => void;
  startGame: () => void;
  nextStage: () => void;
  nextTurn: () => void;
  selectDifficulty: (difficulty: 1 | 2 | 3) => void;
  completeQuestion: (answer: string) => void;
  completeTask: (partnerConfirmed: boolean) => void;
  useVeto: () => void;
  setIntensityLevel: (level: IntensityLevel) => void;
  setPremium: (isPremium: boolean) => void;
  toggleSound: () => void;
  setQuizRoomCode: (code: string | null) => void;
  setQuizConnected: (connected: boolean) => void;
  resetGame: () => void;
  getCurrentPlayer: () => Player;
  getPartner: () => Player;
  getWinner: () => Player | null;
}

const initialPlayer = (id: 'player1' | 'player2'): Player => ({
  id,
  name: '',
  gender: null,
  score: 0,
  vetosUsed: 0,
  vetosRemaining: MAX_VETOS_PER_PLAYER,
});

export const useGameStore = create<GameState>((set, get) => ({
  // Initial state
  player1: initialPlayer('player1'),
  player2: initialPlayer('player2'),
  phase: 'splash',
  currentStage: 0,
  currentTurn: 'player1',
  stageProgress: [],
  intensityLevel: null,
  isPremium: false,
  soundEnabled: true,
  quizRoomCode: null,
  quizConnected: false,

  // Actions
  setPlayerName: (playerId, name) => {
    set((state) => ({
      [playerId]: { ...state[playerId], name },
    }));
  },

  setPlayerGender: (playerId, gender) => {
    set((state) => ({
      [playerId]: { ...state[playerId], gender },
    }));
  },

  setPhase: (phase) => {
    set({ phase });
  },

  startGame: () => {
    const stageProgress: StageProgress[] = STAGES.slice(0, 5).map((stage) => ({
      stageId: stage.id,
      stageName: stage.name,
      currentItemIndex: 0,
      totalItems: stage.items,
      completed: false,
      turns: [],
    }));

    set({
      phase: 'playing',
      currentStage: 1,
      currentTurn: 'player1',
      stageProgress,
    });
  },

  nextStage: () => {
    const { currentStage, isPremium } = get();
    const nextStageNum = currentStage + 1;

    // Check for paywall after stage 2
    if (nextStageNum === 3 && !isPremium) {
      set({ phase: 'paywall' });
      return;
    }

    // Check if moving to quiz (stage 6)
    if (nextStageNum === 6) {
      set({
        currentStage: 6,
        phase: 'quiz_setup',
      });
      return;
    }

    // Check if game complete
    if (nextStageNum > 7) {
      set({ phase: 'results' });
      return;
    }

    // Mark current stage as complete
    set((state) => {
      const newProgress = [...state.stageProgress];
      const currentProgress = newProgress.find((p) => p.stageId === currentStage);
      if (currentProgress) {
        currentProgress.completed = true;
      }
      return {
        stageProgress: newProgress,
        currentStage: nextStageNum,
        currentTurn: 'player1',
      };
    });
  },

  nextTurn: () => {
    set((state) => ({
      currentTurn: state.currentTurn === 'player1' ? 'player2' : 'player1',
    }));
  },

  selectDifficulty: (difficulty) => {
    const { currentStage, currentTurn, stageProgress } = get();
    const points = POINTS.difficulty[difficulty];

    set((state) => {
      const newProgress = [...state.stageProgress];
      const currentProgress = newProgress.find((p) => p.stageId === currentStage);

      if (currentProgress) {
        const turn: Turn = {
          playerId: currentTurn,
          itemId: `${currentStage}_${currentProgress.currentItemIndex}`,
          type: Math.random() < STAGES[currentStage - 1].questionRatio ? 'question' : 'task',
          difficultyChosen: difficulty,
          pointsAvailable: points,
          vetoed: false,
          completed: false,
        };
        currentProgress.turns.push(turn);
      }

      return { stageProgress: newProgress };
    });
  },

  completeQuestion: (answer) => {
    const { currentStage, currentTurn, stageProgress } = get();

    set((state) => {
      const newProgress = [...state.stageProgress];
      const currentProgress = newProgress.find((p) => p.stageId === currentStage);

      if (currentProgress && currentProgress.turns.length > 0) {
        const lastTurn = currentProgress.turns[currentProgress.turns.length - 1];
        lastTurn.completed = true;
        lastTurn.answer = answer;

        // Add points
        const player = state[currentTurn];
        const newScore = player.score + lastTurn.pointsAvailable;

        // Move to next item
        currentProgress.currentItemIndex++;

        return {
          stageProgress: newProgress,
          [currentTurn]: { ...player, score: newScore },
        };
      }

      return { stageProgress: newProgress };
    });
  },

  completeTask: (partnerConfirmed) => {
    const { currentStage, currentTurn, stageProgress } = get();

    set((state) => {
      const newProgress = [...state.stageProgress];
      const currentProgress = newProgress.find((p) => p.stageId === currentStage);

      if (currentProgress && currentProgress.turns.length > 0) {
        const lastTurn = currentProgress.turns[currentProgress.turns.length - 1];
        lastTurn.completed = true;
        lastTurn.partnerConfirmed = partnerConfirmed;

        const player = state[currentTurn];
        let newScore = player.score;
        let newVetosUsed = player.vetosUsed;
        let newVetosRemaining = player.vetosRemaining;

        if (partnerConfirmed) {
          // Task completed successfully
          newScore += lastTurn.pointsAvailable;
        } else {
          // Auto veto
          lastTurn.vetoed = true;
          newScore += POINTS.veto;
          newVetosUsed++;
          newVetosRemaining--;
        }

        // Move to next item
        currentProgress.currentItemIndex++;

        return {
          stageProgress: newProgress,
          [currentTurn]: {
            ...player,
            score: newScore,
            vetosUsed: newVetosUsed,
            vetosRemaining: newVetosRemaining,
          },
        };
      }

      return { stageProgress: newProgress };
    });
  },

  useVeto: () => {
    const { currentStage, currentTurn, stageProgress } = get();

    set((state) => {
      const player = state[currentTurn];

      if (player.vetosRemaining <= 0) {
        return state;
      }

      const newProgress = [...state.stageProgress];
      const currentProgress = newProgress.find((p) => p.stageId === currentStage);

      if (currentProgress && currentProgress.turns.length > 0) {
        const lastTurn = currentProgress.turns[currentProgress.turns.length - 1];
        lastTurn.vetoed = true;
        lastTurn.completed = true;

        // Move to next item
        currentProgress.currentItemIndex++;

        return {
          stageProgress: newProgress,
          [currentTurn]: {
            ...player,
            score: player.score + POINTS.veto,
            vetosUsed: player.vetosUsed + 1,
            vetosRemaining: player.vetosRemaining - 1,
          },
        };
      }

      return state;
    });
  },

  setIntensityLevel: (level) => {
    set({ intensityLevel: level });
  },

  setPremium: (isPremium) => {
    set({ isPremium });
  },

  toggleSound: () => {
    set((state) => ({ soundEnabled: !state.soundEnabled }));
  },

  setQuizRoomCode: (code) => {
    set({ quizRoomCode: code });
  },

  setQuizConnected: (connected) => {
    set({ quizConnected: connected });
  },

  resetGame: () => {
    set({
      player1: { ...initialPlayer('player1'), name: get().player1.name, gender: get().player1.gender },
      player2: { ...initialPlayer('player2'), name: get().player2.name, gender: get().player2.gender },
      phase: 'splash',
      currentStage: 0,
      currentTurn: 'player1',
      stageProgress: [],
      intensityLevel: null,
      quizRoomCode: null,
      quizConnected: false,
    });
  },

  getCurrentPlayer: () => {
    const { currentTurn, player1, player2 } = get();
    return currentTurn === 'player1' ? player1 : player2;
  },

  getPartner: () => {
    const { currentTurn, player1, player2 } = get();
    return currentTurn === 'player1' ? player2 : player1;
  },

  getWinner: () => {
    const { player1, player2 } = get();
    if (player1.score > player2.score) return player1;
    if (player2.score > player1.score) return player2;
    return null; // Tie
  },
}));

export default useGameStore;

--------------------------------------------------------------------------------
FILE: src/store/index.ts
--------------------------------------------------------------------------------

export { useGameStore, type Player, type Turn, type StageProgress, type GamePhase, type IntensityLevel, POINTS, STAGES, MAX_VETOS_PER_PLAYER } from './gameStore';
export { useQuizStore, type QuizQuestion, type QuizAnswer, type QuizResult } from './quizStore';

--------------------------------------------------------------------------------
FILE: src/store/quizStore.ts
--------------------------------------------------------------------------------

/**
 * Quiz Store - Zustand
 *
 * ◊†◊ô◊î◊ï◊ú ◊û◊¶◊ë ◊î◊ó◊ô◊ì◊ï◊ü ◊î◊ñ◊ï◊í◊ô ◊õ◊ï◊ú◊ú:
 * - ◊°◊†◊õ◊®◊ï◊ü ◊ë◊ô◊ü ◊û◊õ◊©◊ô◊®◊ô◊ù
 * - ◊™◊©◊ï◊ë◊ï◊™ ◊ï◊™◊ï◊¶◊ê◊ï◊™
 */

import { create } from 'zustand';

export interface QuizQuestion {
  id: string;
  category: 'past' | 'daily' | 'dreams' | 'intimacy' | 'dilemmas' | 'us';
  text: string;
  options: string[];
}

export interface QuizAnswer {
  questionId: string;
  selfAnswer: number; // index of chosen option for self
  partnerAnswer: number; // index of chosen option for partner
}

export interface QuizResult {
  questionId: string;
  player1SelfAnswer: number;
  player1PartnerAnswer: number;
  player2SelfAnswer: number;
  player2PartnerAnswer: number;
  player1Correct: boolean; // player1 guessed player2's answer correctly
  player2Correct: boolean; // player2 guessed player1's answer correctly
}

interface QuizState {
  // Room state
  roomCode: string | null;
  isHost: boolean;
  partnerConnected: boolean;

  // Quiz progress
  questions: QuizQuestion[];
  currentQuestionIndex: number;
  totalQuestions: number;

  // Answers
  myAnswers: QuizAnswer[];
  partnerAnswers: QuizAnswer[];
  results: QuizResult[];

  // Current question state
  currentSelfAnswer: number | null;
  currentPartnerAnswer: number | null;
  partnerHasAnswered: boolean;

  // Scores
  player1Score: number;
  player2Score: number;

  // Actions
  createRoom: () => string;
  joinRoom: (code: string) => void;
  setPartnerConnected: (connected: boolean) => void;
  setQuestions: (questions: QuizQuestion[]) => void;
  setCurrentSelfAnswer: (index: number) => void;
  setCurrentPartnerAnswer: (index: number) => void;
  submitAnswer: () => void;
  setPartnerAnswer: (answer: QuizAnswer) => void;
  nextQuestion: () => void;
  calculateResults: () => void;
  resetQuiz: () => void;
}

// Generate 4-digit room code
const generateRoomCode = (): string => {
  return Math.floor(1000 + Math.random() * 9000).toString();
};

export const useQuizStore = create<QuizState>((set, get) => ({
  // Initial state
  roomCode: null,
  isHost: false,
  partnerConnected: false,
  questions: [],
  currentQuestionIndex: 0,
  totalQuestions: 24,
  myAnswers: [],
  partnerAnswers: [],
  results: [],
  currentSelfAnswer: null,
  currentPartnerAnswer: null,
  partnerHasAnswered: false,
  player1Score: 0,
  player2Score: 0,

  // Actions
  createRoom: () => {
    const code = generateRoomCode();
    set({
      roomCode: code,
      isHost: true,
      partnerConnected: false,
    });
    return code;
  },

  joinRoom: (code) => {
    set({
      roomCode: code,
      isHost: false,
      partnerConnected: true,
    });
  },

  setPartnerConnected: (connected) => {
    set({ partnerConnected: connected });
  },

  setQuestions: (questions) => {
    set({
      questions,
      totalQuestions: questions.length,
      currentQuestionIndex: 0,
    });
  },

  setCurrentSelfAnswer: (index) => {
    set({ currentSelfAnswer: index });
  },

  setCurrentPartnerAnswer: (index) => {
    set({ currentPartnerAnswer: index });
  },

  submitAnswer: () => {
    const { currentSelfAnswer, currentPartnerAnswer, questions, currentQuestionIndex, myAnswers } = get();

    if (currentSelfAnswer === null || currentPartnerAnswer === null) {
      return;
    }

    const answer: QuizAnswer = {
      questionId: questions[currentQuestionIndex].id,
      selfAnswer: currentSelfAnswer,
      partnerAnswer: currentPartnerAnswer,
    };

    set({
      myAnswers: [...myAnswers, answer],
    });
  },

  setPartnerAnswer: (answer) => {
    set((state) => ({
      partnerAnswers: [...state.partnerAnswers, answer],
      partnerHasAnswered: true,
    }));
  },

  nextQuestion: () => {
    const { currentQuestionIndex, totalQuestions } = get();

    if (currentQuestionIndex < totalQuestions - 1) {
      set({
        currentQuestionIndex: currentQuestionIndex + 1,
        currentSelfAnswer: null,
        currentPartnerAnswer: null,
        partnerHasAnswered: false,
      });
    }
  },

  calculateResults: () => {
    const { myAnswers, partnerAnswers, isHost } = get();

    const results: QuizResult[] = myAnswers.map((myAnswer, index) => {
      const partnerAnswer = partnerAnswers[index];

      if (!partnerAnswer) {
        return {
          questionId: myAnswer.questionId,
          player1SelfAnswer: isHost ? myAnswer.selfAnswer : partnerAnswer?.selfAnswer || 0,
          player1PartnerAnswer: isHost ? myAnswer.partnerAnswer : partnerAnswer?.partnerAnswer || 0,
          player2SelfAnswer: isHost ? partnerAnswer?.selfAnswer || 0 : myAnswer.selfAnswer,
          player2PartnerAnswer: isHost ? partnerAnswer?.partnerAnswer || 0 : myAnswer.partnerAnswer,
          player1Correct: false,
          player2Correct: false,
        };
      }

      const player1SelfAnswer = isHost ? myAnswer.selfAnswer : partnerAnswer.selfAnswer;
      const player1PartnerAnswer = isHost ? myAnswer.partnerAnswer : partnerAnswer.partnerAnswer;
      const player2SelfAnswer = isHost ? partnerAnswer.selfAnswer : myAnswer.selfAnswer;
      const player2PartnerAnswer = isHost ? partnerAnswer.partnerAnswer : myAnswer.partnerAnswer;

      // Player 1 is correct if they guessed Player 2's self-answer
      const player1Correct = player1PartnerAnswer === player2SelfAnswer;
      // Player 2 is correct if they guessed Player 1's self-answer
      const player2Correct = player2PartnerAnswer === player1SelfAnswer;

      return {
        questionId: myAnswer.questionId,
        player1SelfAnswer,
        player1PartnerAnswer,
        player2SelfAnswer,
        player2PartnerAnswer,
        player1Correct,
        player2Correct,
      };
    });

    const player1Score = results.filter((r) => r.player1Correct).length * 5;
    const player2Score = results.filter((r) => r.player2Correct).length * 5;

    set({
      results,
      player1Score,
      player2Score,
    });
  },

  resetQuiz: () => {
    set({
      roomCode: null,
      isHost: false,
      partnerConnected: false,
      questions: [],
      currentQuestionIndex: 0,
      myAnswers: [],
      partnerAnswers: [],
      results: [],
      currentSelfAnswer: null,
      currentPartnerAnswer: null,
      partnerHasAnswered: false,
      player1Score: 0,
      player2Score: 0,
    });
  },
}));

export default useQuizStore;

--------------------------------------------------------------------------------
FILE: src/theme/colors.ts
--------------------------------------------------------------------------------

/**
 * ◊§◊ú◊ò◊™ ◊¶◊ë◊¢◊ô◊ù ◊§◊®◊ô◊û◊ô◊ï◊ù - ◊ñ◊ï◊í◊ô◊ò
 * ◊û◊ë◊ï◊°◊° ◊¢◊ú ◊ê◊ï◊ï◊ô◊®◊™ ◊ë◊® ◊ô◊ô◊ü ◊ê◊ô◊†◊ò◊ô◊û◊ô
 *
 * "◊ë◊® ◊ô◊ô◊ü ◊ô◊ï◊ß◊®◊™◊ô ◊ë-1 ◊ë◊ú◊ô◊ú◊î" - ◊ê◊ô◊†◊ò◊ô◊û◊ô◊™, ◊û◊™◊ï◊ó◊õ◊û◊™, ◊ó◊û◊î.
 */

export const colors = {
  // ◊®◊ß◊¢◊ô◊ù - ◊í◊®◊ì◊ô◊ê◊†◊ò◊ô◊ù ◊¢◊û◊ï◊ß◊ô◊ù
  background: {
    primary: '#0D0714',      // ◊°◊í◊ï◊ú-◊©◊ó◊ï◊® ◊¢◊û◊ï◊ß (◊î◊ë◊°◊ô◊°)
    secondary: '#1A0F24',    // ◊°◊í◊ï◊ú ◊õ◊î◊î
    tertiary: '#251635',     // ◊°◊í◊ï◊ú ◊ë◊ô◊†◊ï◊†◊ô ◊ú◊ê◊ú◊û◊†◊ò◊ô◊ù
    card: 'rgba(255, 255, 255, 0.05)', // ◊ñ◊õ◊ï◊õ◊ô◊™ ◊©◊ß◊ï◊§◊î
    cardBorder: 'rgba(255, 255, 255, 0.1)',
    overlay: 'rgba(13, 7, 20, 0.9)', // ◊©◊õ◊ë◊™ overlay
  },

  // Glass Morphism
  glass: {
    background: 'rgba(255, 255, 255, 0.08)',
    backgroundStrong: 'rgba(255, 255, 255, 0.12)',
    border: 'rgba(255, 255, 255, 0.15)',
    borderLight: 'rgba(255, 255, 255, 0.08)',
    shadow: 'rgba(0, 0, 0, 0.3)',
  },

  // ◊ê◊ß◊°◊†◊ò◊ô◊ù - ◊ñ◊î◊ë ◊ï◊ï◊®◊ï◊ì
  accent: {
    gold: '#D4A574',         // ◊ñ◊î◊ë ◊ó◊û◊ô◊ù (◊®◊ê◊©◊ô)
    goldLight: '#E8C9A0',    // ◊ñ◊î◊ë ◊ë◊î◊ô◊®
    goldDark: '#B8956A',     // ◊ñ◊î◊ë ◊õ◊î◊î
    wine: '#722F37',         // ◊ë◊ï◊®◊ì◊ï/◊ô◊ô◊ü
    wineLight: '#8B3D47',    // ◊ë◊ï◊®◊ì◊ï ◊ë◊î◊ô◊®
    rose: '#C97B84',         // ◊ï◊®◊ï◊ì ◊¢◊™◊ô◊ß
    lavender: '#9D8CA1',     // ◊°◊í◊ï◊ú ◊ú◊ë◊†◊ì◊®
  },

  // ◊ò◊ß◊°◊ò
  text: {
    primary: '#FFFFFF',       // ◊ú◊ë◊ü ◊û◊ú◊ê ◊ú◊õ◊ï◊™◊®◊ï◊™
    secondary: 'rgba(255, 255, 255, 0.85)', // ◊ú◊ë◊ü ◊®◊ö ◊ú◊í◊ï◊£
    tertiary: 'rgba(255, 255, 255, 0.6)',   // ◊ú◊ë◊ü ◊¢◊û◊ï◊ù ◊ú◊û◊©◊†◊ô
    muted: 'rgba(255, 255, 255, 0.4)',      // ◊¢◊û◊ï◊ù ◊û◊ê◊ï◊ì
    gold: '#D4A574',          // ◊ñ◊î◊ë ◊ú◊ì◊í◊©◊ô◊ù
    inverse: '#0D0714',       // ◊ú◊ò◊ß◊°◊ò ◊¢◊ú ◊®◊ß◊¢ ◊ë◊î◊ô◊®
  },

  // ◊û◊¶◊ë◊ô◊ù
  status: {
    success: '#4CAF50',
    error: '#E57373',
    warning: '#FFB74D',
    info: '#5B6B8A',
  },

  // ◊í◊®◊ì◊ô◊ê◊†◊ò◊ô◊ù (◊ú◊©◊ô◊û◊ï◊© ◊¢◊ù LinearGradient)
  gradients: {
    background: ['#0D0714', '#1A0F24', '#0D0714'],
    card: ['rgba(255,255,255,0.1)', 'rgba(255,255,255,0.05)'],
    gold: ['#D4A574', '#E8C9A0', '#D4A574'],
    button: ['#D4A574', '#B8956A'],
    glow: ['rgba(212,165,116,0.3)', 'rgba(212,165,116,0)'],
    wine: ['#722F37', '#4A1D2E'],
  },

  // ◊®◊û◊ï◊™ ◊™◊¢◊ï◊ñ◊î
  difficulty: {
    easy: '#4A7C59',       // ◊ô◊®◊ï◊ß ◊¢◊û◊ï◊ù - ◊ß◊ú
    medium: '#9E7B4F',     // ◊õ◊™◊ï◊ù ◊¢◊û◊ï◊ù - ◊ë◊ô◊†◊ï◊†◊ô
    hard: '#8B3D48',       // ◊ê◊ì◊ï◊ù ◊¢◊û◊ï◊ù - ◊ê◊û◊ô◊•
  },

  // ◊ê◊§◊ß◊ò◊ô◊ù
  effects: {
    glow: 'rgba(212, 165, 116, 0.3)',  // ◊ñ◊ï◊î◊® ◊ñ◊î◊ë
    shadow: 'rgba(0, 0, 0, 0.5)',       // ◊¶◊ú
    glass: 'rgba(255, 255, 255, 0.05)', // glassmorphism
  },

  // ◊©◊ß◊ô◊§◊ï◊ô◊ï◊™
  alpha: {
    10: 'rgba(255, 255, 255, 0.1)',
    20: 'rgba(255, 255, 255, 0.2)',
    30: 'rgba(255, 255, 255, 0.3)',
    50: 'rgba(255, 255, 255, 0.5)',
  },
} as const;

export type ColorTheme = typeof colors;
export default colors;

--------------------------------------------------------------------------------
FILE: src/theme/fonts.ts
--------------------------------------------------------------------------------

/**
 * Zoogit Typography System
 *
 * ◊§◊ï◊†◊ò◊ô◊ù: Heebo ◊ú◊¢◊ë◊®◊ô◊™, Playfair Display ◊ú◊õ◊ï◊™◊®◊ï◊™
 */

export const fontFamilies = {
  // ◊¢◊ë◊®◊ô◊™ - Heebo
  heeboLight: 'Heebo-Light',
  heeboRegular: 'Heebo-Regular',
  heeboMedium: 'Heebo-Medium',
  heeboBold: 'Heebo-Bold',

  // ◊õ◊ï◊™◊®◊ï◊™ ◊ê◊†◊í◊ú◊ô◊ï◊™ - Playfair Display
  playfairRegular: 'PlayfairDisplay-Regular',
  playfairBold: 'PlayfairDisplay-Bold',
  playfairItalic: 'PlayfairDisplay-Italic',
} as const;

export const fontSizes = {
  xs: 12,
  sm: 14,
  md: 16,
  lg: 18,
  xl: 20,
  '2xl': 24,
  '3xl': 28,
  '4xl': 32,
  '5xl': 40,
  '6xl': 48,
} as const;

export const lineHeights = {
  tight: 1.2,
  normal: 1.5,
  relaxed: 1.75,
  loose: 2,
} as const;

export const fontWeights = {
  light: '300',
  regular: '400',
  medium: '500',
  bold: '700',
} as const;

// Typography presets for Hebrew text
export const typography = {
  // ◊õ◊ï◊™◊®◊ï◊™
  h1: {
    fontFamily: fontFamilies.heeboBold,
    fontSize: fontSizes['4xl'],
    lineHeight: lineHeights.tight,
  },
  h2: {
    fontFamily: fontFamilies.heeboBold,
    fontSize: fontSizes['3xl'],
    lineHeight: lineHeights.tight,
  },
  h3: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: fontSizes['2xl'],
    lineHeight: lineHeights.normal,
  },
  h4: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: fontSizes.xl,
    lineHeight: lineHeights.normal,
  },

  // ◊í◊ï◊£ ◊ò◊ß◊°◊ò
  bodyLarge: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: fontSizes.lg,
    lineHeight: lineHeights.relaxed,
  },
  body: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: fontSizes.md,
    lineHeight: lineHeights.relaxed,
  },
  bodySmall: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: fontSizes.sm,
    lineHeight: lineHeights.normal,
  },

  // ◊¶◊ô◊ò◊ï◊ò◊ô◊ù ◊ì"◊® ◊ó◊®◊ô◊£
  quote: {
    fontFamily: fontFamilies.heeboLight,
    fontSize: fontSizes.lg,
    lineHeight: lineHeights.loose,
    fontStyle: 'italic' as const,
  },
  quoteSmall: {
    fontFamily: fontFamilies.heeboLight,
    fontSize: fontSizes.md,
    lineHeight: lineHeights.relaxed,
    fontStyle: 'italic' as const,
  },

  // ◊õ◊§◊™◊ï◊®◊ô◊ù
  button: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: fontSizes.md,
    lineHeight: lineHeights.tight,
  },
  buttonSmall: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: fontSizes.sm,
    lineHeight: lineHeights.tight,
  },

  // ◊™◊ï◊ï◊ô◊ï◊™
  label: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: fontSizes.sm,
    lineHeight: lineHeights.normal,
  },
  caption: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: fontSizes.xs,
    lineHeight: lineHeights.normal,
  },
} as const;

export type Typography = typeof typography;

--------------------------------------------------------------------------------
FILE: src/theme/index.ts
--------------------------------------------------------------------------------

/**
 * Zoogit Theme - "Velvet Lounge" Premium
 *
 * ◊ë◊® ◊ô◊ô◊ü ◊§◊®◊ò◊ô ◊ë◊©◊¢◊î ◊ê◊ó◊™ ◊ë◊ú◊ô◊ú◊î.
 * Glass morphism, Gold accents, Soft gradients, Intimate lighting, Premium feel
 */

export * from './colors';
export * from './fonts';
export * from './spacing';
export * from './shadows';

import { colors } from './colors';
import { fontFamilies, fontSizes, lineHeights, fontWeights, typography } from './fonts';
import { spacing, borderRadius, layout } from './spacing';
import { shadows } from './shadows';

export const theme = {
  colors,
  fonts: {
    families: fontFamilies,
    sizes: fontSizes,
    lineHeights,
    weights: fontWeights,
  },
  typography,
  spacing,
  borderRadius,
  shadows,
  layout,
} as const;

export type Theme = typeof theme;

export default theme;

--------------------------------------------------------------------------------
FILE: src/theme/shadows.ts
--------------------------------------------------------------------------------

/**
 * ◊¶◊ú◊ú◊ô◊ù ◊ï-Glow effects
 */

import { colors } from './colors';

export const shadows = {
  // ◊ú◊ú◊ê ◊¶◊ú
  none: {
    shadowColor: 'transparent',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0,
    shadowRadius: 0,
    elevation: 0,
  },

  // ◊¶◊ú ◊®◊ö
  soft: {
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 4,
  },

  sm: {
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
    elevation: 2,
  },

  // ◊¶◊ú ◊ë◊ô◊†◊ï◊†◊ô
  medium: {
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.25,
    shadowRadius: 16,
    elevation: 8,
  },

  md: {
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },

  lg: {
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.25,
    shadowRadius: 16,
    elevation: 8,
  },

  // Glow ◊ñ◊î◊ë
  goldGlow: {
    shadowColor: '#D4A574',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.4,
    shadowRadius: 20,
    elevation: 10,
  },

  glow: {
    shadowColor: '#D4A574',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.4,
    shadowRadius: 12,
    elevation: 6,
  },

  // Glow ◊°◊í◊ï◊ú
  purpleGlow: {
    shadowColor: '#722F37',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.3,
    shadowRadius: 24,
    elevation: 8,
  },

  // Glass shadow
  glass: {
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 6,
  },
} as const;

export type Shadows = typeof shadows;
export default shadows;

--------------------------------------------------------------------------------
FILE: src/theme/spacing.ts
--------------------------------------------------------------------------------

/**
 * Zoogit Spacing System
 *
 * ◊û◊®◊ï◊ï◊ó◊ô◊ù ◊ï◊û◊ô◊û◊ì◊ô◊ù ◊ú◊¢◊ô◊¶◊ï◊ë ◊¢◊ß◊ë◊ô
 */

export const spacing = {
  // ◊û◊®◊ï◊ï◊ó◊ô◊ù ◊ë◊°◊ô◊°◊ô◊ô◊ù
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
  xxxl: 64,
  '2xl': 24,
  '3xl': 32,
  '4xl': 40,
  '5xl': 48,
  '6xl': 64,
  '7xl': 80,
  '8xl': 96,
} as const;

export const borderRadius = {
  none: 0,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  '2xl': 24,
  full: 9999,
} as const;

// Layout constants
export const layout = {
  screenPadding: spacing.xl,
  cardPadding: spacing.lg,
  contentMaxWidth: 400,
  headerHeight: 60,
  buttonHeight: 56,
  inputHeight: 52,
  iconSize: {
    sm: 16,
    md: 24,
    lg: 32,
    xl: 48,
  },
} as const;

export type Spacing = typeof spacing;
export type BorderRadius = typeof borderRadius;

--------------------------------------------------------------------------------
FILE: src/theme/typography.ts
--------------------------------------------------------------------------------

/**
 * ◊ò◊ô◊§◊ï◊í◊®◊§◊ô◊î ◊§◊®◊ô◊û◊ô◊ï◊ù
 * ◊¢◊ë◊®◊ô◊™: Heebo (◊†◊ß◊ô, ◊û◊ï◊ì◊®◊†◊ô)
 * ◊ì◊í◊©◊ô◊ù: Playfair Display (◊ê◊ú◊í◊†◊ò◊ô, ◊ô◊ï◊ß◊®◊™◊ô)
 */

import { StyleSheet, Platform } from 'react-native';
import { colors } from './colors';

export const fontFamilies = {
  // ◊¢◊ë◊®◊ô◊™
  heeboLight: 'Heebo-Light',
  heeboRegular: 'Heebo-Regular',
  heeboMedium: 'Heebo-Medium',
  heeboBold: 'Heebo-Bold',

  // ◊ê◊†◊í◊ú◊ô◊™/◊û◊°◊§◊®◊ô◊ù ◊ô◊ï◊ß◊®◊™◊ô◊ô◊ù
  playfairRegular: 'PlayfairDisplay-Regular',
  playfairBold: 'PlayfairDisplay-Bold',
  playfairItalic: 'PlayfairDisplay-Italic',
};

export const typography = StyleSheet.create({
  // ◊õ◊ï◊™◊®◊ï◊™
  heroTitle: {
    fontFamily: fontFamilies.heeboLight,
    fontSize: 36,
    lineHeight: 48,
    color: colors.text.primary,
    textAlign: 'center',
    letterSpacing: 1,
  },

  screenTitle: {
    fontFamily: fontFamilies.heeboBold,
    fontSize: 28,
    lineHeight: 36,
    color: colors.text.primary,
    textAlign: 'center',
  },

  sectionTitle: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: 20,
    lineHeight: 28,
    color: colors.text.primary,
  },

  // ◊í◊ï◊£ ◊ò◊ß◊°◊ò
  bodyLarge: {
    fontFamily: fontFamilies.heeboLight,
    fontSize: 22,
    lineHeight: 34,
    color: colors.text.secondary,
    textAlign: 'center',
  },

  body: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: 16,
    lineHeight: 26,
    color: colors.text.secondary,
  },

  bodySmall: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: 14,
    lineHeight: 22,
    color: colors.text.tertiary,
  },

  // ◊ì◊í◊©◊ô◊ù
  accent: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: 16,
    color: colors.accent.gold,
  },

  // ◊™◊ï◊ï◊ô◊ï◊™
  label: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: 12,
    lineHeight: 16,
    color: colors.text.muted,
    textTransform: 'uppercase',
    letterSpacing: 2,
  },

  // ◊õ◊§◊™◊ï◊®◊ô◊ù
  button: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: 16,
    color: colors.background.primary,
    letterSpacing: 0.5,
  },

  buttonSecondary: {
    fontFamily: fontFamilies.heeboRegular,
    fontSize: 16,
    color: colors.text.primary,
  },

  // ◊û◊°◊§◊®◊ô◊ù (◊¢◊ù ◊§◊ï◊†◊ò ◊ê◊ú◊í◊†◊ò◊ô)
  number: {
    fontFamily: fontFamilies.playfairRegular,
    fontSize: 32,
    color: colors.accent.gold,
  },

  numberLarge: {
    fontFamily: fontFamilies.playfairBold,
    fontSize: 48,
    color: colors.accent.gold,
  },

  // ◊©◊ù ◊û◊©◊™◊û◊©
  playerName: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: 18,
    color: colors.text.primary,
  },

  // ◊ì"◊® ◊ó◊®◊ô◊£
  drCharifSpeech: {
    fontFamily: fontFamilies.heeboLight,
    fontSize: 24,
    lineHeight: 40,
    color: colors.text.primary,
    textAlign: 'center',
  },

  drCharifLabel: {
    fontFamily: fontFamilies.heeboMedium,
    fontSize: 14,
    color: colors.accent.gold,
    letterSpacing: 1,
  },
});

export default typography;
